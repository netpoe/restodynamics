// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateCurrency {
  count: Int!
}

type AggregateExpenseUnit {
  count: Int!
}

type AggregateExpenseUnitCategory {
  count: Int!
}

type AggregateInventory {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateMeasurementUnit {
  count: Int!
}

type AggregateMerchandise {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Currency {
  id: ID!
  symbol: String!
  isDefault: Boolean
  createdAt: DateTime!
}

type CurrencyConnection {
  pageInfo: PageInfo!
  edges: [CurrencyEdge]!
  aggregate: AggregateCurrency!
}

input CurrencyCreateInput {
  id: ID
  symbol: String!
  isDefault: Boolean
}

input CurrencyCreateOneInput {
  create: CurrencyCreateInput
  connect: CurrencyWhereUniqueInput
}

type CurrencyEdge {
  node: Currency!
  cursor: String!
}

enum CurrencyOrderByInput {
  id_ASC
  id_DESC
  symbol_ASC
  symbol_DESC
  isDefault_ASC
  isDefault_DESC
  createdAt_ASC
  createdAt_DESC
}

type CurrencyPreviousValues {
  id: ID!
  symbol: String!
  isDefault: Boolean
  createdAt: DateTime!
}

type CurrencySubscriptionPayload {
  mutation: MutationType!
  node: Currency
  updatedFields: [String!]
  previousValues: CurrencyPreviousValues
}

input CurrencySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CurrencyWhereInput
  AND: [CurrencySubscriptionWhereInput!]
  OR: [CurrencySubscriptionWhereInput!]
  NOT: [CurrencySubscriptionWhereInput!]
}

input CurrencyUpdateDataInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateManyMutationInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateOneRequiredInput {
  create: CurrencyCreateInput
  update: CurrencyUpdateDataInput
  upsert: CurrencyUpsertNestedInput
  connect: CurrencyWhereUniqueInput
}

input CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput!
  create: CurrencyCreateInput!
}

input CurrencyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  symbol: String
  symbol_not: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_gt: String
  symbol_gte: String
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  isDefault: Boolean
  isDefault_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CurrencyWhereInput!]
  OR: [CurrencyWhereInput!]
  NOT: [CurrencyWhereInput!]
}

input CurrencyWhereUniqueInput {
  id: ID
}

scalar DateTime

type ExpenseUnit {
  id: ID!
  amount: String!
  currency: Currency!
  item(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  createdAt: DateTime!
}

type ExpenseUnitCategory {
  id: ID!
  name: String!
}

type ExpenseUnitCategoryConnection {
  pageInfo: PageInfo!
  edges: [ExpenseUnitCategoryEdge]!
  aggregate: AggregateExpenseUnitCategory!
}

input ExpenseUnitCategoryCreateInput {
  id: ID
  name: String!
}

type ExpenseUnitCategoryEdge {
  node: ExpenseUnitCategory!
  cursor: String!
}

enum ExpenseUnitCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ExpenseUnitCategoryPreviousValues {
  id: ID!
  name: String!
}

type ExpenseUnitCategorySubscriptionPayload {
  mutation: MutationType!
  node: ExpenseUnitCategory
  updatedFields: [String!]
  previousValues: ExpenseUnitCategoryPreviousValues
}

input ExpenseUnitCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExpenseUnitCategoryWhereInput
  AND: [ExpenseUnitCategorySubscriptionWhereInput!]
  OR: [ExpenseUnitCategorySubscriptionWhereInput!]
  NOT: [ExpenseUnitCategorySubscriptionWhereInput!]
}

input ExpenseUnitCategoryUpdateInput {
  name: String
}

input ExpenseUnitCategoryUpdateManyMutationInput {
  name: String
}

input ExpenseUnitCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ExpenseUnitCategoryWhereInput!]
  OR: [ExpenseUnitCategoryWhereInput!]
  NOT: [ExpenseUnitCategoryWhereInput!]
}

input ExpenseUnitCategoryWhereUniqueInput {
  id: ID
  name: String
}

type ExpenseUnitConnection {
  pageInfo: PageInfo!
  edges: [ExpenseUnitEdge]!
  aggregate: AggregateExpenseUnit!
}

input ExpenseUnitCreateInput {
  id: ID
  amount: String
  currency: CurrencyCreateOneInput!
  item: ItemCreateManyInput
}

type ExpenseUnitEdge {
  node: ExpenseUnit!
  cursor: String!
}

enum ExpenseUnitOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
}

type ExpenseUnitPreviousValues {
  id: ID!
  amount: String!
  createdAt: DateTime!
}

type ExpenseUnitSubscriptionPayload {
  mutation: MutationType!
  node: ExpenseUnit
  updatedFields: [String!]
  previousValues: ExpenseUnitPreviousValues
}

input ExpenseUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExpenseUnitWhereInput
  AND: [ExpenseUnitSubscriptionWhereInput!]
  OR: [ExpenseUnitSubscriptionWhereInput!]
  NOT: [ExpenseUnitSubscriptionWhereInput!]
}

input ExpenseUnitUpdateInput {
  amount: String
  currency: CurrencyUpdateOneRequiredInput
  item: ItemUpdateManyInput
}

input ExpenseUnitUpdateManyMutationInput {
  amount: String
}

input ExpenseUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  currency: CurrencyWhereInput
  item_every: ItemWhereInput
  item_some: ItemWhereInput
  item_none: ItemWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ExpenseUnitWhereInput!]
  OR: [ExpenseUnitWhereInput!]
  NOT: [ExpenseUnitWhereInput!]
}

input ExpenseUnitWhereUniqueInput {
  id: ID
}

type Inventory {
  id: ID!
  quantity: String!
  unit: MeasurementUnit!
  item(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InventoryConnection {
  pageInfo: PageInfo!
  edges: [InventoryEdge]!
  aggregate: AggregateInventory!
}

input InventoryCreateInput {
  id: ID
  quantity: String
  unit: MeasurementUnitCreateOneInput!
  item: ItemCreateManyInput
}

type InventoryEdge {
  node: Inventory!
  cursor: String!
}

enum InventoryOrderByInput {
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InventoryPreviousValues {
  id: ID!
  quantity: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InventorySubscriptionPayload {
  mutation: MutationType!
  node: Inventory
  updatedFields: [String!]
  previousValues: InventoryPreviousValues
}

input InventorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryWhereInput
  AND: [InventorySubscriptionWhereInput!]
  OR: [InventorySubscriptionWhereInput!]
  NOT: [InventorySubscriptionWhereInput!]
}

input InventoryUpdateInput {
  quantity: String
  unit: MeasurementUnitUpdateOneRequiredInput
  item: ItemUpdateManyInput
}

input InventoryUpdateManyMutationInput {
  quantity: String
}

input InventoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: String
  quantity_not: String
  quantity_in: [String!]
  quantity_not_in: [String!]
  quantity_lt: String
  quantity_lte: String
  quantity_gt: String
  quantity_gte: String
  quantity_contains: String
  quantity_not_contains: String
  quantity_starts_with: String
  quantity_not_starts_with: String
  quantity_ends_with: String
  quantity_not_ends_with: String
  unit: MeasurementUnitWhereInput
  item_every: ItemWhereInput
  item_some: ItemWhereInput
  item_none: ItemWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
}

input InventoryWhereUniqueInput {
  id: ID
}

type Item {
  id: ID!
  name: String
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: ID
  name: String
}

input ItemCreateManyInput {
  create: [ItemCreateInput!]
  connect: [ItemWhereUniqueInput!]
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ItemPreviousValues {
  id: ID!
  name: String
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateDataInput {
  name: String
}

input ItemUpdateInput {
  name: String
}

input ItemUpdateManyDataInput {
  name: String
}

input ItemUpdateManyInput {
  create: [ItemCreateInput!]
  update: [ItemUpdateWithWhereUniqueNestedInput!]
  upsert: [ItemUpsertWithWhereUniqueNestedInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyMutationInput {
  name: String
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateDataInput!
}

input ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateDataInput!
  create: ItemCreateInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Long

type MeasurementUnit {
  id: ID!
  name: String!
  symbol: String!
}

type MeasurementUnitConnection {
  pageInfo: PageInfo!
  edges: [MeasurementUnitEdge]!
  aggregate: AggregateMeasurementUnit!
}

input MeasurementUnitCreateInput {
  id: ID
  name: String!
  symbol: String!
}

input MeasurementUnitCreateOneInput {
  create: MeasurementUnitCreateInput
  connect: MeasurementUnitWhereUniqueInput
}

type MeasurementUnitEdge {
  node: MeasurementUnit!
  cursor: String!
}

enum MeasurementUnitOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  symbol_ASC
  symbol_DESC
}

type MeasurementUnitPreviousValues {
  id: ID!
  name: String!
  symbol: String!
}

type MeasurementUnitSubscriptionPayload {
  mutation: MutationType!
  node: MeasurementUnit
  updatedFields: [String!]
  previousValues: MeasurementUnitPreviousValues
}

input MeasurementUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MeasurementUnitWhereInput
  AND: [MeasurementUnitSubscriptionWhereInput!]
  OR: [MeasurementUnitSubscriptionWhereInput!]
  NOT: [MeasurementUnitSubscriptionWhereInput!]
}

input MeasurementUnitUpdateDataInput {
  name: String
  symbol: String
}

input MeasurementUnitUpdateInput {
  name: String
  symbol: String
}

input MeasurementUnitUpdateManyMutationInput {
  name: String
  symbol: String
}

input MeasurementUnitUpdateOneRequiredInput {
  create: MeasurementUnitCreateInput
  update: MeasurementUnitUpdateDataInput
  upsert: MeasurementUnitUpsertNestedInput
  connect: MeasurementUnitWhereUniqueInput
}

input MeasurementUnitUpsertNestedInput {
  update: MeasurementUnitUpdateDataInput!
  create: MeasurementUnitCreateInput!
}

input MeasurementUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  symbol: String
  symbol_not: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_gt: String
  symbol_gte: String
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  AND: [MeasurementUnitWhereInput!]
  OR: [MeasurementUnitWhereInput!]
  NOT: [MeasurementUnitWhereInput!]
}

input MeasurementUnitWhereUniqueInput {
  id: ID
}

type Merchandise {
  id: ID!
  quantity: String!
  product(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MerchandiseConnection {
  pageInfo: PageInfo!
  edges: [MerchandiseEdge]!
  aggregate: AggregateMerchandise!
}

input MerchandiseCreateInput {
  id: ID
  quantity: String
  product: ProductCreateManyInput
}

type MerchandiseEdge {
  node: Merchandise!
  cursor: String!
}

enum MerchandiseOrderByInput {
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MerchandisePreviousValues {
  id: ID!
  quantity: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MerchandiseSubscriptionPayload {
  mutation: MutationType!
  node: Merchandise
  updatedFields: [String!]
  previousValues: MerchandisePreviousValues
}

input MerchandiseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MerchandiseWhereInput
  AND: [MerchandiseSubscriptionWhereInput!]
  OR: [MerchandiseSubscriptionWhereInput!]
  NOT: [MerchandiseSubscriptionWhereInput!]
}

input MerchandiseUpdateInput {
  quantity: String
  product: ProductUpdateManyInput
}

input MerchandiseUpdateManyMutationInput {
  quantity: String
}

input MerchandiseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: String
  quantity_not: String
  quantity_in: [String!]
  quantity_not_in: [String!]
  quantity_lt: String
  quantity_lte: String
  quantity_gt: String
  quantity_gte: String
  quantity_contains: String
  quantity_not_contains: String
  quantity_starts_with: String
  quantity_not_starts_with: String
  quantity_ends_with: String
  quantity_not_ends_with: String
  product_every: ProductWhereInput
  product_some: ProductWhereInput
  product_none: ProductWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MerchandiseWhereInput!]
  OR: [MerchandiseWhereInput!]
  NOT: [MerchandiseWhereInput!]
}

input MerchandiseWhereUniqueInput {
  id: ID
}

type Mutation {
  createCurrency(data: CurrencyCreateInput!): Currency!
  updateCurrency(data: CurrencyUpdateInput!, where: CurrencyWhereUniqueInput!): Currency
  updateManyCurrencies(data: CurrencyUpdateManyMutationInput!, where: CurrencyWhereInput): BatchPayload!
  upsertCurrency(where: CurrencyWhereUniqueInput!, create: CurrencyCreateInput!, update: CurrencyUpdateInput!): Currency!
  deleteCurrency(where: CurrencyWhereUniqueInput!): Currency
  deleteManyCurrencies(where: CurrencyWhereInput): BatchPayload!
  createExpenseUnit(data: ExpenseUnitCreateInput!): ExpenseUnit!
  updateExpenseUnit(data: ExpenseUnitUpdateInput!, where: ExpenseUnitWhereUniqueInput!): ExpenseUnit
  updateManyExpenseUnits(data: ExpenseUnitUpdateManyMutationInput!, where: ExpenseUnitWhereInput): BatchPayload!
  upsertExpenseUnit(where: ExpenseUnitWhereUniqueInput!, create: ExpenseUnitCreateInput!, update: ExpenseUnitUpdateInput!): ExpenseUnit!
  deleteExpenseUnit(where: ExpenseUnitWhereUniqueInput!): ExpenseUnit
  deleteManyExpenseUnits(where: ExpenseUnitWhereInput): BatchPayload!
  createExpenseUnitCategory(data: ExpenseUnitCategoryCreateInput!): ExpenseUnitCategory!
  updateExpenseUnitCategory(data: ExpenseUnitCategoryUpdateInput!, where: ExpenseUnitCategoryWhereUniqueInput!): ExpenseUnitCategory
  updateManyExpenseUnitCategories(data: ExpenseUnitCategoryUpdateManyMutationInput!, where: ExpenseUnitCategoryWhereInput): BatchPayload!
  upsertExpenseUnitCategory(where: ExpenseUnitCategoryWhereUniqueInput!, create: ExpenseUnitCategoryCreateInput!, update: ExpenseUnitCategoryUpdateInput!): ExpenseUnitCategory!
  deleteExpenseUnitCategory(where: ExpenseUnitCategoryWhereUniqueInput!): ExpenseUnitCategory
  deleteManyExpenseUnitCategories(where: ExpenseUnitCategoryWhereInput): BatchPayload!
  createInventory(data: InventoryCreateInput!): Inventory!
  updateInventory(data: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory
  updateManyInventories(data: InventoryUpdateManyMutationInput!, where: InventoryWhereInput): BatchPayload!
  upsertInventory(where: InventoryWhereUniqueInput!, create: InventoryCreateInput!, update: InventoryUpdateInput!): Inventory!
  deleteInventory(where: InventoryWhereUniqueInput!): Inventory
  deleteManyInventories(where: InventoryWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createMeasurementUnit(data: MeasurementUnitCreateInput!): MeasurementUnit!
  updateMeasurementUnit(data: MeasurementUnitUpdateInput!, where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  updateManyMeasurementUnits(data: MeasurementUnitUpdateManyMutationInput!, where: MeasurementUnitWhereInput): BatchPayload!
  upsertMeasurementUnit(where: MeasurementUnitWhereUniqueInput!, create: MeasurementUnitCreateInput!, update: MeasurementUnitUpdateInput!): MeasurementUnit!
  deleteMeasurementUnit(where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  deleteManyMeasurementUnits(where: MeasurementUnitWhereInput): BatchPayload!
  createMerchandise(data: MerchandiseCreateInput!): Merchandise!
  updateMerchandise(data: MerchandiseUpdateInput!, where: MerchandiseWhereUniqueInput!): Merchandise
  updateManyMerchandises(data: MerchandiseUpdateManyMutationInput!, where: MerchandiseWhereInput): BatchPayload!
  upsertMerchandise(where: MerchandiseWhereUniqueInput!, create: MerchandiseCreateInput!, update: MerchandiseUpdateInput!): Merchandise!
  deleteMerchandise(where: MerchandiseWhereUniqueInput!): Merchandise
  deleteManyMerchandises(where: MerchandiseWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Product {
  id: ID!
  name: String
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  name: String
}

input ProductCreateManyInput {
  create: [ProductCreateInput!]
  connect: [ProductWhereUniqueInput!]
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ProductPreviousValues {
  id: ID!
  name: String
}

input ProductScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  name: String
}

input ProductUpdateInput {
  name: String
}

input ProductUpdateManyDataInput {
  name: String
}

input ProductUpdateManyInput {
  create: [ProductCreateInput!]
  update: [ProductUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductUpsertWithWhereUniqueNestedInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyMutationInput {
  name: String
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateDataInput!
}

input ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  currency(where: CurrencyWhereUniqueInput!): Currency
  currencies(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Currency]!
  currenciesConnection(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CurrencyConnection!
  expenseUnit(where: ExpenseUnitWhereUniqueInput!): ExpenseUnit
  expenseUnits(where: ExpenseUnitWhereInput, orderBy: ExpenseUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExpenseUnit]!
  expenseUnitsConnection(where: ExpenseUnitWhereInput, orderBy: ExpenseUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExpenseUnitConnection!
  expenseUnitCategory(where: ExpenseUnitCategoryWhereUniqueInput!): ExpenseUnitCategory
  expenseUnitCategories(where: ExpenseUnitCategoryWhereInput, orderBy: ExpenseUnitCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExpenseUnitCategory]!
  expenseUnitCategoriesConnection(where: ExpenseUnitCategoryWhereInput, orderBy: ExpenseUnitCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExpenseUnitCategoryConnection!
  inventory(where: InventoryWhereUniqueInput!): Inventory
  inventories(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Inventory]!
  inventoriesConnection(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  measurementUnit(where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  measurementUnits(where: MeasurementUnitWhereInput, orderBy: MeasurementUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MeasurementUnit]!
  measurementUnitsConnection(where: MeasurementUnitWhereInput, orderBy: MeasurementUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MeasurementUnitConnection!
  merchandise(where: MerchandiseWhereUniqueInput!): Merchandise
  merchandises(where: MerchandiseWhereInput, orderBy: MerchandiseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Merchandise]!
  merchandisesConnection(where: MerchandiseWhereInput, orderBy: MerchandiseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MerchandiseConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  node(id: ID!): Node
}

type Subscription {
  currency(where: CurrencySubscriptionWhereInput): CurrencySubscriptionPayload
  expenseUnit(where: ExpenseUnitSubscriptionWhereInput): ExpenseUnitSubscriptionPayload
  expenseUnitCategory(where: ExpenseUnitCategorySubscriptionWhereInput): ExpenseUnitCategorySubscriptionPayload
  inventory(where: InventorySubscriptionWhereInput): InventorySubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  measurementUnit(where: MeasurementUnitSubscriptionWhereInput): MeasurementUnitSubscriptionPayload
  merchandise(where: MerchandiseSubscriptionWhereInput): MerchandiseSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
}
`