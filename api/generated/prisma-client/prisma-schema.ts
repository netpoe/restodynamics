// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateCurrency {
  count: Int!
}

type AggregateExpenseUnit {
  count: Int!
}

type AggregateInventory {
  count: Int!
}

type AggregateInventoryUnit {
  count: Int!
}

type AggregateMeasurementUnit {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateStockUnit {
  count: Int!
}

type AggregateStockUnitCategory {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Currency {
  id: ID!
  symbol: String!
  isDefault: Boolean
  createdAt: DateTime!
}

type CurrencyConnection {
  pageInfo: PageInfo!
  edges: [CurrencyEdge]!
  aggregate: AggregateCurrency!
}

input CurrencyCreateInput {
  id: ID
  symbol: String!
  isDefault: Boolean
}

input CurrencyCreateOneInput {
  create: CurrencyCreateInput
  connect: CurrencyWhereUniqueInput
}

type CurrencyEdge {
  node: Currency!
  cursor: String!
}

enum CurrencyOrderByInput {
  id_ASC
  id_DESC
  symbol_ASC
  symbol_DESC
  isDefault_ASC
  isDefault_DESC
  createdAt_ASC
  createdAt_DESC
}

type CurrencyPreviousValues {
  id: ID!
  symbol: String!
  isDefault: Boolean
  createdAt: DateTime!
}

type CurrencySubscriptionPayload {
  mutation: MutationType!
  node: Currency
  updatedFields: [String!]
  previousValues: CurrencyPreviousValues
}

input CurrencySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CurrencyWhereInput
  AND: [CurrencySubscriptionWhereInput!]
  OR: [CurrencySubscriptionWhereInput!]
  NOT: [CurrencySubscriptionWhereInput!]
}

input CurrencyUpdateDataInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateManyMutationInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateOneRequiredInput {
  create: CurrencyCreateInput
  update: CurrencyUpdateDataInput
  upsert: CurrencyUpsertNestedInput
  connect: CurrencyWhereUniqueInput
}

input CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput!
  create: CurrencyCreateInput!
}

input CurrencyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  symbol: String
  symbol_not: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_gt: String
  symbol_gte: String
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  isDefault: Boolean
  isDefault_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CurrencyWhereInput!]
  OR: [CurrencyWhereInput!]
  NOT: [CurrencyWhereInput!]
}

input CurrencyWhereUniqueInput {
  id: ID
  symbol: String
}

scalar DateTime

type ExpenseUnit {
  id: ID!
  amount: String!
  currency: Currency!
  stockUnit: StockUnit!
  createdAt: DateTime!
}

type ExpenseUnitConnection {
  pageInfo: PageInfo!
  edges: [ExpenseUnitEdge]!
  aggregate: AggregateExpenseUnit!
}

input ExpenseUnitCreateInput {
  id: ID
  amount: String
  currency: CurrencyCreateOneInput!
  stockUnit: StockUnitCreateOneWithoutExpenseUnitInput!
}

input ExpenseUnitCreateManyWithoutStockUnitInput {
  create: [ExpenseUnitCreateWithoutStockUnitInput!]
  connect: [ExpenseUnitWhereUniqueInput!]
}

input ExpenseUnitCreateOneInput {
  create: ExpenseUnitCreateInput
  connect: ExpenseUnitWhereUniqueInput
}

input ExpenseUnitCreateWithoutStockUnitInput {
  id: ID
  amount: String
  currency: CurrencyCreateOneInput!
}

type ExpenseUnitEdge {
  node: ExpenseUnit!
  cursor: String!
}

enum ExpenseUnitOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
}

type ExpenseUnitPreviousValues {
  id: ID!
  amount: String!
  createdAt: DateTime!
}

input ExpenseUnitScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ExpenseUnitScalarWhereInput!]
  OR: [ExpenseUnitScalarWhereInput!]
  NOT: [ExpenseUnitScalarWhereInput!]
}

type ExpenseUnitSubscriptionPayload {
  mutation: MutationType!
  node: ExpenseUnit
  updatedFields: [String!]
  previousValues: ExpenseUnitPreviousValues
}

input ExpenseUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExpenseUnitWhereInput
  AND: [ExpenseUnitSubscriptionWhereInput!]
  OR: [ExpenseUnitSubscriptionWhereInput!]
  NOT: [ExpenseUnitSubscriptionWhereInput!]
}

input ExpenseUnitUpdateDataInput {
  amount: String
  currency: CurrencyUpdateOneRequiredInput
  stockUnit: StockUnitUpdateOneRequiredWithoutExpenseUnitInput
}

input ExpenseUnitUpdateInput {
  amount: String
  currency: CurrencyUpdateOneRequiredInput
  stockUnit: StockUnitUpdateOneRequiredWithoutExpenseUnitInput
}

input ExpenseUnitUpdateManyDataInput {
  amount: String
}

input ExpenseUnitUpdateManyMutationInput {
  amount: String
}

input ExpenseUnitUpdateManyWithoutStockUnitInput {
  create: [ExpenseUnitCreateWithoutStockUnitInput!]
  delete: [ExpenseUnitWhereUniqueInput!]
  connect: [ExpenseUnitWhereUniqueInput!]
  set: [ExpenseUnitWhereUniqueInput!]
  disconnect: [ExpenseUnitWhereUniqueInput!]
  update: [ExpenseUnitUpdateWithWhereUniqueWithoutStockUnitInput!]
  upsert: [ExpenseUnitUpsertWithWhereUniqueWithoutStockUnitInput!]
  deleteMany: [ExpenseUnitScalarWhereInput!]
  updateMany: [ExpenseUnitUpdateManyWithWhereNestedInput!]
}

input ExpenseUnitUpdateManyWithWhereNestedInput {
  where: ExpenseUnitScalarWhereInput!
  data: ExpenseUnitUpdateManyDataInput!
}

input ExpenseUnitUpdateOneInput {
  create: ExpenseUnitCreateInput
  update: ExpenseUnitUpdateDataInput
  upsert: ExpenseUnitUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ExpenseUnitWhereUniqueInput
}

input ExpenseUnitUpdateWithoutStockUnitDataInput {
  amount: String
  currency: CurrencyUpdateOneRequiredInput
}

input ExpenseUnitUpdateWithWhereUniqueWithoutStockUnitInput {
  where: ExpenseUnitWhereUniqueInput!
  data: ExpenseUnitUpdateWithoutStockUnitDataInput!
}

input ExpenseUnitUpsertNestedInput {
  update: ExpenseUnitUpdateDataInput!
  create: ExpenseUnitCreateInput!
}

input ExpenseUnitUpsertWithWhereUniqueWithoutStockUnitInput {
  where: ExpenseUnitWhereUniqueInput!
  update: ExpenseUnitUpdateWithoutStockUnitDataInput!
  create: ExpenseUnitCreateWithoutStockUnitInput!
}

input ExpenseUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  currency: CurrencyWhereInput
  stockUnit: StockUnitWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ExpenseUnitWhereInput!]
  OR: [ExpenseUnitWhereInput!]
  NOT: [ExpenseUnitWhereInput!]
}

input ExpenseUnitWhereUniqueInput {
  id: ID
}

type Inventory {
  id: ID!
  createdAt: DateTime!
  inventoryUnit(where: InventoryUnitWhereInput, orderBy: InventoryUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InventoryUnit!]
}

type InventoryConnection {
  pageInfo: PageInfo!
  edges: [InventoryEdge]!
  aggregate: AggregateInventory!
}

input InventoryCreateInput {
  id: ID
  inventoryUnit: InventoryUnitCreateManyWithoutInventoryInput
}

input InventoryCreateOneWithoutInventoryUnitInput {
  create: InventoryCreateWithoutInventoryUnitInput
  connect: InventoryWhereUniqueInput
}

input InventoryCreateWithoutInventoryUnitInput {
  id: ID
}

type InventoryEdge {
  node: Inventory!
  cursor: String!
}

enum InventoryOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
}

type InventoryPreviousValues {
  id: ID!
  createdAt: DateTime!
}

type InventorySubscriptionPayload {
  mutation: MutationType!
  node: Inventory
  updatedFields: [String!]
  previousValues: InventoryPreviousValues
}

input InventorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryWhereInput
  AND: [InventorySubscriptionWhereInput!]
  OR: [InventorySubscriptionWhereInput!]
  NOT: [InventorySubscriptionWhereInput!]
}

type InventoryUnit {
  id: ID!
  inventory: Inventory!
  quantity: String!
  unit: MeasurementUnit!
  expenseUnit: ExpenseUnit
  stockUnit: StockUnit!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InventoryUnitConnection {
  pageInfo: PageInfo!
  edges: [InventoryUnitEdge]!
  aggregate: AggregateInventoryUnit!
}

input InventoryUnitCreateInput {
  id: ID
  inventory: InventoryCreateOneWithoutInventoryUnitInput!
  quantity: String
  unit: MeasurementUnitCreateOneInput!
  expenseUnit: ExpenseUnitCreateOneInput
  stockUnit: StockUnitCreateOneWithoutInventoryUnitInput!
}

input InventoryUnitCreateManyWithoutInventoryInput {
  create: [InventoryUnitCreateWithoutInventoryInput!]
  connect: [InventoryUnitWhereUniqueInput!]
}

input InventoryUnitCreateManyWithoutStockUnitInput {
  create: [InventoryUnitCreateWithoutStockUnitInput!]
  connect: [InventoryUnitWhereUniqueInput!]
}

input InventoryUnitCreateWithoutInventoryInput {
  id: ID
  quantity: String
  unit: MeasurementUnitCreateOneInput!
  expenseUnit: ExpenseUnitCreateOneInput
  stockUnit: StockUnitCreateOneWithoutInventoryUnitInput!
}

input InventoryUnitCreateWithoutStockUnitInput {
  id: ID
  inventory: InventoryCreateOneWithoutInventoryUnitInput!
  quantity: String
  unit: MeasurementUnitCreateOneInput!
  expenseUnit: ExpenseUnitCreateOneInput
}

type InventoryUnitEdge {
  node: InventoryUnit!
  cursor: String!
}

enum InventoryUnitOrderByInput {
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InventoryUnitPreviousValues {
  id: ID!
  quantity: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input InventoryUnitScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: String
  quantity_not: String
  quantity_in: [String!]
  quantity_not_in: [String!]
  quantity_lt: String
  quantity_lte: String
  quantity_gt: String
  quantity_gte: String
  quantity_contains: String
  quantity_not_contains: String
  quantity_starts_with: String
  quantity_not_starts_with: String
  quantity_ends_with: String
  quantity_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InventoryUnitScalarWhereInput!]
  OR: [InventoryUnitScalarWhereInput!]
  NOT: [InventoryUnitScalarWhereInput!]
}

type InventoryUnitSubscriptionPayload {
  mutation: MutationType!
  node: InventoryUnit
  updatedFields: [String!]
  previousValues: InventoryUnitPreviousValues
}

input InventoryUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryUnitWhereInput
  AND: [InventoryUnitSubscriptionWhereInput!]
  OR: [InventoryUnitSubscriptionWhereInput!]
  NOT: [InventoryUnitSubscriptionWhereInput!]
}

input InventoryUnitUpdateInput {
  inventory: InventoryUpdateOneRequiredWithoutInventoryUnitInput
  quantity: String
  unit: MeasurementUnitUpdateOneRequiredInput
  expenseUnit: ExpenseUnitUpdateOneInput
  stockUnit: StockUnitUpdateOneRequiredWithoutInventoryUnitInput
}

input InventoryUnitUpdateManyDataInput {
  quantity: String
}

input InventoryUnitUpdateManyMutationInput {
  quantity: String
}

input InventoryUnitUpdateManyWithoutInventoryInput {
  create: [InventoryUnitCreateWithoutInventoryInput!]
  delete: [InventoryUnitWhereUniqueInput!]
  connect: [InventoryUnitWhereUniqueInput!]
  set: [InventoryUnitWhereUniqueInput!]
  disconnect: [InventoryUnitWhereUniqueInput!]
  update: [InventoryUnitUpdateWithWhereUniqueWithoutInventoryInput!]
  upsert: [InventoryUnitUpsertWithWhereUniqueWithoutInventoryInput!]
  deleteMany: [InventoryUnitScalarWhereInput!]
  updateMany: [InventoryUnitUpdateManyWithWhereNestedInput!]
}

input InventoryUnitUpdateManyWithoutStockUnitInput {
  create: [InventoryUnitCreateWithoutStockUnitInput!]
  delete: [InventoryUnitWhereUniqueInput!]
  connect: [InventoryUnitWhereUniqueInput!]
  set: [InventoryUnitWhereUniqueInput!]
  disconnect: [InventoryUnitWhereUniqueInput!]
  update: [InventoryUnitUpdateWithWhereUniqueWithoutStockUnitInput!]
  upsert: [InventoryUnitUpsertWithWhereUniqueWithoutStockUnitInput!]
  deleteMany: [InventoryUnitScalarWhereInput!]
  updateMany: [InventoryUnitUpdateManyWithWhereNestedInput!]
}

input InventoryUnitUpdateManyWithWhereNestedInput {
  where: InventoryUnitScalarWhereInput!
  data: InventoryUnitUpdateManyDataInput!
}

input InventoryUnitUpdateWithoutInventoryDataInput {
  quantity: String
  unit: MeasurementUnitUpdateOneRequiredInput
  expenseUnit: ExpenseUnitUpdateOneInput
  stockUnit: StockUnitUpdateOneRequiredWithoutInventoryUnitInput
}

input InventoryUnitUpdateWithoutStockUnitDataInput {
  inventory: InventoryUpdateOneRequiredWithoutInventoryUnitInput
  quantity: String
  unit: MeasurementUnitUpdateOneRequiredInput
  expenseUnit: ExpenseUnitUpdateOneInput
}

input InventoryUnitUpdateWithWhereUniqueWithoutInventoryInput {
  where: InventoryUnitWhereUniqueInput!
  data: InventoryUnitUpdateWithoutInventoryDataInput!
}

input InventoryUnitUpdateWithWhereUniqueWithoutStockUnitInput {
  where: InventoryUnitWhereUniqueInput!
  data: InventoryUnitUpdateWithoutStockUnitDataInput!
}

input InventoryUnitUpsertWithWhereUniqueWithoutInventoryInput {
  where: InventoryUnitWhereUniqueInput!
  update: InventoryUnitUpdateWithoutInventoryDataInput!
  create: InventoryUnitCreateWithoutInventoryInput!
}

input InventoryUnitUpsertWithWhereUniqueWithoutStockUnitInput {
  where: InventoryUnitWhereUniqueInput!
  update: InventoryUnitUpdateWithoutStockUnitDataInput!
  create: InventoryUnitCreateWithoutStockUnitInput!
}

input InventoryUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  inventory: InventoryWhereInput
  quantity: String
  quantity_not: String
  quantity_in: [String!]
  quantity_not_in: [String!]
  quantity_lt: String
  quantity_lte: String
  quantity_gt: String
  quantity_gte: String
  quantity_contains: String
  quantity_not_contains: String
  quantity_starts_with: String
  quantity_not_starts_with: String
  quantity_ends_with: String
  quantity_not_ends_with: String
  unit: MeasurementUnitWhereInput
  expenseUnit: ExpenseUnitWhereInput
  stockUnit: StockUnitWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InventoryUnitWhereInput!]
  OR: [InventoryUnitWhereInput!]
  NOT: [InventoryUnitWhereInput!]
}

input InventoryUnitWhereUniqueInput {
  id: ID
}

input InventoryUpdateInput {
  inventoryUnit: InventoryUnitUpdateManyWithoutInventoryInput
}

input InventoryUpdateOneRequiredWithoutInventoryUnitInput {
  create: InventoryCreateWithoutInventoryUnitInput
  connect: InventoryWhereUniqueInput
}

input InventoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  inventoryUnit_every: InventoryUnitWhereInput
  inventoryUnit_some: InventoryUnitWhereInput
  inventoryUnit_none: InventoryUnitWhereInput
  AND: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
}

input InventoryWhereUniqueInput {
  id: ID
}

scalar Long

type MeasurementUnit {
  id: ID!
  name: String!
  symbol: String!
}

type MeasurementUnitConnection {
  pageInfo: PageInfo!
  edges: [MeasurementUnitEdge]!
  aggregate: AggregateMeasurementUnit!
}

input MeasurementUnitCreateInput {
  id: ID
  name: String!
  symbol: String!
}

input MeasurementUnitCreateOneInput {
  create: MeasurementUnitCreateInput
  connect: MeasurementUnitWhereUniqueInput
}

type MeasurementUnitEdge {
  node: MeasurementUnit!
  cursor: String!
}

enum MeasurementUnitOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  symbol_ASC
  symbol_DESC
}

type MeasurementUnitPreviousValues {
  id: ID!
  name: String!
  symbol: String!
}

type MeasurementUnitSubscriptionPayload {
  mutation: MutationType!
  node: MeasurementUnit
  updatedFields: [String!]
  previousValues: MeasurementUnitPreviousValues
}

input MeasurementUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MeasurementUnitWhereInput
  AND: [MeasurementUnitSubscriptionWhereInput!]
  OR: [MeasurementUnitSubscriptionWhereInput!]
  NOT: [MeasurementUnitSubscriptionWhereInput!]
}

input MeasurementUnitUpdateDataInput {
  name: String
  symbol: String
}

input MeasurementUnitUpdateInput {
  name: String
  symbol: String
}

input MeasurementUnitUpdateManyMutationInput {
  name: String
  symbol: String
}

input MeasurementUnitUpdateOneRequiredInput {
  create: MeasurementUnitCreateInput
  update: MeasurementUnitUpdateDataInput
  upsert: MeasurementUnitUpsertNestedInput
  connect: MeasurementUnitWhereUniqueInput
}

input MeasurementUnitUpsertNestedInput {
  update: MeasurementUnitUpdateDataInput!
  create: MeasurementUnitCreateInput!
}

input MeasurementUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  symbol: String
  symbol_not: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_gt: String
  symbol_gte: String
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  AND: [MeasurementUnitWhereInput!]
  OR: [MeasurementUnitWhereInput!]
  NOT: [MeasurementUnitWhereInput!]
}

input MeasurementUnitWhereUniqueInput {
  id: ID
  name: String
  symbol: String
}

type Mutation {
  createCurrency(data: CurrencyCreateInput!): Currency!
  updateCurrency(data: CurrencyUpdateInput!, where: CurrencyWhereUniqueInput!): Currency
  updateManyCurrencies(data: CurrencyUpdateManyMutationInput!, where: CurrencyWhereInput): BatchPayload!
  upsertCurrency(where: CurrencyWhereUniqueInput!, create: CurrencyCreateInput!, update: CurrencyUpdateInput!): Currency!
  deleteCurrency(where: CurrencyWhereUniqueInput!): Currency
  deleteManyCurrencies(where: CurrencyWhereInput): BatchPayload!
  createExpenseUnit(data: ExpenseUnitCreateInput!): ExpenseUnit!
  updateExpenseUnit(data: ExpenseUnitUpdateInput!, where: ExpenseUnitWhereUniqueInput!): ExpenseUnit
  updateManyExpenseUnits(data: ExpenseUnitUpdateManyMutationInput!, where: ExpenseUnitWhereInput): BatchPayload!
  upsertExpenseUnit(where: ExpenseUnitWhereUniqueInput!, create: ExpenseUnitCreateInput!, update: ExpenseUnitUpdateInput!): ExpenseUnit!
  deleteExpenseUnit(where: ExpenseUnitWhereUniqueInput!): ExpenseUnit
  deleteManyExpenseUnits(where: ExpenseUnitWhereInput): BatchPayload!
  createInventory(data: InventoryCreateInput!): Inventory!
  updateInventory(data: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory
  upsertInventory(where: InventoryWhereUniqueInput!, create: InventoryCreateInput!, update: InventoryUpdateInput!): Inventory!
  deleteInventory(where: InventoryWhereUniqueInput!): Inventory
  deleteManyInventories(where: InventoryWhereInput): BatchPayload!
  createInventoryUnit(data: InventoryUnitCreateInput!): InventoryUnit!
  updateInventoryUnit(data: InventoryUnitUpdateInput!, where: InventoryUnitWhereUniqueInput!): InventoryUnit
  updateManyInventoryUnits(data: InventoryUnitUpdateManyMutationInput!, where: InventoryUnitWhereInput): BatchPayload!
  upsertInventoryUnit(where: InventoryUnitWhereUniqueInput!, create: InventoryUnitCreateInput!, update: InventoryUnitUpdateInput!): InventoryUnit!
  deleteInventoryUnit(where: InventoryUnitWhereUniqueInput!): InventoryUnit
  deleteManyInventoryUnits(where: InventoryUnitWhereInput): BatchPayload!
  createMeasurementUnit(data: MeasurementUnitCreateInput!): MeasurementUnit!
  updateMeasurementUnit(data: MeasurementUnitUpdateInput!, where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  updateManyMeasurementUnits(data: MeasurementUnitUpdateManyMutationInput!, where: MeasurementUnitWhereInput): BatchPayload!
  upsertMeasurementUnit(where: MeasurementUnitWhereUniqueInput!, create: MeasurementUnitCreateInput!, update: MeasurementUnitUpdateInput!): MeasurementUnit!
  deleteMeasurementUnit(where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  deleteManyMeasurementUnits(where: MeasurementUnitWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createStockUnit(data: StockUnitCreateInput!): StockUnit!
  updateStockUnit(data: StockUnitUpdateInput!, where: StockUnitWhereUniqueInput!): StockUnit
  updateManyStockUnits(data: StockUnitUpdateManyMutationInput!, where: StockUnitWhereInput): BatchPayload!
  upsertStockUnit(where: StockUnitWhereUniqueInput!, create: StockUnitCreateInput!, update: StockUnitUpdateInput!): StockUnit!
  deleteStockUnit(where: StockUnitWhereUniqueInput!): StockUnit
  deleteManyStockUnits(where: StockUnitWhereInput): BatchPayload!
  createStockUnitCategory(data: StockUnitCategoryCreateInput!): StockUnitCategory!
  updateStockUnitCategory(data: StockUnitCategoryUpdateInput!, where: StockUnitCategoryWhereUniqueInput!): StockUnitCategory
  updateManyStockUnitCategories(data: StockUnitCategoryUpdateManyMutationInput!, where: StockUnitCategoryWhereInput): BatchPayload!
  upsertStockUnitCategory(where: StockUnitCategoryWhereUniqueInput!, create: StockUnitCategoryCreateInput!, update: StockUnitCategoryUpdateInput!): StockUnitCategory!
  deleteStockUnitCategory(where: StockUnitCategoryWhereUniqueInput!): StockUnitCategory
  deleteManyStockUnitCategories(where: StockUnitCategoryWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Product {
  id: ID!
  item: StockUnit!
  stockUnit(where: StockUnitWhereInput, orderBy: StockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StockUnit!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  item: StockUnitCreateOneInput!
  stockUnit: StockUnitCreateManyInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateInput {
  item: StockUnitUpdateOneRequiredInput
  stockUnit: StockUnitUpdateManyInput
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  item: StockUnitWhereInput
  stockUnit_every: StockUnitWhereInput
  stockUnit_some: StockUnitWhereInput
  stockUnit_none: StockUnitWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  currency(where: CurrencyWhereUniqueInput!): Currency
  currencies(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Currency]!
  currenciesConnection(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CurrencyConnection!
  expenseUnit(where: ExpenseUnitWhereUniqueInput!): ExpenseUnit
  expenseUnits(where: ExpenseUnitWhereInput, orderBy: ExpenseUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExpenseUnit]!
  expenseUnitsConnection(where: ExpenseUnitWhereInput, orderBy: ExpenseUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExpenseUnitConnection!
  inventory(where: InventoryWhereUniqueInput!): Inventory
  inventories(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Inventory]!
  inventoriesConnection(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryConnection!
  inventoryUnit(where: InventoryUnitWhereUniqueInput!): InventoryUnit
  inventoryUnits(where: InventoryUnitWhereInput, orderBy: InventoryUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InventoryUnit]!
  inventoryUnitsConnection(where: InventoryUnitWhereInput, orderBy: InventoryUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryUnitConnection!
  measurementUnit(where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  measurementUnits(where: MeasurementUnitWhereInput, orderBy: MeasurementUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MeasurementUnit]!
  measurementUnitsConnection(where: MeasurementUnitWhereInput, orderBy: MeasurementUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MeasurementUnitConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  stockUnit(where: StockUnitWhereUniqueInput!): StockUnit
  stockUnits(where: StockUnitWhereInput, orderBy: StockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StockUnit]!
  stockUnitsConnection(where: StockUnitWhereInput, orderBy: StockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StockUnitConnection!
  stockUnitCategory(where: StockUnitCategoryWhereUniqueInput!): StockUnitCategory
  stockUnitCategories(where: StockUnitCategoryWhereInput, orderBy: StockUnitCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StockUnitCategory]!
  stockUnitCategoriesConnection(where: StockUnitCategoryWhereInput, orderBy: StockUnitCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StockUnitCategoryConnection!
  node(id: ID!): Node
}

type StockUnit {
  id: ID!
  name: String
  inventoryUnit(where: InventoryUnitWhereInput, orderBy: InventoryUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InventoryUnit!]
  category: StockUnitCategory
  expenseUnit(where: ExpenseUnitWhereInput, orderBy: ExpenseUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExpenseUnit!]
}

type StockUnitCategory {
  id: ID!
  name: String!
}

type StockUnitCategoryConnection {
  pageInfo: PageInfo!
  edges: [StockUnitCategoryEdge]!
  aggregate: AggregateStockUnitCategory!
}

input StockUnitCategoryCreateInput {
  id: ID
  name: String!
}

input StockUnitCategoryCreateOneInput {
  create: StockUnitCategoryCreateInput
  connect: StockUnitCategoryWhereUniqueInput
}

type StockUnitCategoryEdge {
  node: StockUnitCategory!
  cursor: String!
}

enum StockUnitCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type StockUnitCategoryPreviousValues {
  id: ID!
  name: String!
}

type StockUnitCategorySubscriptionPayload {
  mutation: MutationType!
  node: StockUnitCategory
  updatedFields: [String!]
  previousValues: StockUnitCategoryPreviousValues
}

input StockUnitCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StockUnitCategoryWhereInput
  AND: [StockUnitCategorySubscriptionWhereInput!]
  OR: [StockUnitCategorySubscriptionWhereInput!]
  NOT: [StockUnitCategorySubscriptionWhereInput!]
}

input StockUnitCategoryUpdateDataInput {
  name: String
}

input StockUnitCategoryUpdateInput {
  name: String
}

input StockUnitCategoryUpdateManyMutationInput {
  name: String
}

input StockUnitCategoryUpdateOneInput {
  create: StockUnitCategoryCreateInput
  update: StockUnitCategoryUpdateDataInput
  upsert: StockUnitCategoryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: StockUnitCategoryWhereUniqueInput
}

input StockUnitCategoryUpsertNestedInput {
  update: StockUnitCategoryUpdateDataInput!
  create: StockUnitCategoryCreateInput!
}

input StockUnitCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [StockUnitCategoryWhereInput!]
  OR: [StockUnitCategoryWhereInput!]
  NOT: [StockUnitCategoryWhereInput!]
}

input StockUnitCategoryWhereUniqueInput {
  id: ID
  name: String
}

type StockUnitConnection {
  pageInfo: PageInfo!
  edges: [StockUnitEdge]!
  aggregate: AggregateStockUnit!
}

input StockUnitCreateInput {
  id: ID
  name: String
  inventoryUnit: InventoryUnitCreateManyWithoutStockUnitInput
  category: StockUnitCategoryCreateOneInput
  expenseUnit: ExpenseUnitCreateManyWithoutStockUnitInput
}

input StockUnitCreateManyInput {
  create: [StockUnitCreateInput!]
  connect: [StockUnitWhereUniqueInput!]
}

input StockUnitCreateOneInput {
  create: StockUnitCreateInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitCreateOneWithoutExpenseUnitInput {
  create: StockUnitCreateWithoutExpenseUnitInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitCreateOneWithoutInventoryUnitInput {
  create: StockUnitCreateWithoutInventoryUnitInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitCreateWithoutExpenseUnitInput {
  id: ID
  name: String
  inventoryUnit: InventoryUnitCreateManyWithoutStockUnitInput
  category: StockUnitCategoryCreateOneInput
}

input StockUnitCreateWithoutInventoryUnitInput {
  id: ID
  name: String
  category: StockUnitCategoryCreateOneInput
  expenseUnit: ExpenseUnitCreateManyWithoutStockUnitInput
}

type StockUnitEdge {
  node: StockUnit!
  cursor: String!
}

enum StockUnitOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type StockUnitPreviousValues {
  id: ID!
  name: String
}

input StockUnitScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [StockUnitScalarWhereInput!]
  OR: [StockUnitScalarWhereInput!]
  NOT: [StockUnitScalarWhereInput!]
}

type StockUnitSubscriptionPayload {
  mutation: MutationType!
  node: StockUnit
  updatedFields: [String!]
  previousValues: StockUnitPreviousValues
}

input StockUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StockUnitWhereInput
  AND: [StockUnitSubscriptionWhereInput!]
  OR: [StockUnitSubscriptionWhereInput!]
  NOT: [StockUnitSubscriptionWhereInput!]
}

input StockUnitUpdateDataInput {
  name: String
  inventoryUnit: InventoryUnitUpdateManyWithoutStockUnitInput
  category: StockUnitCategoryUpdateOneInput
  expenseUnit: ExpenseUnitUpdateManyWithoutStockUnitInput
}

input StockUnitUpdateInput {
  name: String
  inventoryUnit: InventoryUnitUpdateManyWithoutStockUnitInput
  category: StockUnitCategoryUpdateOneInput
  expenseUnit: ExpenseUnitUpdateManyWithoutStockUnitInput
}

input StockUnitUpdateManyDataInput {
  name: String
}

input StockUnitUpdateManyInput {
  create: [StockUnitCreateInput!]
  update: [StockUnitUpdateWithWhereUniqueNestedInput!]
  upsert: [StockUnitUpsertWithWhereUniqueNestedInput!]
  delete: [StockUnitWhereUniqueInput!]
  connect: [StockUnitWhereUniqueInput!]
  set: [StockUnitWhereUniqueInput!]
  disconnect: [StockUnitWhereUniqueInput!]
  deleteMany: [StockUnitScalarWhereInput!]
  updateMany: [StockUnitUpdateManyWithWhereNestedInput!]
}

input StockUnitUpdateManyMutationInput {
  name: String
}

input StockUnitUpdateManyWithWhereNestedInput {
  where: StockUnitScalarWhereInput!
  data: StockUnitUpdateManyDataInput!
}

input StockUnitUpdateOneRequiredInput {
  create: StockUnitCreateInput
  update: StockUnitUpdateDataInput
  upsert: StockUnitUpsertNestedInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitUpdateOneRequiredWithoutExpenseUnitInput {
  create: StockUnitCreateWithoutExpenseUnitInput
  update: StockUnitUpdateWithoutExpenseUnitDataInput
  upsert: StockUnitUpsertWithoutExpenseUnitInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitUpdateOneRequiredWithoutInventoryUnitInput {
  create: StockUnitCreateWithoutInventoryUnitInput
  update: StockUnitUpdateWithoutInventoryUnitDataInput
  upsert: StockUnitUpsertWithoutInventoryUnitInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitUpdateWithoutExpenseUnitDataInput {
  name: String
  inventoryUnit: InventoryUnitUpdateManyWithoutStockUnitInput
  category: StockUnitCategoryUpdateOneInput
}

input StockUnitUpdateWithoutInventoryUnitDataInput {
  name: String
  category: StockUnitCategoryUpdateOneInput
  expenseUnit: ExpenseUnitUpdateManyWithoutStockUnitInput
}

input StockUnitUpdateWithWhereUniqueNestedInput {
  where: StockUnitWhereUniqueInput!
  data: StockUnitUpdateDataInput!
}

input StockUnitUpsertNestedInput {
  update: StockUnitUpdateDataInput!
  create: StockUnitCreateInput!
}

input StockUnitUpsertWithoutExpenseUnitInput {
  update: StockUnitUpdateWithoutExpenseUnitDataInput!
  create: StockUnitCreateWithoutExpenseUnitInput!
}

input StockUnitUpsertWithoutInventoryUnitInput {
  update: StockUnitUpdateWithoutInventoryUnitDataInput!
  create: StockUnitCreateWithoutInventoryUnitInput!
}

input StockUnitUpsertWithWhereUniqueNestedInput {
  where: StockUnitWhereUniqueInput!
  update: StockUnitUpdateDataInput!
  create: StockUnitCreateInput!
}

input StockUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  inventoryUnit_every: InventoryUnitWhereInput
  inventoryUnit_some: InventoryUnitWhereInput
  inventoryUnit_none: InventoryUnitWhereInput
  category: StockUnitCategoryWhereInput
  expenseUnit_every: ExpenseUnitWhereInput
  expenseUnit_some: ExpenseUnitWhereInput
  expenseUnit_none: ExpenseUnitWhereInput
  AND: [StockUnitWhereInput!]
  OR: [StockUnitWhereInput!]
  NOT: [StockUnitWhereInput!]
}

input StockUnitWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  currency(where: CurrencySubscriptionWhereInput): CurrencySubscriptionPayload
  expenseUnit(where: ExpenseUnitSubscriptionWhereInput): ExpenseUnitSubscriptionPayload
  inventory(where: InventorySubscriptionWhereInput): InventorySubscriptionPayload
  inventoryUnit(where: InventoryUnitSubscriptionWhereInput): InventoryUnitSubscriptionPayload
  measurementUnit(where: MeasurementUnitSubscriptionWhereInput): MeasurementUnitSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  stockUnit(where: StockUnitSubscriptionWhereInput): StockUnitSubscriptionPayload
  stockUnitCategory(where: StockUnitCategorySubscriptionWhereInput): StockUnitCategorySubscriptionPayload
}
`