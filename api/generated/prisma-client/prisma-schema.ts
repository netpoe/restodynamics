// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateComponent {
  count: Int!
}

type AggregateCurrency {
  count: Int!
}

type AggregateExpenseUnit {
  count: Int!
}

type AggregateInventory {
  count: Int!
}

type AggregateInventoryUnit {
  count: Int!
}

type AggregateMeasurementUnit {
  count: Int!
}

type AggregateStockUnit {
  count: Int!
}

type AggregateStockUnitCategory {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Component {
  id: ID!
  stockUnit: StockUnit!
  inventoryUnit: InventoryUnit
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ComponentConnection {
  pageInfo: PageInfo!
  edges: [ComponentEdge]!
  aggregate: AggregateComponent!
}

input ComponentCreateInput {
  id: ID
  stockUnit: StockUnitCreateOneWithoutComponentsInput!
  inventoryUnit: InventoryUnitCreateOneInput
}

input ComponentCreateManyWithoutStockUnitInput {
  create: [ComponentCreateWithoutStockUnitInput!]
  connect: [ComponentWhereUniqueInput!]
}

input ComponentCreateWithoutStockUnitInput {
  id: ID
  inventoryUnit: InventoryUnitCreateOneInput
}

type ComponentEdge {
  node: Component!
  cursor: String!
}

enum ComponentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ComponentPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ComponentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ComponentScalarWhereInput!]
  OR: [ComponentScalarWhereInput!]
  NOT: [ComponentScalarWhereInput!]
}

type ComponentSubscriptionPayload {
  mutation: MutationType!
  node: Component
  updatedFields: [String!]
  previousValues: ComponentPreviousValues
}

input ComponentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ComponentWhereInput
  AND: [ComponentSubscriptionWhereInput!]
  OR: [ComponentSubscriptionWhereInput!]
  NOT: [ComponentSubscriptionWhereInput!]
}

input ComponentUpdateInput {
  stockUnit: StockUnitUpdateOneRequiredWithoutComponentsInput
  inventoryUnit: InventoryUnitUpdateOneInput
}

input ComponentUpdateManyWithoutStockUnitInput {
  create: [ComponentCreateWithoutStockUnitInput!]
  delete: [ComponentWhereUniqueInput!]
  connect: [ComponentWhereUniqueInput!]
  set: [ComponentWhereUniqueInput!]
  disconnect: [ComponentWhereUniqueInput!]
  update: [ComponentUpdateWithWhereUniqueWithoutStockUnitInput!]
  upsert: [ComponentUpsertWithWhereUniqueWithoutStockUnitInput!]
  deleteMany: [ComponentScalarWhereInput!]
}

input ComponentUpdateWithoutStockUnitDataInput {
  inventoryUnit: InventoryUnitUpdateOneInput
}

input ComponentUpdateWithWhereUniqueWithoutStockUnitInput {
  where: ComponentWhereUniqueInput!
  data: ComponentUpdateWithoutStockUnitDataInput!
}

input ComponentUpsertWithWhereUniqueWithoutStockUnitInput {
  where: ComponentWhereUniqueInput!
  update: ComponentUpdateWithoutStockUnitDataInput!
  create: ComponentCreateWithoutStockUnitInput!
}

input ComponentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stockUnit: StockUnitWhereInput
  inventoryUnit: InventoryUnitWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ComponentWhereInput!]
  OR: [ComponentWhereInput!]
  NOT: [ComponentWhereInput!]
}

input ComponentWhereUniqueInput {
  id: ID
}

type Currency {
  id: ID!
  symbol: String!
  isDefault: Boolean
  createdAt: DateTime!
}

type CurrencyConnection {
  pageInfo: PageInfo!
  edges: [CurrencyEdge]!
  aggregate: AggregateCurrency!
}

input CurrencyCreateInput {
  id: ID
  symbol: String!
  isDefault: Boolean
}

input CurrencyCreateOneInput {
  create: CurrencyCreateInput
  connect: CurrencyWhereUniqueInput
}

type CurrencyEdge {
  node: Currency!
  cursor: String!
}

enum CurrencyOrderByInput {
  id_ASC
  id_DESC
  symbol_ASC
  symbol_DESC
  isDefault_ASC
  isDefault_DESC
  createdAt_ASC
  createdAt_DESC
}

type CurrencyPreviousValues {
  id: ID!
  symbol: String!
  isDefault: Boolean
  createdAt: DateTime!
}

type CurrencySubscriptionPayload {
  mutation: MutationType!
  node: Currency
  updatedFields: [String!]
  previousValues: CurrencyPreviousValues
}

input CurrencySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CurrencyWhereInput
  AND: [CurrencySubscriptionWhereInput!]
  OR: [CurrencySubscriptionWhereInput!]
  NOT: [CurrencySubscriptionWhereInput!]
}

input CurrencyUpdateDataInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateManyMutationInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateOneRequiredInput {
  create: CurrencyCreateInput
  update: CurrencyUpdateDataInput
  upsert: CurrencyUpsertNestedInput
  connect: CurrencyWhereUniqueInput
}

input CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput!
  create: CurrencyCreateInput!
}

input CurrencyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  symbol: String
  symbol_not: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_gt: String
  symbol_gte: String
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  isDefault: Boolean
  isDefault_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CurrencyWhereInput!]
  OR: [CurrencyWhereInput!]
  NOT: [CurrencyWhereInput!]
}

input CurrencyWhereUniqueInput {
  id: ID
  symbol: String
}

scalar DateTime

type ExpenseUnit {
  id: ID!
  amount: String!
  currency: Currency!
  stockUnit: StockUnit!
  createdAt: DateTime!
}

type ExpenseUnitConnection {
  pageInfo: PageInfo!
  edges: [ExpenseUnitEdge]!
  aggregate: AggregateExpenseUnit!
}

input ExpenseUnitCreateInput {
  id: ID
  amount: String
  currency: CurrencyCreateOneInput!
  stockUnit: StockUnitCreateOneWithoutExpenseUnitsInput!
}

input ExpenseUnitCreateManyWithoutStockUnitInput {
  create: [ExpenseUnitCreateWithoutStockUnitInput!]
  connect: [ExpenseUnitWhereUniqueInput!]
}

input ExpenseUnitCreateOneInput {
  create: ExpenseUnitCreateInput
  connect: ExpenseUnitWhereUniqueInput
}

input ExpenseUnitCreateWithoutStockUnitInput {
  id: ID
  amount: String
  currency: CurrencyCreateOneInput!
}

type ExpenseUnitEdge {
  node: ExpenseUnit!
  cursor: String!
}

enum ExpenseUnitOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
}

type ExpenseUnitPreviousValues {
  id: ID!
  amount: String!
  createdAt: DateTime!
}

input ExpenseUnitScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ExpenseUnitScalarWhereInput!]
  OR: [ExpenseUnitScalarWhereInput!]
  NOT: [ExpenseUnitScalarWhereInput!]
}

type ExpenseUnitSubscriptionPayload {
  mutation: MutationType!
  node: ExpenseUnit
  updatedFields: [String!]
  previousValues: ExpenseUnitPreviousValues
}

input ExpenseUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExpenseUnitWhereInput
  AND: [ExpenseUnitSubscriptionWhereInput!]
  OR: [ExpenseUnitSubscriptionWhereInput!]
  NOT: [ExpenseUnitSubscriptionWhereInput!]
}

input ExpenseUnitUpdateDataInput {
  amount: String
  currency: CurrencyUpdateOneRequiredInput
  stockUnit: StockUnitUpdateOneRequiredWithoutExpenseUnitsInput
}

input ExpenseUnitUpdateInput {
  amount: String
  currency: CurrencyUpdateOneRequiredInput
  stockUnit: StockUnitUpdateOneRequiredWithoutExpenseUnitsInput
}

input ExpenseUnitUpdateManyDataInput {
  amount: String
}

input ExpenseUnitUpdateManyMutationInput {
  amount: String
}

input ExpenseUnitUpdateManyWithoutStockUnitInput {
  create: [ExpenseUnitCreateWithoutStockUnitInput!]
  delete: [ExpenseUnitWhereUniqueInput!]
  connect: [ExpenseUnitWhereUniqueInput!]
  set: [ExpenseUnitWhereUniqueInput!]
  disconnect: [ExpenseUnitWhereUniqueInput!]
  update: [ExpenseUnitUpdateWithWhereUniqueWithoutStockUnitInput!]
  upsert: [ExpenseUnitUpsertWithWhereUniqueWithoutStockUnitInput!]
  deleteMany: [ExpenseUnitScalarWhereInput!]
  updateMany: [ExpenseUnitUpdateManyWithWhereNestedInput!]
}

input ExpenseUnitUpdateManyWithWhereNestedInput {
  where: ExpenseUnitScalarWhereInput!
  data: ExpenseUnitUpdateManyDataInput!
}

input ExpenseUnitUpdateOneInput {
  create: ExpenseUnitCreateInput
  update: ExpenseUnitUpdateDataInput
  upsert: ExpenseUnitUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ExpenseUnitWhereUniqueInput
}

input ExpenseUnitUpdateWithoutStockUnitDataInput {
  amount: String
  currency: CurrencyUpdateOneRequiredInput
}

input ExpenseUnitUpdateWithWhereUniqueWithoutStockUnitInput {
  where: ExpenseUnitWhereUniqueInput!
  data: ExpenseUnitUpdateWithoutStockUnitDataInput!
}

input ExpenseUnitUpsertNestedInput {
  update: ExpenseUnitUpdateDataInput!
  create: ExpenseUnitCreateInput!
}

input ExpenseUnitUpsertWithWhereUniqueWithoutStockUnitInput {
  where: ExpenseUnitWhereUniqueInput!
  update: ExpenseUnitUpdateWithoutStockUnitDataInput!
  create: ExpenseUnitCreateWithoutStockUnitInput!
}

input ExpenseUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  currency: CurrencyWhereInput
  stockUnit: StockUnitWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ExpenseUnitWhereInput!]
  OR: [ExpenseUnitWhereInput!]
  NOT: [ExpenseUnitWhereInput!]
}

input ExpenseUnitWhereUniqueInput {
  id: ID
}

type Inventory {
  id: ID!
  createdAt: DateTime!
  inventoryUnits(where: InventoryUnitWhereInput, orderBy: InventoryUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InventoryUnit!]
}

type InventoryConnection {
  pageInfo: PageInfo!
  edges: [InventoryEdge]!
  aggregate: AggregateInventory!
}

input InventoryCreateInput {
  id: ID
  inventoryUnits: InventoryUnitCreateManyWithoutInventoryInput
}

input InventoryCreateOneWithoutInventoryUnitsInput {
  create: InventoryCreateWithoutInventoryUnitsInput
  connect: InventoryWhereUniqueInput
}

input InventoryCreateWithoutInventoryUnitsInput {
  id: ID
}

type InventoryEdge {
  node: Inventory!
  cursor: String!
}

enum InventoryOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
}

type InventoryPreviousValues {
  id: ID!
  createdAt: DateTime!
}

type InventorySubscriptionPayload {
  mutation: MutationType!
  node: Inventory
  updatedFields: [String!]
  previousValues: InventoryPreviousValues
}

input InventorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryWhereInput
  AND: [InventorySubscriptionWhereInput!]
  OR: [InventorySubscriptionWhereInput!]
  NOT: [InventorySubscriptionWhereInput!]
}

type InventoryUnit {
  id: ID!
  inventory: Inventory
  quantity: String!
  unit: MeasurementUnit!
  expenseUnit: ExpenseUnit
  stockUnit: StockUnit
  expiresAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InventoryUnitConnection {
  pageInfo: PageInfo!
  edges: [InventoryUnitEdge]!
  aggregate: AggregateInventoryUnit!
}

input InventoryUnitCreateInput {
  id: ID
  inventory: InventoryCreateOneWithoutInventoryUnitsInput
  quantity: String
  unit: MeasurementUnitCreateOneInput!
  expenseUnit: ExpenseUnitCreateOneInput
  stockUnit: StockUnitCreateOneWithoutInventoryUnitsInput
  expiresAt: DateTime
}

input InventoryUnitCreateManyWithoutInventoryInput {
  create: [InventoryUnitCreateWithoutInventoryInput!]
  connect: [InventoryUnitWhereUniqueInput!]
}

input InventoryUnitCreateManyWithoutStockUnitInput {
  create: [InventoryUnitCreateWithoutStockUnitInput!]
  connect: [InventoryUnitWhereUniqueInput!]
}

input InventoryUnitCreateOneInput {
  create: InventoryUnitCreateInput
  connect: InventoryUnitWhereUniqueInput
}

input InventoryUnitCreateWithoutInventoryInput {
  id: ID
  quantity: String
  unit: MeasurementUnitCreateOneInput!
  expenseUnit: ExpenseUnitCreateOneInput
  stockUnit: StockUnitCreateOneWithoutInventoryUnitsInput
  expiresAt: DateTime
}

input InventoryUnitCreateWithoutStockUnitInput {
  id: ID
  inventory: InventoryCreateOneWithoutInventoryUnitsInput
  quantity: String
  unit: MeasurementUnitCreateOneInput!
  expenseUnit: ExpenseUnitCreateOneInput
  expiresAt: DateTime
}

type InventoryUnitEdge {
  node: InventoryUnit!
  cursor: String!
}

enum InventoryUnitOrderByInput {
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
  expiresAt_ASC
  expiresAt_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InventoryUnitPreviousValues {
  id: ID!
  quantity: String!
  expiresAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input InventoryUnitScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: String
  quantity_not: String
  quantity_in: [String!]
  quantity_not_in: [String!]
  quantity_lt: String
  quantity_lte: String
  quantity_gt: String
  quantity_gte: String
  quantity_contains: String
  quantity_not_contains: String
  quantity_starts_with: String
  quantity_not_starts_with: String
  quantity_ends_with: String
  quantity_not_ends_with: String
  expiresAt: DateTime
  expiresAt_not: DateTime
  expiresAt_in: [DateTime!]
  expiresAt_not_in: [DateTime!]
  expiresAt_lt: DateTime
  expiresAt_lte: DateTime
  expiresAt_gt: DateTime
  expiresAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InventoryUnitScalarWhereInput!]
  OR: [InventoryUnitScalarWhereInput!]
  NOT: [InventoryUnitScalarWhereInput!]
}

type InventoryUnitSubscriptionPayload {
  mutation: MutationType!
  node: InventoryUnit
  updatedFields: [String!]
  previousValues: InventoryUnitPreviousValues
}

input InventoryUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryUnitWhereInput
  AND: [InventoryUnitSubscriptionWhereInput!]
  OR: [InventoryUnitSubscriptionWhereInput!]
  NOT: [InventoryUnitSubscriptionWhereInput!]
}

input InventoryUnitUpdateDataInput {
  inventory: InventoryUpdateOneWithoutInventoryUnitsInput
  quantity: String
  unit: MeasurementUnitUpdateOneRequiredInput
  expenseUnit: ExpenseUnitUpdateOneInput
  stockUnit: StockUnitUpdateOneWithoutInventoryUnitsInput
  expiresAt: DateTime
}

input InventoryUnitUpdateInput {
  inventory: InventoryUpdateOneWithoutInventoryUnitsInput
  quantity: String
  unit: MeasurementUnitUpdateOneRequiredInput
  expenseUnit: ExpenseUnitUpdateOneInput
  stockUnit: StockUnitUpdateOneWithoutInventoryUnitsInput
  expiresAt: DateTime
}

input InventoryUnitUpdateManyDataInput {
  quantity: String
  expiresAt: DateTime
}

input InventoryUnitUpdateManyMutationInput {
  quantity: String
  expiresAt: DateTime
}

input InventoryUnitUpdateManyWithoutInventoryInput {
  create: [InventoryUnitCreateWithoutInventoryInput!]
  delete: [InventoryUnitWhereUniqueInput!]
  connect: [InventoryUnitWhereUniqueInput!]
  set: [InventoryUnitWhereUniqueInput!]
  disconnect: [InventoryUnitWhereUniqueInput!]
  update: [InventoryUnitUpdateWithWhereUniqueWithoutInventoryInput!]
  upsert: [InventoryUnitUpsertWithWhereUniqueWithoutInventoryInput!]
  deleteMany: [InventoryUnitScalarWhereInput!]
  updateMany: [InventoryUnitUpdateManyWithWhereNestedInput!]
}

input InventoryUnitUpdateManyWithoutStockUnitInput {
  create: [InventoryUnitCreateWithoutStockUnitInput!]
  delete: [InventoryUnitWhereUniqueInput!]
  connect: [InventoryUnitWhereUniqueInput!]
  set: [InventoryUnitWhereUniqueInput!]
  disconnect: [InventoryUnitWhereUniqueInput!]
  update: [InventoryUnitUpdateWithWhereUniqueWithoutStockUnitInput!]
  upsert: [InventoryUnitUpsertWithWhereUniqueWithoutStockUnitInput!]
  deleteMany: [InventoryUnitScalarWhereInput!]
  updateMany: [InventoryUnitUpdateManyWithWhereNestedInput!]
}

input InventoryUnitUpdateManyWithWhereNestedInput {
  where: InventoryUnitScalarWhereInput!
  data: InventoryUnitUpdateManyDataInput!
}

input InventoryUnitUpdateOneInput {
  create: InventoryUnitCreateInput
  update: InventoryUnitUpdateDataInput
  upsert: InventoryUnitUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: InventoryUnitWhereUniqueInput
}

input InventoryUnitUpdateWithoutInventoryDataInput {
  quantity: String
  unit: MeasurementUnitUpdateOneRequiredInput
  expenseUnit: ExpenseUnitUpdateOneInput
  stockUnit: StockUnitUpdateOneWithoutInventoryUnitsInput
  expiresAt: DateTime
}

input InventoryUnitUpdateWithoutStockUnitDataInput {
  inventory: InventoryUpdateOneWithoutInventoryUnitsInput
  quantity: String
  unit: MeasurementUnitUpdateOneRequiredInput
  expenseUnit: ExpenseUnitUpdateOneInput
  expiresAt: DateTime
}

input InventoryUnitUpdateWithWhereUniqueWithoutInventoryInput {
  where: InventoryUnitWhereUniqueInput!
  data: InventoryUnitUpdateWithoutInventoryDataInput!
}

input InventoryUnitUpdateWithWhereUniqueWithoutStockUnitInput {
  where: InventoryUnitWhereUniqueInput!
  data: InventoryUnitUpdateWithoutStockUnitDataInput!
}

input InventoryUnitUpsertNestedInput {
  update: InventoryUnitUpdateDataInput!
  create: InventoryUnitCreateInput!
}

input InventoryUnitUpsertWithWhereUniqueWithoutInventoryInput {
  where: InventoryUnitWhereUniqueInput!
  update: InventoryUnitUpdateWithoutInventoryDataInput!
  create: InventoryUnitCreateWithoutInventoryInput!
}

input InventoryUnitUpsertWithWhereUniqueWithoutStockUnitInput {
  where: InventoryUnitWhereUniqueInput!
  update: InventoryUnitUpdateWithoutStockUnitDataInput!
  create: InventoryUnitCreateWithoutStockUnitInput!
}

input InventoryUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  inventory: InventoryWhereInput
  quantity: String
  quantity_not: String
  quantity_in: [String!]
  quantity_not_in: [String!]
  quantity_lt: String
  quantity_lte: String
  quantity_gt: String
  quantity_gte: String
  quantity_contains: String
  quantity_not_contains: String
  quantity_starts_with: String
  quantity_not_starts_with: String
  quantity_ends_with: String
  quantity_not_ends_with: String
  unit: MeasurementUnitWhereInput
  expenseUnit: ExpenseUnitWhereInput
  stockUnit: StockUnitWhereInput
  expiresAt: DateTime
  expiresAt_not: DateTime
  expiresAt_in: [DateTime!]
  expiresAt_not_in: [DateTime!]
  expiresAt_lt: DateTime
  expiresAt_lte: DateTime
  expiresAt_gt: DateTime
  expiresAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InventoryUnitWhereInput!]
  OR: [InventoryUnitWhereInput!]
  NOT: [InventoryUnitWhereInput!]
}

input InventoryUnitWhereUniqueInput {
  id: ID
}

input InventoryUpdateInput {
  inventoryUnits: InventoryUnitUpdateManyWithoutInventoryInput
}

input InventoryUpdateOneWithoutInventoryUnitsInput {
  create: InventoryCreateWithoutInventoryUnitsInput
  delete: Boolean
  disconnect: Boolean
  connect: InventoryWhereUniqueInput
}

input InventoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  inventoryUnits_every: InventoryUnitWhereInput
  inventoryUnits_some: InventoryUnitWhereInput
  inventoryUnits_none: InventoryUnitWhereInput
  AND: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
}

input InventoryWhereUniqueInput {
  id: ID
}

scalar Long

type MeasurementUnit {
  id: ID!
  name: String!
  symbol: String!
}

type MeasurementUnitConnection {
  pageInfo: PageInfo!
  edges: [MeasurementUnitEdge]!
  aggregate: AggregateMeasurementUnit!
}

input MeasurementUnitCreateInput {
  id: ID
  name: String!
  symbol: String!
}

input MeasurementUnitCreateOneInput {
  create: MeasurementUnitCreateInput
  connect: MeasurementUnitWhereUniqueInput
}

type MeasurementUnitEdge {
  node: MeasurementUnit!
  cursor: String!
}

enum MeasurementUnitOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  symbol_ASC
  symbol_DESC
}

type MeasurementUnitPreviousValues {
  id: ID!
  name: String!
  symbol: String!
}

type MeasurementUnitSubscriptionPayload {
  mutation: MutationType!
  node: MeasurementUnit
  updatedFields: [String!]
  previousValues: MeasurementUnitPreviousValues
}

input MeasurementUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MeasurementUnitWhereInput
  AND: [MeasurementUnitSubscriptionWhereInput!]
  OR: [MeasurementUnitSubscriptionWhereInput!]
  NOT: [MeasurementUnitSubscriptionWhereInput!]
}

input MeasurementUnitUpdateDataInput {
  name: String
  symbol: String
}

input MeasurementUnitUpdateInput {
  name: String
  symbol: String
}

input MeasurementUnitUpdateManyMutationInput {
  name: String
  symbol: String
}

input MeasurementUnitUpdateOneRequiredInput {
  create: MeasurementUnitCreateInput
  update: MeasurementUnitUpdateDataInput
  upsert: MeasurementUnitUpsertNestedInput
  connect: MeasurementUnitWhereUniqueInput
}

input MeasurementUnitUpsertNestedInput {
  update: MeasurementUnitUpdateDataInput!
  create: MeasurementUnitCreateInput!
}

input MeasurementUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  symbol: String
  symbol_not: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_gt: String
  symbol_gte: String
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  AND: [MeasurementUnitWhereInput!]
  OR: [MeasurementUnitWhereInput!]
  NOT: [MeasurementUnitWhereInput!]
}

input MeasurementUnitWhereUniqueInput {
  id: ID
  name: String
  symbol: String
}

type Mutation {
  createComponent(data: ComponentCreateInput!): Component!
  updateComponent(data: ComponentUpdateInput!, where: ComponentWhereUniqueInput!): Component
  upsertComponent(where: ComponentWhereUniqueInput!, create: ComponentCreateInput!, update: ComponentUpdateInput!): Component!
  deleteComponent(where: ComponentWhereUniqueInput!): Component
  deleteManyComponents(where: ComponentWhereInput): BatchPayload!
  createCurrency(data: CurrencyCreateInput!): Currency!
  updateCurrency(data: CurrencyUpdateInput!, where: CurrencyWhereUniqueInput!): Currency
  updateManyCurrencies(data: CurrencyUpdateManyMutationInput!, where: CurrencyWhereInput): BatchPayload!
  upsertCurrency(where: CurrencyWhereUniqueInput!, create: CurrencyCreateInput!, update: CurrencyUpdateInput!): Currency!
  deleteCurrency(where: CurrencyWhereUniqueInput!): Currency
  deleteManyCurrencies(where: CurrencyWhereInput): BatchPayload!
  createExpenseUnit(data: ExpenseUnitCreateInput!): ExpenseUnit!
  updateExpenseUnit(data: ExpenseUnitUpdateInput!, where: ExpenseUnitWhereUniqueInput!): ExpenseUnit
  updateManyExpenseUnits(data: ExpenseUnitUpdateManyMutationInput!, where: ExpenseUnitWhereInput): BatchPayload!
  upsertExpenseUnit(where: ExpenseUnitWhereUniqueInput!, create: ExpenseUnitCreateInput!, update: ExpenseUnitUpdateInput!): ExpenseUnit!
  deleteExpenseUnit(where: ExpenseUnitWhereUniqueInput!): ExpenseUnit
  deleteManyExpenseUnits(where: ExpenseUnitWhereInput): BatchPayload!
  createInventory(data: InventoryCreateInput!): Inventory!
  updateInventory(data: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory
  upsertInventory(where: InventoryWhereUniqueInput!, create: InventoryCreateInput!, update: InventoryUpdateInput!): Inventory!
  deleteInventory(where: InventoryWhereUniqueInput!): Inventory
  deleteManyInventories(where: InventoryWhereInput): BatchPayload!
  createInventoryUnit(data: InventoryUnitCreateInput!): InventoryUnit!
  updateInventoryUnit(data: InventoryUnitUpdateInput!, where: InventoryUnitWhereUniqueInput!): InventoryUnit
  updateManyInventoryUnits(data: InventoryUnitUpdateManyMutationInput!, where: InventoryUnitWhereInput): BatchPayload!
  upsertInventoryUnit(where: InventoryUnitWhereUniqueInput!, create: InventoryUnitCreateInput!, update: InventoryUnitUpdateInput!): InventoryUnit!
  deleteInventoryUnit(where: InventoryUnitWhereUniqueInput!): InventoryUnit
  deleteManyInventoryUnits(where: InventoryUnitWhereInput): BatchPayload!
  createMeasurementUnit(data: MeasurementUnitCreateInput!): MeasurementUnit!
  updateMeasurementUnit(data: MeasurementUnitUpdateInput!, where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  updateManyMeasurementUnits(data: MeasurementUnitUpdateManyMutationInput!, where: MeasurementUnitWhereInput): BatchPayload!
  upsertMeasurementUnit(where: MeasurementUnitWhereUniqueInput!, create: MeasurementUnitCreateInput!, update: MeasurementUnitUpdateInput!): MeasurementUnit!
  deleteMeasurementUnit(where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  deleteManyMeasurementUnits(where: MeasurementUnitWhereInput): BatchPayload!
  createStockUnit(data: StockUnitCreateInput!): StockUnit!
  updateStockUnit(data: StockUnitUpdateInput!, where: StockUnitWhereUniqueInput!): StockUnit
  updateManyStockUnits(data: StockUnitUpdateManyMutationInput!, where: StockUnitWhereInput): BatchPayload!
  upsertStockUnit(where: StockUnitWhereUniqueInput!, create: StockUnitCreateInput!, update: StockUnitUpdateInput!): StockUnit!
  deleteStockUnit(where: StockUnitWhereUniqueInput!): StockUnit
  deleteManyStockUnits(where: StockUnitWhereInput): BatchPayload!
  createStockUnitCategory(data: StockUnitCategoryCreateInput!): StockUnitCategory!
  updateStockUnitCategory(data: StockUnitCategoryUpdateInput!, where: StockUnitCategoryWhereUniqueInput!): StockUnitCategory
  updateManyStockUnitCategories(data: StockUnitCategoryUpdateManyMutationInput!, where: StockUnitCategoryWhereInput): BatchPayload!
  upsertStockUnitCategory(where: StockUnitCategoryWhereUniqueInput!, create: StockUnitCategoryCreateInput!, update: StockUnitCategoryUpdateInput!): StockUnitCategory!
  deleteStockUnitCategory(where: StockUnitCategoryWhereUniqueInput!): StockUnitCategory
  deleteManyStockUnitCategories(where: StockUnitCategoryWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  component(where: ComponentWhereUniqueInput!): Component
  components(where: ComponentWhereInput, orderBy: ComponentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Component]!
  componentsConnection(where: ComponentWhereInput, orderBy: ComponentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ComponentConnection!
  currency(where: CurrencyWhereUniqueInput!): Currency
  currencies(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Currency]!
  currenciesConnection(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CurrencyConnection!
  expenseUnit(where: ExpenseUnitWhereUniqueInput!): ExpenseUnit
  expenseUnits(where: ExpenseUnitWhereInput, orderBy: ExpenseUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExpenseUnit]!
  expenseUnitsConnection(where: ExpenseUnitWhereInput, orderBy: ExpenseUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExpenseUnitConnection!
  inventory(where: InventoryWhereUniqueInput!): Inventory
  inventories(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Inventory]!
  inventoriesConnection(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryConnection!
  inventoryUnit(where: InventoryUnitWhereUniqueInput!): InventoryUnit
  inventoryUnits(where: InventoryUnitWhereInput, orderBy: InventoryUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InventoryUnit]!
  inventoryUnitsConnection(where: InventoryUnitWhereInput, orderBy: InventoryUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryUnitConnection!
  measurementUnit(where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  measurementUnits(where: MeasurementUnitWhereInput, orderBy: MeasurementUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MeasurementUnit]!
  measurementUnitsConnection(where: MeasurementUnitWhereInput, orderBy: MeasurementUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MeasurementUnitConnection!
  stockUnit(where: StockUnitWhereUniqueInput!): StockUnit
  stockUnits(where: StockUnitWhereInput, orderBy: StockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StockUnit]!
  stockUnitsConnection(where: StockUnitWhereInput, orderBy: StockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StockUnitConnection!
  stockUnitCategory(where: StockUnitCategoryWhereUniqueInput!): StockUnitCategory
  stockUnitCategories(where: StockUnitCategoryWhereInput, orderBy: StockUnitCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StockUnitCategory]!
  stockUnitCategoriesConnection(where: StockUnitCategoryWhereInput, orderBy: StockUnitCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StockUnitCategoryConnection!
  node(id: ID!): Node
}

type StockUnit {
  id: ID!
  name: String
  category: StockUnitCategory
  inventoryUnits(where: InventoryUnitWhereInput, orderBy: InventoryUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InventoryUnit!]
  expenseUnits(where: ExpenseUnitWhereInput, orderBy: ExpenseUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExpenseUnit!]
  components(where: ComponentWhereInput, orderBy: ComponentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Component!]
}

type StockUnitCategory {
  id: ID!
  name: String!
}

type StockUnitCategoryConnection {
  pageInfo: PageInfo!
  edges: [StockUnitCategoryEdge]!
  aggregate: AggregateStockUnitCategory!
}

input StockUnitCategoryCreateInput {
  id: ID
  name: String!
}

input StockUnitCategoryCreateOneInput {
  create: StockUnitCategoryCreateInput
  connect: StockUnitCategoryWhereUniqueInput
}

type StockUnitCategoryEdge {
  node: StockUnitCategory!
  cursor: String!
}

enum StockUnitCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type StockUnitCategoryPreviousValues {
  id: ID!
  name: String!
}

type StockUnitCategorySubscriptionPayload {
  mutation: MutationType!
  node: StockUnitCategory
  updatedFields: [String!]
  previousValues: StockUnitCategoryPreviousValues
}

input StockUnitCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StockUnitCategoryWhereInput
  AND: [StockUnitCategorySubscriptionWhereInput!]
  OR: [StockUnitCategorySubscriptionWhereInput!]
  NOT: [StockUnitCategorySubscriptionWhereInput!]
}

input StockUnitCategoryUpdateDataInput {
  name: String
}

input StockUnitCategoryUpdateInput {
  name: String
}

input StockUnitCategoryUpdateManyMutationInput {
  name: String
}

input StockUnitCategoryUpdateOneInput {
  create: StockUnitCategoryCreateInput
  update: StockUnitCategoryUpdateDataInput
  upsert: StockUnitCategoryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: StockUnitCategoryWhereUniqueInput
}

input StockUnitCategoryUpsertNestedInput {
  update: StockUnitCategoryUpdateDataInput!
  create: StockUnitCategoryCreateInput!
}

input StockUnitCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [StockUnitCategoryWhereInput!]
  OR: [StockUnitCategoryWhereInput!]
  NOT: [StockUnitCategoryWhereInput!]
}

input StockUnitCategoryWhereUniqueInput {
  id: ID
  name: String
}

type StockUnitConnection {
  pageInfo: PageInfo!
  edges: [StockUnitEdge]!
  aggregate: AggregateStockUnit!
}

input StockUnitCreateInput {
  id: ID
  name: String
  category: StockUnitCategoryCreateOneInput
  inventoryUnits: InventoryUnitCreateManyWithoutStockUnitInput
  expenseUnits: ExpenseUnitCreateManyWithoutStockUnitInput
  components: ComponentCreateManyWithoutStockUnitInput
}

input StockUnitCreateOneWithoutComponentsInput {
  create: StockUnitCreateWithoutComponentsInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitCreateOneWithoutExpenseUnitsInput {
  create: StockUnitCreateWithoutExpenseUnitsInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitCreateOneWithoutInventoryUnitsInput {
  create: StockUnitCreateWithoutInventoryUnitsInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitCreateWithoutComponentsInput {
  id: ID
  name: String
  category: StockUnitCategoryCreateOneInput
  inventoryUnits: InventoryUnitCreateManyWithoutStockUnitInput
  expenseUnits: ExpenseUnitCreateManyWithoutStockUnitInput
}

input StockUnitCreateWithoutExpenseUnitsInput {
  id: ID
  name: String
  category: StockUnitCategoryCreateOneInput
  inventoryUnits: InventoryUnitCreateManyWithoutStockUnitInput
  components: ComponentCreateManyWithoutStockUnitInput
}

input StockUnitCreateWithoutInventoryUnitsInput {
  id: ID
  name: String
  category: StockUnitCategoryCreateOneInput
  expenseUnits: ExpenseUnitCreateManyWithoutStockUnitInput
  components: ComponentCreateManyWithoutStockUnitInput
}

type StockUnitEdge {
  node: StockUnit!
  cursor: String!
}

enum StockUnitOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type StockUnitPreviousValues {
  id: ID!
  name: String
}

type StockUnitSubscriptionPayload {
  mutation: MutationType!
  node: StockUnit
  updatedFields: [String!]
  previousValues: StockUnitPreviousValues
}

input StockUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StockUnitWhereInput
  AND: [StockUnitSubscriptionWhereInput!]
  OR: [StockUnitSubscriptionWhereInput!]
  NOT: [StockUnitSubscriptionWhereInput!]
}

input StockUnitUpdateInput {
  name: String
  category: StockUnitCategoryUpdateOneInput
  inventoryUnits: InventoryUnitUpdateManyWithoutStockUnitInput
  expenseUnits: ExpenseUnitUpdateManyWithoutStockUnitInput
  components: ComponentUpdateManyWithoutStockUnitInput
}

input StockUnitUpdateManyMutationInput {
  name: String
}

input StockUnitUpdateOneRequiredWithoutComponentsInput {
  create: StockUnitCreateWithoutComponentsInput
  update: StockUnitUpdateWithoutComponentsDataInput
  upsert: StockUnitUpsertWithoutComponentsInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitUpdateOneRequiredWithoutExpenseUnitsInput {
  create: StockUnitCreateWithoutExpenseUnitsInput
  update: StockUnitUpdateWithoutExpenseUnitsDataInput
  upsert: StockUnitUpsertWithoutExpenseUnitsInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitUpdateOneWithoutInventoryUnitsInput {
  create: StockUnitCreateWithoutInventoryUnitsInput
  update: StockUnitUpdateWithoutInventoryUnitsDataInput
  upsert: StockUnitUpsertWithoutInventoryUnitsInput
  delete: Boolean
  disconnect: Boolean
  connect: StockUnitWhereUniqueInput
}

input StockUnitUpdateWithoutComponentsDataInput {
  name: String
  category: StockUnitCategoryUpdateOneInput
  inventoryUnits: InventoryUnitUpdateManyWithoutStockUnitInput
  expenseUnits: ExpenseUnitUpdateManyWithoutStockUnitInput
}

input StockUnitUpdateWithoutExpenseUnitsDataInput {
  name: String
  category: StockUnitCategoryUpdateOneInput
  inventoryUnits: InventoryUnitUpdateManyWithoutStockUnitInput
  components: ComponentUpdateManyWithoutStockUnitInput
}

input StockUnitUpdateWithoutInventoryUnitsDataInput {
  name: String
  category: StockUnitCategoryUpdateOneInput
  expenseUnits: ExpenseUnitUpdateManyWithoutStockUnitInput
  components: ComponentUpdateManyWithoutStockUnitInput
}

input StockUnitUpsertWithoutComponentsInput {
  update: StockUnitUpdateWithoutComponentsDataInput!
  create: StockUnitCreateWithoutComponentsInput!
}

input StockUnitUpsertWithoutExpenseUnitsInput {
  update: StockUnitUpdateWithoutExpenseUnitsDataInput!
  create: StockUnitCreateWithoutExpenseUnitsInput!
}

input StockUnitUpsertWithoutInventoryUnitsInput {
  update: StockUnitUpdateWithoutInventoryUnitsDataInput!
  create: StockUnitCreateWithoutInventoryUnitsInput!
}

input StockUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: StockUnitCategoryWhereInput
  inventoryUnits_every: InventoryUnitWhereInput
  inventoryUnits_some: InventoryUnitWhereInput
  inventoryUnits_none: InventoryUnitWhereInput
  expenseUnits_every: ExpenseUnitWhereInput
  expenseUnits_some: ExpenseUnitWhereInput
  expenseUnits_none: ExpenseUnitWhereInput
  components_every: ComponentWhereInput
  components_some: ComponentWhereInput
  components_none: ComponentWhereInput
  AND: [StockUnitWhereInput!]
  OR: [StockUnitWhereInput!]
  NOT: [StockUnitWhereInput!]
}

input StockUnitWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  component(where: ComponentSubscriptionWhereInput): ComponentSubscriptionPayload
  currency(where: CurrencySubscriptionWhereInput): CurrencySubscriptionPayload
  expenseUnit(where: ExpenseUnitSubscriptionWhereInput): ExpenseUnitSubscriptionPayload
  inventory(where: InventorySubscriptionWhereInput): InventorySubscriptionPayload
  inventoryUnit(where: InventoryUnitSubscriptionWhereInput): InventoryUnitSubscriptionPayload
  measurementUnit(where: MeasurementUnitSubscriptionWhereInput): MeasurementUnitSubscriptionPayload
  stockUnit(where: StockUnitSubscriptionWhereInput): StockUnitSubscriptionPayload
  stockUnitCategory(where: StockUnitCategorySubscriptionWhereInput): StockUnitCategorySubscriptionPayload
}
`