// Code generated by Prisma (prisma@1.34.5). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Address {
  id: ID!
  line1: String
  line2: String
  city: String
  region: String
  country: String
  zipCode: String
  createdAt: DateTime!
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  id: ID
  line1: String
  line2: String
  city: String
  region: String
  country: String
  zipCode: String
}

input AddressCreateOneInput {
  create: AddressCreateInput
  connect: AddressWhereUniqueInput
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  line1_ASC
  line1_DESC
  line2_ASC
  line2_DESC
  city_ASC
  city_DESC
  region_ASC
  region_DESC
  country_ASC
  country_DESC
  zipCode_ASC
  zipCode_DESC
  createdAt_ASC
  createdAt_DESC
}

type AddressPreviousValues {
  id: ID!
  line1: String
  line2: String
  city: String
  region: String
  country: String
  zipCode: String
  createdAt: DateTime!
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
  OR: [AddressSubscriptionWhereInput!]
  NOT: [AddressSubscriptionWhereInput!]
}

input AddressUpdateDataInput {
  line1: String
  line2: String
  city: String
  region: String
  country: String
  zipCode: String
}

input AddressUpdateInput {
  line1: String
  line2: String
  city: String
  region: String
  country: String
  zipCode: String
}

input AddressUpdateManyMutationInput {
  line1: String
  line2: String
  city: String
  region: String
  country: String
  zipCode: String
}

input AddressUpdateOneInput {
  create: AddressCreateInput
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AddressWhereUniqueInput
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  line1: String
  line1_not: String
  line1_in: [String!]
  line1_not_in: [String!]
  line1_lt: String
  line1_lte: String
  line1_gt: String
  line1_gte: String
  line1_contains: String
  line1_not_contains: String
  line1_starts_with: String
  line1_not_starts_with: String
  line1_ends_with: String
  line1_not_ends_with: String
  line2: String
  line2_not: String
  line2_in: [String!]
  line2_not_in: [String!]
  line2_lt: String
  line2_lte: String
  line2_gt: String
  line2_gte: String
  line2_contains: String
  line2_not_contains: String
  line2_starts_with: String
  line2_not_starts_with: String
  line2_ends_with: String
  line2_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  region: String
  region_not: String
  region_in: [String!]
  region_not_in: [String!]
  region_lt: String
  region_lte: String
  region_gt: String
  region_gte: String
  region_contains: String
  region_not_contains: String
  region_starts_with: String
  region_not_starts_with: String
  region_ends_with: String
  region_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  zipCode: String
  zipCode_not: String
  zipCode_in: [String!]
  zipCode_not_in: [String!]
  zipCode_lt: String
  zipCode_lte: String
  zipCode_gt: String
  zipCode_gte: String
  zipCode_contains: String
  zipCode_not_contains: String
  zipCode_starts_with: String
  zipCode_not_starts_with: String
  zipCode_ends_with: String
  zipCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateContact {
  count: Int!
}

type AggregateCostUnit {
  count: Int!
}

type AggregateCostUnitByLaborUnit {
  count: Int!
}

type AggregateCostUnitByMenuItem {
  count: Int!
}

type AggregateCostUnitByStockUnit {
  count: Int!
}

type AggregateCurrency {
  count: Int!
}

type AggregateInventory {
  count: Int!
}

type AggregateInventoryByStockUnit {
  count: Int!
}

type AggregateLaborUnit {
  count: Int!
}

type AggregateMeasurementUnit {
  count: Int!
}

type AggregateMenu {
  count: Int!
}

type AggregateMenuItem {
  count: Int!
}

type AggregateMenuItemByMenu {
  count: Int!
}

type AggregateMenuItemByOrder {
  count: Int!
}

type AggregateMenuItemCategory {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregatePrice {
  count: Int!
}

type AggregateStockUnit {
  count: Int!
}

type AggregateStockUnitByMenuItem {
  count: Int!
}

type AggregateStockUnitCategory {
  count: Int!
}

type AggregateSupplier {
  count: Int!
}

type AggregateSupplierByStockUnit {
  count: Int!
}

type AggregateTable {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Contact {
  id: ID!
  email: String
  firstName: String
  lastName: String
  phoneNumber: String
  createdAt: DateTime!
}

type ContactConnection {
  pageInfo: PageInfo!
  edges: [ContactEdge]!
  aggregate: AggregateContact!
}

input ContactCreateInput {
  id: ID
  email: String
  firstName: String
  lastName: String
  phoneNumber: String
}

input ContactCreateOneInput {
  create: ContactCreateInput
  connect: ContactWhereUniqueInput
}

type ContactEdge {
  node: Contact!
  cursor: String!
}

enum ContactOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  createdAt_ASC
  createdAt_DESC
}

type ContactPreviousValues {
  id: ID!
  email: String
  firstName: String
  lastName: String
  phoneNumber: String
  createdAt: DateTime!
}

type ContactSubscriptionPayload {
  mutation: MutationType!
  node: Contact
  updatedFields: [String!]
  previousValues: ContactPreviousValues
}

input ContactSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContactWhereInput
  AND: [ContactSubscriptionWhereInput!]
  OR: [ContactSubscriptionWhereInput!]
  NOT: [ContactSubscriptionWhereInput!]
}

input ContactUpdateDataInput {
  email: String
  firstName: String
  lastName: String
  phoneNumber: String
}

input ContactUpdateInput {
  email: String
  firstName: String
  lastName: String
  phoneNumber: String
}

input ContactUpdateManyMutationInput {
  email: String
  firstName: String
  lastName: String
  phoneNumber: String
}

input ContactUpdateOneInput {
  create: ContactCreateInput
  update: ContactUpdateDataInput
  upsert: ContactUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ContactWhereUniqueInput
}

input ContactUpsertNestedInput {
  update: ContactUpdateDataInput!
  create: ContactCreateInput!
}

input ContactWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  NOT: [ContactWhereInput!]
}

input ContactWhereUniqueInput {
  id: ID
  email: String
}

type CostUnit {
  id: ID!
  amount: String!
  currency: Currency!
  label: String
  createdAt: DateTime!
}

type CostUnitByLaborUnit {
  id: ID!
  laborUnit: LaborUnit!
  costUnit: CostUnit!
}

type CostUnitByLaborUnitConnection {
  pageInfo: PageInfo!
  edges: [CostUnitByLaborUnitEdge]!
  aggregate: AggregateCostUnitByLaborUnit!
}

input CostUnitByLaborUnitCreateInput {
  id: ID
  laborUnit: LaborUnitCreateOneInput!
  costUnit: CostUnitCreateOneInput!
}

type CostUnitByLaborUnitEdge {
  node: CostUnitByLaborUnit!
  cursor: String!
}

enum CostUnitByLaborUnitOrderByInput {
  id_ASC
  id_DESC
}

type CostUnitByLaborUnitPreviousValues {
  id: ID!
}

type CostUnitByLaborUnitSubscriptionPayload {
  mutation: MutationType!
  node: CostUnitByLaborUnit
  updatedFields: [String!]
  previousValues: CostUnitByLaborUnitPreviousValues
}

input CostUnitByLaborUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CostUnitByLaborUnitWhereInput
  AND: [CostUnitByLaborUnitSubscriptionWhereInput!]
  OR: [CostUnitByLaborUnitSubscriptionWhereInput!]
  NOT: [CostUnitByLaborUnitSubscriptionWhereInput!]
}

input CostUnitByLaborUnitUpdateInput {
  laborUnit: LaborUnitUpdateOneRequiredInput
  costUnit: CostUnitUpdateOneRequiredInput
}

input CostUnitByLaborUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  laborUnit: LaborUnitWhereInput
  costUnit: CostUnitWhereInput
  AND: [CostUnitByLaborUnitWhereInput!]
  OR: [CostUnitByLaborUnitWhereInput!]
  NOT: [CostUnitByLaborUnitWhereInput!]
}

input CostUnitByLaborUnitWhereUniqueInput {
  id: ID
}

type CostUnitByMenuItem {
  id: ID!
  menuItem: MenuItem!
  costUnit: CostUnit!
}

type CostUnitByMenuItemConnection {
  pageInfo: PageInfo!
  edges: [CostUnitByMenuItemEdge]!
  aggregate: AggregateCostUnitByMenuItem!
}

input CostUnitByMenuItemCreateInput {
  id: ID
  menuItem: MenuItemCreateOneInput!
  costUnit: CostUnitCreateOneInput!
}

type CostUnitByMenuItemEdge {
  node: CostUnitByMenuItem!
  cursor: String!
}

enum CostUnitByMenuItemOrderByInput {
  id_ASC
  id_DESC
}

type CostUnitByMenuItemPreviousValues {
  id: ID!
}

type CostUnitByMenuItemSubscriptionPayload {
  mutation: MutationType!
  node: CostUnitByMenuItem
  updatedFields: [String!]
  previousValues: CostUnitByMenuItemPreviousValues
}

input CostUnitByMenuItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CostUnitByMenuItemWhereInput
  AND: [CostUnitByMenuItemSubscriptionWhereInput!]
  OR: [CostUnitByMenuItemSubscriptionWhereInput!]
  NOT: [CostUnitByMenuItemSubscriptionWhereInput!]
}

input CostUnitByMenuItemUpdateInput {
  menuItem: MenuItemUpdateOneRequiredInput
  costUnit: CostUnitUpdateOneRequiredInput
}

input CostUnitByMenuItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  menuItem: MenuItemWhereInput
  costUnit: CostUnitWhereInput
  AND: [CostUnitByMenuItemWhereInput!]
  OR: [CostUnitByMenuItemWhereInput!]
  NOT: [CostUnitByMenuItemWhereInput!]
}

input CostUnitByMenuItemWhereUniqueInput {
  id: ID
}

type CostUnitByStockUnit {
  id: ID!
  stockUnit: StockUnit!
  costUnit: CostUnit!
}

type CostUnitByStockUnitConnection {
  pageInfo: PageInfo!
  edges: [CostUnitByStockUnitEdge]!
  aggregate: AggregateCostUnitByStockUnit!
}

input CostUnitByStockUnitCreateInput {
  id: ID
  stockUnit: StockUnitCreateOneInput!
  costUnit: CostUnitCreateOneInput!
}

type CostUnitByStockUnitEdge {
  node: CostUnitByStockUnit!
  cursor: String!
}

enum CostUnitByStockUnitOrderByInput {
  id_ASC
  id_DESC
}

type CostUnitByStockUnitPreviousValues {
  id: ID!
}

type CostUnitByStockUnitSubscriptionPayload {
  mutation: MutationType!
  node: CostUnitByStockUnit
  updatedFields: [String!]
  previousValues: CostUnitByStockUnitPreviousValues
}

input CostUnitByStockUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CostUnitByStockUnitWhereInput
  AND: [CostUnitByStockUnitSubscriptionWhereInput!]
  OR: [CostUnitByStockUnitSubscriptionWhereInput!]
  NOT: [CostUnitByStockUnitSubscriptionWhereInput!]
}

input CostUnitByStockUnitUpdateInput {
  stockUnit: StockUnitUpdateOneRequiredInput
  costUnit: CostUnitUpdateOneRequiredInput
}

input CostUnitByStockUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stockUnit: StockUnitWhereInput
  costUnit: CostUnitWhereInput
  AND: [CostUnitByStockUnitWhereInput!]
  OR: [CostUnitByStockUnitWhereInput!]
  NOT: [CostUnitByStockUnitWhereInput!]
}

input CostUnitByStockUnitWhereUniqueInput {
  id: ID
}

type CostUnitConnection {
  pageInfo: PageInfo!
  edges: [CostUnitEdge]!
  aggregate: AggregateCostUnit!
}

input CostUnitCreateInput {
  id: ID
  amount: String
  currency: CurrencyCreateOneInput!
  label: String
}

input CostUnitCreateOneInput {
  create: CostUnitCreateInput
  connect: CostUnitWhereUniqueInput
}

type CostUnitEdge {
  node: CostUnit!
  cursor: String!
}

enum CostUnitOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  label_ASC
  label_DESC
  createdAt_ASC
  createdAt_DESC
}

type CostUnitPreviousValues {
  id: ID!
  amount: String!
  label: String
  createdAt: DateTime!
}

type CostUnitSubscriptionPayload {
  mutation: MutationType!
  node: CostUnit
  updatedFields: [String!]
  previousValues: CostUnitPreviousValues
}

input CostUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CostUnitWhereInput
  AND: [CostUnitSubscriptionWhereInput!]
  OR: [CostUnitSubscriptionWhereInput!]
  NOT: [CostUnitSubscriptionWhereInput!]
}

input CostUnitUpdateDataInput {
  amount: String
  currency: CurrencyUpdateOneRequiredInput
  label: String
}

input CostUnitUpdateInput {
  amount: String
  currency: CurrencyUpdateOneRequiredInput
  label: String
}

input CostUnitUpdateManyMutationInput {
  amount: String
  label: String
}

input CostUnitUpdateOneRequiredInput {
  create: CostUnitCreateInput
  update: CostUnitUpdateDataInput
  upsert: CostUnitUpsertNestedInput
  connect: CostUnitWhereUniqueInput
}

input CostUnitUpsertNestedInput {
  update: CostUnitUpdateDataInput!
  create: CostUnitCreateInput!
}

input CostUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  currency: CurrencyWhereInput
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CostUnitWhereInput!]
  OR: [CostUnitWhereInput!]
  NOT: [CostUnitWhereInput!]
}

input CostUnitWhereUniqueInput {
  id: ID
}

type Currency {
  id: ID!
  symbol: String!
  isDefault: Boolean
  createdAt: DateTime!
}

type CurrencyConnection {
  pageInfo: PageInfo!
  edges: [CurrencyEdge]!
  aggregate: AggregateCurrency!
}

input CurrencyCreateInput {
  id: ID
  symbol: String!
  isDefault: Boolean
}

input CurrencyCreateOneInput {
  create: CurrencyCreateInput
  connect: CurrencyWhereUniqueInput
}

type CurrencyEdge {
  node: Currency!
  cursor: String!
}

enum CurrencyOrderByInput {
  id_ASC
  id_DESC
  symbol_ASC
  symbol_DESC
  isDefault_ASC
  isDefault_DESC
  createdAt_ASC
  createdAt_DESC
}

type CurrencyPreviousValues {
  id: ID!
  symbol: String!
  isDefault: Boolean
  createdAt: DateTime!
}

type CurrencySubscriptionPayload {
  mutation: MutationType!
  node: Currency
  updatedFields: [String!]
  previousValues: CurrencyPreviousValues
}

input CurrencySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CurrencyWhereInput
  AND: [CurrencySubscriptionWhereInput!]
  OR: [CurrencySubscriptionWhereInput!]
  NOT: [CurrencySubscriptionWhereInput!]
}

input CurrencyUpdateDataInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateManyMutationInput {
  symbol: String
  isDefault: Boolean
}

input CurrencyUpdateOneRequiredInput {
  create: CurrencyCreateInput
  update: CurrencyUpdateDataInput
  upsert: CurrencyUpsertNestedInput
  connect: CurrencyWhereUniqueInput
}

input CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput!
  create: CurrencyCreateInput!
}

input CurrencyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  symbol: String
  symbol_not: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_gt: String
  symbol_gte: String
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  isDefault: Boolean
  isDefault_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CurrencyWhereInput!]
  OR: [CurrencyWhereInput!]
  NOT: [CurrencyWhereInput!]
}

input CurrencyWhereUniqueInput {
  id: ID
}

scalar DateTime

type Inventory {
  id: ID!
  label: String!
  createdAt: DateTime!
}

type InventoryByStockUnit {
  id: ID!
  amount: String!
  stockUnit: StockUnit!
  unit: MeasurementUnit!
  expiresAt: DateTime
}

type InventoryByStockUnitConnection {
  pageInfo: PageInfo!
  edges: [InventoryByStockUnitEdge]!
  aggregate: AggregateInventoryByStockUnit!
}

input InventoryByStockUnitCreateInput {
  id: ID
  amount: String
  stockUnit: StockUnitCreateOneInput!
  unit: MeasurementUnitCreateOneInput!
  expiresAt: DateTime
}

type InventoryByStockUnitEdge {
  node: InventoryByStockUnit!
  cursor: String!
}

enum InventoryByStockUnitOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  expiresAt_ASC
  expiresAt_DESC
}

type InventoryByStockUnitPreviousValues {
  id: ID!
  amount: String!
  expiresAt: DateTime
}

type InventoryByStockUnitSubscriptionPayload {
  mutation: MutationType!
  node: InventoryByStockUnit
  updatedFields: [String!]
  previousValues: InventoryByStockUnitPreviousValues
}

input InventoryByStockUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryByStockUnitWhereInput
  AND: [InventoryByStockUnitSubscriptionWhereInput!]
  OR: [InventoryByStockUnitSubscriptionWhereInput!]
  NOT: [InventoryByStockUnitSubscriptionWhereInput!]
}

input InventoryByStockUnitUpdateInput {
  amount: String
  stockUnit: StockUnitUpdateOneRequiredInput
  unit: MeasurementUnitUpdateOneRequiredInput
  expiresAt: DateTime
}

input InventoryByStockUnitUpdateManyMutationInput {
  amount: String
  expiresAt: DateTime
}

input InventoryByStockUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  stockUnit: StockUnitWhereInput
  unit: MeasurementUnitWhereInput
  expiresAt: DateTime
  expiresAt_not: DateTime
  expiresAt_in: [DateTime!]
  expiresAt_not_in: [DateTime!]
  expiresAt_lt: DateTime
  expiresAt_lte: DateTime
  expiresAt_gt: DateTime
  expiresAt_gte: DateTime
  AND: [InventoryByStockUnitWhereInput!]
  OR: [InventoryByStockUnitWhereInput!]
  NOT: [InventoryByStockUnitWhereInput!]
}

input InventoryByStockUnitWhereUniqueInput {
  id: ID
}

type InventoryConnection {
  pageInfo: PageInfo!
  edges: [InventoryEdge]!
  aggregate: AggregateInventory!
}

input InventoryCreateInput {
  id: ID
  label: String!
}

type InventoryEdge {
  node: Inventory!
  cursor: String!
}

enum InventoryOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  createdAt_ASC
  createdAt_DESC
}

type InventoryPreviousValues {
  id: ID!
  label: String!
  createdAt: DateTime!
}

type InventorySubscriptionPayload {
  mutation: MutationType!
  node: Inventory
  updatedFields: [String!]
  previousValues: InventoryPreviousValues
}

input InventorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryWhereInput
  AND: [InventorySubscriptionWhereInput!]
  OR: [InventorySubscriptionWhereInput!]
  NOT: [InventorySubscriptionWhereInput!]
}

input InventoryUpdateInput {
  label: String
}

input InventoryUpdateManyMutationInput {
  label: String
}

input InventoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
}

input InventoryWhereUniqueInput {
  id: ID
}

type LaborUnit {
  id: ID!
  label: String!
  createdAt: DateTime!
}

type LaborUnitConnection {
  pageInfo: PageInfo!
  edges: [LaborUnitEdge]!
  aggregate: AggregateLaborUnit!
}

input LaborUnitCreateInput {
  id: ID
  label: String!
}

input LaborUnitCreateOneInput {
  create: LaborUnitCreateInput
  connect: LaborUnitWhereUniqueInput
}

type LaborUnitEdge {
  node: LaborUnit!
  cursor: String!
}

enum LaborUnitOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  createdAt_ASC
  createdAt_DESC
}

type LaborUnitPreviousValues {
  id: ID!
  label: String!
  createdAt: DateTime!
}

type LaborUnitSubscriptionPayload {
  mutation: MutationType!
  node: LaborUnit
  updatedFields: [String!]
  previousValues: LaborUnitPreviousValues
}

input LaborUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LaborUnitWhereInput
  AND: [LaborUnitSubscriptionWhereInput!]
  OR: [LaborUnitSubscriptionWhereInput!]
  NOT: [LaborUnitSubscriptionWhereInput!]
}

input LaborUnitUpdateDataInput {
  label: String
}

input LaborUnitUpdateInput {
  label: String
}

input LaborUnitUpdateManyMutationInput {
  label: String
}

input LaborUnitUpdateOneRequiredInput {
  create: LaborUnitCreateInput
  update: LaborUnitUpdateDataInput
  upsert: LaborUnitUpsertNestedInput
  connect: LaborUnitWhereUniqueInput
}

input LaborUnitUpsertNestedInput {
  update: LaborUnitUpdateDataInput!
  create: LaborUnitCreateInput!
}

input LaborUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [LaborUnitWhereInput!]
  OR: [LaborUnitWhereInput!]
  NOT: [LaborUnitWhereInput!]
}

input LaborUnitWhereUniqueInput {
  id: ID
}

scalar Long

type MeasurementUnit {
  id: ID!
  symbol: MeasurementUnitSymbol!
  name: MeasurementUnitName!
}

type MeasurementUnitConnection {
  pageInfo: PageInfo!
  edges: [MeasurementUnitEdge]!
  aggregate: AggregateMeasurementUnit!
}

input MeasurementUnitCreateInput {
  id: ID
  symbol: MeasurementUnitSymbol!
  name: MeasurementUnitName!
}

input MeasurementUnitCreateOneInput {
  create: MeasurementUnitCreateInput
  connect: MeasurementUnitWhereUniqueInput
}

type MeasurementUnitEdge {
  node: MeasurementUnit!
  cursor: String!
}

enum MeasurementUnitName {
  UNITS
  MILILITERS
  LITERS
  GRAMS
  KILOGRAMS
  POUNDS
  METERS
  CENTIMETERS
  CUPS
  OUNCES
}

enum MeasurementUnitOrderByInput {
  id_ASC
  id_DESC
  symbol_ASC
  symbol_DESC
  name_ASC
  name_DESC
}

type MeasurementUnitPreviousValues {
  id: ID!
  symbol: MeasurementUnitSymbol!
  name: MeasurementUnitName!
}

type MeasurementUnitSubscriptionPayload {
  mutation: MutationType!
  node: MeasurementUnit
  updatedFields: [String!]
  previousValues: MeasurementUnitPreviousValues
}

input MeasurementUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MeasurementUnitWhereInput
  AND: [MeasurementUnitSubscriptionWhereInput!]
  OR: [MeasurementUnitSubscriptionWhereInput!]
  NOT: [MeasurementUnitSubscriptionWhereInput!]
}

enum MeasurementUnitSymbol {
  U
  ML
  L
  G
  KG
  LB
  M
  CM
  CUP
  OZ
}

input MeasurementUnitUpdateDataInput {
  symbol: MeasurementUnitSymbol
  name: MeasurementUnitName
}

input MeasurementUnitUpdateInput {
  symbol: MeasurementUnitSymbol
  name: MeasurementUnitName
}

input MeasurementUnitUpdateManyMutationInput {
  symbol: MeasurementUnitSymbol
  name: MeasurementUnitName
}

input MeasurementUnitUpdateOneRequiredInput {
  create: MeasurementUnitCreateInput
  update: MeasurementUnitUpdateDataInput
  upsert: MeasurementUnitUpsertNestedInput
  connect: MeasurementUnitWhereUniqueInput
}

input MeasurementUnitUpsertNestedInput {
  update: MeasurementUnitUpdateDataInput!
  create: MeasurementUnitCreateInput!
}

input MeasurementUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  symbol: MeasurementUnitSymbol
  symbol_not: MeasurementUnitSymbol
  symbol_in: [MeasurementUnitSymbol!]
  symbol_not_in: [MeasurementUnitSymbol!]
  name: MeasurementUnitName
  name_not: MeasurementUnitName
  name_in: [MeasurementUnitName!]
  name_not_in: [MeasurementUnitName!]
  AND: [MeasurementUnitWhereInput!]
  OR: [MeasurementUnitWhereInput!]
  NOT: [MeasurementUnitWhereInput!]
}

input MeasurementUnitWhereUniqueInput {
  id: ID
}

type Menu {
  id: ID!
  label: String!
  createdAt: DateTime!
}

type MenuConnection {
  pageInfo: PageInfo!
  edges: [MenuEdge]!
  aggregate: AggregateMenu!
}

input MenuCreateInput {
  id: ID
  label: String!
}

input MenuCreateOneInput {
  create: MenuCreateInput
  connect: MenuWhereUniqueInput
}

type MenuEdge {
  node: Menu!
  cursor: String!
}

type MenuItem {
  id: ID!
  name: String!
  category: MenuItemCategory!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MenuItemByMenu {
  id: ID!
  menu: Menu!
  menuItem: MenuItem!
}

type MenuItemByMenuConnection {
  pageInfo: PageInfo!
  edges: [MenuItemByMenuEdge]!
  aggregate: AggregateMenuItemByMenu!
}

input MenuItemByMenuCreateInput {
  id: ID
  menu: MenuCreateOneInput!
  menuItem: MenuItemCreateOneInput!
}

type MenuItemByMenuEdge {
  node: MenuItemByMenu!
  cursor: String!
}

enum MenuItemByMenuOrderByInput {
  id_ASC
  id_DESC
}

type MenuItemByMenuPreviousValues {
  id: ID!
}

type MenuItemByMenuSubscriptionPayload {
  mutation: MutationType!
  node: MenuItemByMenu
  updatedFields: [String!]
  previousValues: MenuItemByMenuPreviousValues
}

input MenuItemByMenuSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuItemByMenuWhereInput
  AND: [MenuItemByMenuSubscriptionWhereInput!]
  OR: [MenuItemByMenuSubscriptionWhereInput!]
  NOT: [MenuItemByMenuSubscriptionWhereInput!]
}

input MenuItemByMenuUpdateInput {
  menu: MenuUpdateOneRequiredInput
  menuItem: MenuItemUpdateOneRequiredInput
}

input MenuItemByMenuWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  menu: MenuWhereInput
  menuItem: MenuItemWhereInput
  AND: [MenuItemByMenuWhereInput!]
  OR: [MenuItemByMenuWhereInput!]
  NOT: [MenuItemByMenuWhereInput!]
}

input MenuItemByMenuWhereUniqueInput {
  id: ID
}

type MenuItemByOrder {
  id: ID!
  order: Order!
  menuItem: MenuItem!
}

type MenuItemByOrderConnection {
  pageInfo: PageInfo!
  edges: [MenuItemByOrderEdge]!
  aggregate: AggregateMenuItemByOrder!
}

input MenuItemByOrderCreateInput {
  id: ID
  order: OrderCreateOneInput!
  menuItem: MenuItemCreateOneInput!
}

type MenuItemByOrderEdge {
  node: MenuItemByOrder!
  cursor: String!
}

enum MenuItemByOrderOrderByInput {
  id_ASC
  id_DESC
}

type MenuItemByOrderPreviousValues {
  id: ID!
}

type MenuItemByOrderSubscriptionPayload {
  mutation: MutationType!
  node: MenuItemByOrder
  updatedFields: [String!]
  previousValues: MenuItemByOrderPreviousValues
}

input MenuItemByOrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuItemByOrderWhereInput
  AND: [MenuItemByOrderSubscriptionWhereInput!]
  OR: [MenuItemByOrderSubscriptionWhereInput!]
  NOT: [MenuItemByOrderSubscriptionWhereInput!]
}

input MenuItemByOrderUpdateInput {
  order: OrderUpdateOneRequiredInput
  menuItem: MenuItemUpdateOneRequiredInput
}

input MenuItemByOrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  order: OrderWhereInput
  menuItem: MenuItemWhereInput
  AND: [MenuItemByOrderWhereInput!]
  OR: [MenuItemByOrderWhereInput!]
  NOT: [MenuItemByOrderWhereInput!]
}

input MenuItemByOrderWhereUniqueInput {
  id: ID
}

type MenuItemCategory {
  id: ID!
  name: MenuItemCategoryName!
}

type MenuItemCategoryConnection {
  pageInfo: PageInfo!
  edges: [MenuItemCategoryEdge]!
  aggregate: AggregateMenuItemCategory!
}

input MenuItemCategoryCreateInput {
  id: ID
  name: MenuItemCategoryName!
}

input MenuItemCategoryCreateOneInput {
  create: MenuItemCategoryCreateInput
  connect: MenuItemCategoryWhereUniqueInput
}

type MenuItemCategoryEdge {
  node: MenuItemCategory!
  cursor: String!
}

enum MenuItemCategoryName {
  STARTER
  SIGNATURE
  SOUP
  DESSERT
  BREAKFAST
  POTS
  WRAPS
  COLD_DRINKS
  HOT_DRINKS
}

enum MenuItemCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type MenuItemCategoryPreviousValues {
  id: ID!
  name: MenuItemCategoryName!
}

type MenuItemCategorySubscriptionPayload {
  mutation: MutationType!
  node: MenuItemCategory
  updatedFields: [String!]
  previousValues: MenuItemCategoryPreviousValues
}

input MenuItemCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuItemCategoryWhereInput
  AND: [MenuItemCategorySubscriptionWhereInput!]
  OR: [MenuItemCategorySubscriptionWhereInput!]
  NOT: [MenuItemCategorySubscriptionWhereInput!]
}

input MenuItemCategoryUpdateDataInput {
  name: MenuItemCategoryName
}

input MenuItemCategoryUpdateInput {
  name: MenuItemCategoryName
}

input MenuItemCategoryUpdateManyMutationInput {
  name: MenuItemCategoryName
}

input MenuItemCategoryUpdateOneRequiredInput {
  create: MenuItemCategoryCreateInput
  update: MenuItemCategoryUpdateDataInput
  upsert: MenuItemCategoryUpsertNestedInput
  connect: MenuItemCategoryWhereUniqueInput
}

input MenuItemCategoryUpsertNestedInput {
  update: MenuItemCategoryUpdateDataInput!
  create: MenuItemCategoryCreateInput!
}

input MenuItemCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: MenuItemCategoryName
  name_not: MenuItemCategoryName
  name_in: [MenuItemCategoryName!]
  name_not_in: [MenuItemCategoryName!]
  AND: [MenuItemCategoryWhereInput!]
  OR: [MenuItemCategoryWhereInput!]
  NOT: [MenuItemCategoryWhereInput!]
}

input MenuItemCategoryWhereUniqueInput {
  id: ID
  name: MenuItemCategoryName
}

type MenuItemConnection {
  pageInfo: PageInfo!
  edges: [MenuItemEdge]!
  aggregate: AggregateMenuItem!
}

input MenuItemCreateInput {
  id: ID
  name: String!
  category: MenuItemCategoryCreateOneInput!
}

input MenuItemCreateOneInput {
  create: MenuItemCreateInput
  connect: MenuItemWhereUniqueInput
}

type MenuItemEdge {
  node: MenuItem!
  cursor: String!
}

enum MenuItemOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MenuItemPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MenuItemSubscriptionPayload {
  mutation: MutationType!
  node: MenuItem
  updatedFields: [String!]
  previousValues: MenuItemPreviousValues
}

input MenuItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuItemWhereInput
  AND: [MenuItemSubscriptionWhereInput!]
  OR: [MenuItemSubscriptionWhereInput!]
  NOT: [MenuItemSubscriptionWhereInput!]
}

input MenuItemUpdateDataInput {
  name: String
  category: MenuItemCategoryUpdateOneRequiredInput
}

input MenuItemUpdateInput {
  name: String
  category: MenuItemCategoryUpdateOneRequiredInput
}

input MenuItemUpdateManyMutationInput {
  name: String
}

input MenuItemUpdateOneRequiredInput {
  create: MenuItemCreateInput
  update: MenuItemUpdateDataInput
  upsert: MenuItemUpsertNestedInput
  connect: MenuItemWhereUniqueInput
}

input MenuItemUpsertNestedInput {
  update: MenuItemUpdateDataInput!
  create: MenuItemCreateInput!
}

input MenuItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: MenuItemCategoryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MenuItemWhereInput!]
  OR: [MenuItemWhereInput!]
  NOT: [MenuItemWhereInput!]
}

input MenuItemWhereUniqueInput {
  id: ID
  name: String
}

enum MenuOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  createdAt_ASC
  createdAt_DESC
}

type MenuPreviousValues {
  id: ID!
  label: String!
  createdAt: DateTime!
}

type MenuSubscriptionPayload {
  mutation: MutationType!
  node: Menu
  updatedFields: [String!]
  previousValues: MenuPreviousValues
}

input MenuSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuWhereInput
  AND: [MenuSubscriptionWhereInput!]
  OR: [MenuSubscriptionWhereInput!]
  NOT: [MenuSubscriptionWhereInput!]
}

input MenuUpdateDataInput {
  label: String
}

input MenuUpdateInput {
  label: String
}

input MenuUpdateManyMutationInput {
  label: String
}

input MenuUpdateOneRequiredInput {
  create: MenuCreateInput
  update: MenuUpdateDataInput
  upsert: MenuUpsertNestedInput
  connect: MenuWhereUniqueInput
}

input MenuUpsertNestedInput {
  update: MenuUpdateDataInput!
  create: MenuCreateInput!
}

input MenuWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [MenuWhereInput!]
  OR: [MenuWhereInput!]
  NOT: [MenuWhereInput!]
}

input MenuWhereUniqueInput {
  id: ID
  label: String
}

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createContact(data: ContactCreateInput!): Contact!
  updateContact(data: ContactUpdateInput!, where: ContactWhereUniqueInput!): Contact
  updateManyContacts(data: ContactUpdateManyMutationInput!, where: ContactWhereInput): BatchPayload!
  upsertContact(where: ContactWhereUniqueInput!, create: ContactCreateInput!, update: ContactUpdateInput!): Contact!
  deleteContact(where: ContactWhereUniqueInput!): Contact
  deleteManyContacts(where: ContactWhereInput): BatchPayload!
  createCostUnit(data: CostUnitCreateInput!): CostUnit!
  updateCostUnit(data: CostUnitUpdateInput!, where: CostUnitWhereUniqueInput!): CostUnit
  updateManyCostUnits(data: CostUnitUpdateManyMutationInput!, where: CostUnitWhereInput): BatchPayload!
  upsertCostUnit(where: CostUnitWhereUniqueInput!, create: CostUnitCreateInput!, update: CostUnitUpdateInput!): CostUnit!
  deleteCostUnit(where: CostUnitWhereUniqueInput!): CostUnit
  deleteManyCostUnits(where: CostUnitWhereInput): BatchPayload!
  createCostUnitByLaborUnit(data: CostUnitByLaborUnitCreateInput!): CostUnitByLaborUnit!
  updateCostUnitByLaborUnit(data: CostUnitByLaborUnitUpdateInput!, where: CostUnitByLaborUnitWhereUniqueInput!): CostUnitByLaborUnit
  upsertCostUnitByLaborUnit(where: CostUnitByLaborUnitWhereUniqueInput!, create: CostUnitByLaborUnitCreateInput!, update: CostUnitByLaborUnitUpdateInput!): CostUnitByLaborUnit!
  deleteCostUnitByLaborUnit(where: CostUnitByLaborUnitWhereUniqueInput!): CostUnitByLaborUnit
  deleteManyCostUnitByLaborUnits(where: CostUnitByLaborUnitWhereInput): BatchPayload!
  createCostUnitByMenuItem(data: CostUnitByMenuItemCreateInput!): CostUnitByMenuItem!
  updateCostUnitByMenuItem(data: CostUnitByMenuItemUpdateInput!, where: CostUnitByMenuItemWhereUniqueInput!): CostUnitByMenuItem
  upsertCostUnitByMenuItem(where: CostUnitByMenuItemWhereUniqueInput!, create: CostUnitByMenuItemCreateInput!, update: CostUnitByMenuItemUpdateInput!): CostUnitByMenuItem!
  deleteCostUnitByMenuItem(where: CostUnitByMenuItemWhereUniqueInput!): CostUnitByMenuItem
  deleteManyCostUnitByMenuItems(where: CostUnitByMenuItemWhereInput): BatchPayload!
  createCostUnitByStockUnit(data: CostUnitByStockUnitCreateInput!): CostUnitByStockUnit!
  updateCostUnitByStockUnit(data: CostUnitByStockUnitUpdateInput!, where: CostUnitByStockUnitWhereUniqueInput!): CostUnitByStockUnit
  upsertCostUnitByStockUnit(where: CostUnitByStockUnitWhereUniqueInput!, create: CostUnitByStockUnitCreateInput!, update: CostUnitByStockUnitUpdateInput!): CostUnitByStockUnit!
  deleteCostUnitByStockUnit(where: CostUnitByStockUnitWhereUniqueInput!): CostUnitByStockUnit
  deleteManyCostUnitByStockUnits(where: CostUnitByStockUnitWhereInput): BatchPayload!
  createCurrency(data: CurrencyCreateInput!): Currency!
  updateCurrency(data: CurrencyUpdateInput!, where: CurrencyWhereUniqueInput!): Currency
  updateManyCurrencies(data: CurrencyUpdateManyMutationInput!, where: CurrencyWhereInput): BatchPayload!
  upsertCurrency(where: CurrencyWhereUniqueInput!, create: CurrencyCreateInput!, update: CurrencyUpdateInput!): Currency!
  deleteCurrency(where: CurrencyWhereUniqueInput!): Currency
  deleteManyCurrencies(where: CurrencyWhereInput): BatchPayload!
  createInventory(data: InventoryCreateInput!): Inventory!
  updateInventory(data: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory
  updateManyInventories(data: InventoryUpdateManyMutationInput!, where: InventoryWhereInput): BatchPayload!
  upsertInventory(where: InventoryWhereUniqueInput!, create: InventoryCreateInput!, update: InventoryUpdateInput!): Inventory!
  deleteInventory(where: InventoryWhereUniqueInput!): Inventory
  deleteManyInventories(where: InventoryWhereInput): BatchPayload!
  createInventoryByStockUnit(data: InventoryByStockUnitCreateInput!): InventoryByStockUnit!
  updateInventoryByStockUnit(data: InventoryByStockUnitUpdateInput!, where: InventoryByStockUnitWhereUniqueInput!): InventoryByStockUnit
  updateManyInventoryByStockUnits(data: InventoryByStockUnitUpdateManyMutationInput!, where: InventoryByStockUnitWhereInput): BatchPayload!
  upsertInventoryByStockUnit(where: InventoryByStockUnitWhereUniqueInput!, create: InventoryByStockUnitCreateInput!, update: InventoryByStockUnitUpdateInput!): InventoryByStockUnit!
  deleteInventoryByStockUnit(where: InventoryByStockUnitWhereUniqueInput!): InventoryByStockUnit
  deleteManyInventoryByStockUnits(where: InventoryByStockUnitWhereInput): BatchPayload!
  createLaborUnit(data: LaborUnitCreateInput!): LaborUnit!
  updateLaborUnit(data: LaborUnitUpdateInput!, where: LaborUnitWhereUniqueInput!): LaborUnit
  updateManyLaborUnits(data: LaborUnitUpdateManyMutationInput!, where: LaborUnitWhereInput): BatchPayload!
  upsertLaborUnit(where: LaborUnitWhereUniqueInput!, create: LaborUnitCreateInput!, update: LaborUnitUpdateInput!): LaborUnit!
  deleteLaborUnit(where: LaborUnitWhereUniqueInput!): LaborUnit
  deleteManyLaborUnits(where: LaborUnitWhereInput): BatchPayload!
  createMeasurementUnit(data: MeasurementUnitCreateInput!): MeasurementUnit!
  updateMeasurementUnit(data: MeasurementUnitUpdateInput!, where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  updateManyMeasurementUnits(data: MeasurementUnitUpdateManyMutationInput!, where: MeasurementUnitWhereInput): BatchPayload!
  upsertMeasurementUnit(where: MeasurementUnitWhereUniqueInput!, create: MeasurementUnitCreateInput!, update: MeasurementUnitUpdateInput!): MeasurementUnit!
  deleteMeasurementUnit(where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  deleteManyMeasurementUnits(where: MeasurementUnitWhereInput): BatchPayload!
  createMenu(data: MenuCreateInput!): Menu!
  updateMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
  updateManyMenus(data: MenuUpdateManyMutationInput!, where: MenuWhereInput): BatchPayload!
  upsertMenu(where: MenuWhereUniqueInput!, create: MenuCreateInput!, update: MenuUpdateInput!): Menu!
  deleteMenu(where: MenuWhereUniqueInput!): Menu
  deleteManyMenus(where: MenuWhereInput): BatchPayload!
  createMenuItem(data: MenuItemCreateInput!): MenuItem!
  updateMenuItem(data: MenuItemUpdateInput!, where: MenuItemWhereUniqueInput!): MenuItem
  updateManyMenuItems(data: MenuItemUpdateManyMutationInput!, where: MenuItemWhereInput): BatchPayload!
  upsertMenuItem(where: MenuItemWhereUniqueInput!, create: MenuItemCreateInput!, update: MenuItemUpdateInput!): MenuItem!
  deleteMenuItem(where: MenuItemWhereUniqueInput!): MenuItem
  deleteManyMenuItems(where: MenuItemWhereInput): BatchPayload!
  createMenuItemByMenu(data: MenuItemByMenuCreateInput!): MenuItemByMenu!
  updateMenuItemByMenu(data: MenuItemByMenuUpdateInput!, where: MenuItemByMenuWhereUniqueInput!): MenuItemByMenu
  upsertMenuItemByMenu(where: MenuItemByMenuWhereUniqueInput!, create: MenuItemByMenuCreateInput!, update: MenuItemByMenuUpdateInput!): MenuItemByMenu!
  deleteMenuItemByMenu(where: MenuItemByMenuWhereUniqueInput!): MenuItemByMenu
  deleteManyMenuItemByMenus(where: MenuItemByMenuWhereInput): BatchPayload!
  createMenuItemByOrder(data: MenuItemByOrderCreateInput!): MenuItemByOrder!
  updateMenuItemByOrder(data: MenuItemByOrderUpdateInput!, where: MenuItemByOrderWhereUniqueInput!): MenuItemByOrder
  upsertMenuItemByOrder(where: MenuItemByOrderWhereUniqueInput!, create: MenuItemByOrderCreateInput!, update: MenuItemByOrderUpdateInput!): MenuItemByOrder!
  deleteMenuItemByOrder(where: MenuItemByOrderWhereUniqueInput!): MenuItemByOrder
  deleteManyMenuItemByOrders(where: MenuItemByOrderWhereInput): BatchPayload!
  createMenuItemCategory(data: MenuItemCategoryCreateInput!): MenuItemCategory!
  updateMenuItemCategory(data: MenuItemCategoryUpdateInput!, where: MenuItemCategoryWhereUniqueInput!): MenuItemCategory
  updateManyMenuItemCategories(data: MenuItemCategoryUpdateManyMutationInput!, where: MenuItemCategoryWhereInput): BatchPayload!
  upsertMenuItemCategory(where: MenuItemCategoryWhereUniqueInput!, create: MenuItemCategoryCreateInput!, update: MenuItemCategoryUpdateInput!): MenuItemCategory!
  deleteMenuItemCategory(where: MenuItemCategoryWhereUniqueInput!): MenuItemCategory
  deleteManyMenuItemCategories(where: MenuItemCategoryWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createPrice(data: PriceCreateInput!): Price!
  updatePrice(data: PriceUpdateInput!, where: PriceWhereUniqueInput!): Price
  updateManyPrices(data: PriceUpdateManyMutationInput!, where: PriceWhereInput): BatchPayload!
  upsertPrice(where: PriceWhereUniqueInput!, create: PriceCreateInput!, update: PriceUpdateInput!): Price!
  deletePrice(where: PriceWhereUniqueInput!): Price
  deleteManyPrices(where: PriceWhereInput): BatchPayload!
  createStockUnit(data: StockUnitCreateInput!): StockUnit!
  updateStockUnit(data: StockUnitUpdateInput!, where: StockUnitWhereUniqueInput!): StockUnit
  updateManyStockUnits(data: StockUnitUpdateManyMutationInput!, where: StockUnitWhereInput): BatchPayload!
  upsertStockUnit(where: StockUnitWhereUniqueInput!, create: StockUnitCreateInput!, update: StockUnitUpdateInput!): StockUnit!
  deleteStockUnit(where: StockUnitWhereUniqueInput!): StockUnit
  deleteManyStockUnits(where: StockUnitWhereInput): BatchPayload!
  createStockUnitByMenuItem(data: StockUnitByMenuItemCreateInput!): StockUnitByMenuItem!
  updateStockUnitByMenuItem(data: StockUnitByMenuItemUpdateInput!, where: StockUnitByMenuItemWhereUniqueInput!): StockUnitByMenuItem
  updateManyStockUnitByMenuItems(data: StockUnitByMenuItemUpdateManyMutationInput!, where: StockUnitByMenuItemWhereInput): BatchPayload!
  upsertStockUnitByMenuItem(where: StockUnitByMenuItemWhereUniqueInput!, create: StockUnitByMenuItemCreateInput!, update: StockUnitByMenuItemUpdateInput!): StockUnitByMenuItem!
  deleteStockUnitByMenuItem(where: StockUnitByMenuItemWhereUniqueInput!): StockUnitByMenuItem
  deleteManyStockUnitByMenuItems(where: StockUnitByMenuItemWhereInput): BatchPayload!
  createStockUnitCategory(data: StockUnitCategoryCreateInput!): StockUnitCategory!
  updateStockUnitCategory(data: StockUnitCategoryUpdateInput!, where: StockUnitCategoryWhereUniqueInput!): StockUnitCategory
  updateManyStockUnitCategories(data: StockUnitCategoryUpdateManyMutationInput!, where: StockUnitCategoryWhereInput): BatchPayload!
  upsertStockUnitCategory(where: StockUnitCategoryWhereUniqueInput!, create: StockUnitCategoryCreateInput!, update: StockUnitCategoryUpdateInput!): StockUnitCategory!
  deleteStockUnitCategory(where: StockUnitCategoryWhereUniqueInput!): StockUnitCategory
  deleteManyStockUnitCategories(where: StockUnitCategoryWhereInput): BatchPayload!
  createSupplier(data: SupplierCreateInput!): Supplier!
  updateSupplier(data: SupplierUpdateInput!, where: SupplierWhereUniqueInput!): Supplier
  updateManySuppliers(data: SupplierUpdateManyMutationInput!, where: SupplierWhereInput): BatchPayload!
  upsertSupplier(where: SupplierWhereUniqueInput!, create: SupplierCreateInput!, update: SupplierUpdateInput!): Supplier!
  deleteSupplier(where: SupplierWhereUniqueInput!): Supplier
  deleteManySuppliers(where: SupplierWhereInput): BatchPayload!
  createSupplierByStockUnit(data: SupplierByStockUnitCreateInput!): SupplierByStockUnit!
  updateSupplierByStockUnit(data: SupplierByStockUnitUpdateInput!, where: SupplierByStockUnitWhereUniqueInput!): SupplierByStockUnit
  upsertSupplierByStockUnit(where: SupplierByStockUnitWhereUniqueInput!, create: SupplierByStockUnitCreateInput!, update: SupplierByStockUnitUpdateInput!): SupplierByStockUnit!
  deleteSupplierByStockUnit(where: SupplierByStockUnitWhereUniqueInput!): SupplierByStockUnit
  deleteManySupplierByStockUnits(where: SupplierByStockUnitWhereInput): BatchPayload!
  createTable(data: TableCreateInput!): Table!
  updateTable(data: TableUpdateInput!, where: TableWhereUniqueInput!): Table
  updateManyTables(data: TableUpdateManyMutationInput!, where: TableWhereInput): BatchPayload!
  upsertTable(where: TableWhereUniqueInput!, create: TableCreateInput!, update: TableUpdateInput!): Table!
  deleteTable(where: TableWhereUniqueInput!): Table
  deleteManyTables(where: TableWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
  table: Table!
  amount: String!
  currency: Currency!
  orderedAt: DateTime!
  paidAt: DateTime
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  table: TableCreateOneInput!
  amount: String
  currency: CurrencyCreateOneInput!
  orderedAt: DateTime!
  paidAt: DateTime
}

input OrderCreateOneInput {
  create: OrderCreateInput
  connect: OrderWhereUniqueInput
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  orderedAt_ASC
  orderedAt_DESC
  paidAt_ASC
  paidAt_DESC
}

type OrderPreviousValues {
  id: ID!
  amount: String!
  orderedAt: DateTime!
  paidAt: DateTime
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateDataInput {
  table: TableUpdateOneRequiredInput
  amount: String
  currency: CurrencyUpdateOneRequiredInput
  orderedAt: DateTime
  paidAt: DateTime
}

input OrderUpdateInput {
  table: TableUpdateOneRequiredInput
  amount: String
  currency: CurrencyUpdateOneRequiredInput
  orderedAt: DateTime
  paidAt: DateTime
}

input OrderUpdateManyMutationInput {
  amount: String
  orderedAt: DateTime
  paidAt: DateTime
}

input OrderUpdateOneRequiredInput {
  create: OrderCreateInput
  update: OrderUpdateDataInput
  upsert: OrderUpsertNestedInput
  connect: OrderWhereUniqueInput
}

input OrderUpsertNestedInput {
  update: OrderUpdateDataInput!
  create: OrderCreateInput!
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  table: TableWhereInput
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  currency: CurrencyWhereInput
  orderedAt: DateTime
  orderedAt_not: DateTime
  orderedAt_in: [DateTime!]
  orderedAt_not_in: [DateTime!]
  orderedAt_lt: DateTime
  orderedAt_lte: DateTime
  orderedAt_gt: DateTime
  orderedAt_gte: DateTime
  paidAt: DateTime
  paidAt_not: DateTime
  paidAt_in: [DateTime!]
  paidAt_not_in: [DateTime!]
  paidAt_lt: DateTime
  paidAt_lte: DateTime
  paidAt_gt: DateTime
  paidAt_gte: DateTime
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Price {
  id: ID!
  amount: String!
  currency: Currency!
  label: String
  createdAt: DateTime!
}

type PriceConnection {
  pageInfo: PageInfo!
  edges: [PriceEdge]!
  aggregate: AggregatePrice!
}

input PriceCreateInput {
  id: ID
  amount: String
  currency: CurrencyCreateOneInput!
  label: String
}

type PriceEdge {
  node: Price!
  cursor: String!
}

enum PriceOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  label_ASC
  label_DESC
  createdAt_ASC
  createdAt_DESC
}

type PricePreviousValues {
  id: ID!
  amount: String!
  label: String
  createdAt: DateTime!
}

type PriceSubscriptionPayload {
  mutation: MutationType!
  node: Price
  updatedFields: [String!]
  previousValues: PricePreviousValues
}

input PriceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PriceWhereInput
  AND: [PriceSubscriptionWhereInput!]
  OR: [PriceSubscriptionWhereInput!]
  NOT: [PriceSubscriptionWhereInput!]
}

input PriceUpdateInput {
  amount: String
  currency: CurrencyUpdateOneRequiredInput
  label: String
}

input PriceUpdateManyMutationInput {
  amount: String
  label: String
}

input PriceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  currency: CurrencyWhereInput
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [PriceWhereInput!]
  OR: [PriceWhereInput!]
  NOT: [PriceWhereInput!]
}

input PriceWhereUniqueInput {
  id: ID
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  contact(where: ContactWhereUniqueInput!): Contact
  contacts(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Contact]!
  contactsConnection(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContactConnection!
  costUnit(where: CostUnitWhereUniqueInput!): CostUnit
  costUnits(where: CostUnitWhereInput, orderBy: CostUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CostUnit]!
  costUnitsConnection(where: CostUnitWhereInput, orderBy: CostUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CostUnitConnection!
  costUnitByLaborUnit(where: CostUnitByLaborUnitWhereUniqueInput!): CostUnitByLaborUnit
  costUnitByLaborUnits(where: CostUnitByLaborUnitWhereInput, orderBy: CostUnitByLaborUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CostUnitByLaborUnit]!
  costUnitByLaborUnitsConnection(where: CostUnitByLaborUnitWhereInput, orderBy: CostUnitByLaborUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CostUnitByLaborUnitConnection!
  costUnitByMenuItem(where: CostUnitByMenuItemWhereUniqueInput!): CostUnitByMenuItem
  costUnitByMenuItems(where: CostUnitByMenuItemWhereInput, orderBy: CostUnitByMenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CostUnitByMenuItem]!
  costUnitByMenuItemsConnection(where: CostUnitByMenuItemWhereInput, orderBy: CostUnitByMenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CostUnitByMenuItemConnection!
  costUnitByStockUnit(where: CostUnitByStockUnitWhereUniqueInput!): CostUnitByStockUnit
  costUnitByStockUnits(where: CostUnitByStockUnitWhereInput, orderBy: CostUnitByStockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CostUnitByStockUnit]!
  costUnitByStockUnitsConnection(where: CostUnitByStockUnitWhereInput, orderBy: CostUnitByStockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CostUnitByStockUnitConnection!
  currency(where: CurrencyWhereUniqueInput!): Currency
  currencies(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Currency]!
  currenciesConnection(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CurrencyConnection!
  inventory(where: InventoryWhereUniqueInput!): Inventory
  inventories(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Inventory]!
  inventoriesConnection(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryConnection!
  inventoryByStockUnit(where: InventoryByStockUnitWhereUniqueInput!): InventoryByStockUnit
  inventoryByStockUnits(where: InventoryByStockUnitWhereInput, orderBy: InventoryByStockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InventoryByStockUnit]!
  inventoryByStockUnitsConnection(where: InventoryByStockUnitWhereInput, orderBy: InventoryByStockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryByStockUnitConnection!
  laborUnit(where: LaborUnitWhereUniqueInput!): LaborUnit
  laborUnits(where: LaborUnitWhereInput, orderBy: LaborUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LaborUnit]!
  laborUnitsConnection(where: LaborUnitWhereInput, orderBy: LaborUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LaborUnitConnection!
  measurementUnit(where: MeasurementUnitWhereUniqueInput!): MeasurementUnit
  measurementUnits(where: MeasurementUnitWhereInput, orderBy: MeasurementUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MeasurementUnit]!
  measurementUnitsConnection(where: MeasurementUnitWhereInput, orderBy: MeasurementUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MeasurementUnitConnection!
  menu(where: MenuWhereUniqueInput!): Menu
  menus(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu]!
  menusConnection(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuConnection!
  menuItem(where: MenuItemWhereUniqueInput!): MenuItem
  menuItems(where: MenuItemWhereInput, orderBy: MenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuItem]!
  menuItemsConnection(where: MenuItemWhereInput, orderBy: MenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuItemConnection!
  menuItemByMenu(where: MenuItemByMenuWhereUniqueInput!): MenuItemByMenu
  menuItemByMenus(where: MenuItemByMenuWhereInput, orderBy: MenuItemByMenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuItemByMenu]!
  menuItemByMenusConnection(where: MenuItemByMenuWhereInput, orderBy: MenuItemByMenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuItemByMenuConnection!
  menuItemByOrder(where: MenuItemByOrderWhereUniqueInput!): MenuItemByOrder
  menuItemByOrders(where: MenuItemByOrderWhereInput, orderBy: MenuItemByOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuItemByOrder]!
  menuItemByOrdersConnection(where: MenuItemByOrderWhereInput, orderBy: MenuItemByOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuItemByOrderConnection!
  menuItemCategory(where: MenuItemCategoryWhereUniqueInput!): MenuItemCategory
  menuItemCategories(where: MenuItemCategoryWhereInput, orderBy: MenuItemCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MenuItemCategory]!
  menuItemCategoriesConnection(where: MenuItemCategoryWhereInput, orderBy: MenuItemCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuItemCategoryConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  price(where: PriceWhereUniqueInput!): Price
  prices(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Price]!
  pricesConnection(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PriceConnection!
  stockUnit(where: StockUnitWhereUniqueInput!): StockUnit
  stockUnits(where: StockUnitWhereInput, orderBy: StockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StockUnit]!
  stockUnitsConnection(where: StockUnitWhereInput, orderBy: StockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StockUnitConnection!
  stockUnitByMenuItem(where: StockUnitByMenuItemWhereUniqueInput!): StockUnitByMenuItem
  stockUnitByMenuItems(where: StockUnitByMenuItemWhereInput, orderBy: StockUnitByMenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StockUnitByMenuItem]!
  stockUnitByMenuItemsConnection(where: StockUnitByMenuItemWhereInput, orderBy: StockUnitByMenuItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StockUnitByMenuItemConnection!
  stockUnitCategory(where: StockUnitCategoryWhereUniqueInput!): StockUnitCategory
  stockUnitCategories(where: StockUnitCategoryWhereInput, orderBy: StockUnitCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StockUnitCategory]!
  stockUnitCategoriesConnection(where: StockUnitCategoryWhereInput, orderBy: StockUnitCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StockUnitCategoryConnection!
  supplier(where: SupplierWhereUniqueInput!): Supplier
  suppliers(where: SupplierWhereInput, orderBy: SupplierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Supplier]!
  suppliersConnection(where: SupplierWhereInput, orderBy: SupplierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SupplierConnection!
  supplierByStockUnit(where: SupplierByStockUnitWhereUniqueInput!): SupplierByStockUnit
  supplierByStockUnits(where: SupplierByStockUnitWhereInput, orderBy: SupplierByStockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SupplierByStockUnit]!
  supplierByStockUnitsConnection(where: SupplierByStockUnitWhereInput, orderBy: SupplierByStockUnitOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SupplierByStockUnitConnection!
  table(where: TableWhereUniqueInput!): Table
  tables(where: TableWhereInput, orderBy: TableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Table]!
  tablesConnection(where: TableWhereInput, orderBy: TableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TableConnection!
  node(id: ID!): Node
}

type StockUnit {
  id: ID!
  name: String!
  sku: String
  supplier(where: SupplierWhereInput, orderBy: SupplierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Supplier!]
  stockUnitCategory: StockUnitCategory
  createdAt: DateTime!
}

type StockUnitByMenuItem {
  id: ID!
  menuItem: MenuItem!
  stockUnit: StockUnit!
  amount: String!
}

type StockUnitByMenuItemConnection {
  pageInfo: PageInfo!
  edges: [StockUnitByMenuItemEdge]!
  aggregate: AggregateStockUnitByMenuItem!
}

input StockUnitByMenuItemCreateInput {
  id: ID
  menuItem: MenuItemCreateOneInput!
  stockUnit: StockUnitCreateOneInput!
  amount: String
}

type StockUnitByMenuItemEdge {
  node: StockUnitByMenuItem!
  cursor: String!
}

enum StockUnitByMenuItemOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
}

type StockUnitByMenuItemPreviousValues {
  id: ID!
  amount: String!
}

type StockUnitByMenuItemSubscriptionPayload {
  mutation: MutationType!
  node: StockUnitByMenuItem
  updatedFields: [String!]
  previousValues: StockUnitByMenuItemPreviousValues
}

input StockUnitByMenuItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StockUnitByMenuItemWhereInput
  AND: [StockUnitByMenuItemSubscriptionWhereInput!]
  OR: [StockUnitByMenuItemSubscriptionWhereInput!]
  NOT: [StockUnitByMenuItemSubscriptionWhereInput!]
}

input StockUnitByMenuItemUpdateInput {
  menuItem: MenuItemUpdateOneRequiredInput
  stockUnit: StockUnitUpdateOneRequiredInput
  amount: String
}

input StockUnitByMenuItemUpdateManyMutationInput {
  amount: String
}

input StockUnitByMenuItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  menuItem: MenuItemWhereInput
  stockUnit: StockUnitWhereInput
  amount: String
  amount_not: String
  amount_in: [String!]
  amount_not_in: [String!]
  amount_lt: String
  amount_lte: String
  amount_gt: String
  amount_gte: String
  amount_contains: String
  amount_not_contains: String
  amount_starts_with: String
  amount_not_starts_with: String
  amount_ends_with: String
  amount_not_ends_with: String
  AND: [StockUnitByMenuItemWhereInput!]
  OR: [StockUnitByMenuItemWhereInput!]
  NOT: [StockUnitByMenuItemWhereInput!]
}

input StockUnitByMenuItemWhereUniqueInput {
  id: ID
}

type StockUnitCategory {
  id: ID!
  name: String!
  createdAt: DateTime!
}

type StockUnitCategoryConnection {
  pageInfo: PageInfo!
  edges: [StockUnitCategoryEdge]!
  aggregate: AggregateStockUnitCategory!
}

input StockUnitCategoryCreateInput {
  id: ID
  name: String!
}

input StockUnitCategoryCreateOneInput {
  create: StockUnitCategoryCreateInput
  connect: StockUnitCategoryWhereUniqueInput
}

type StockUnitCategoryEdge {
  node: StockUnitCategory!
  cursor: String!
}

enum StockUnitCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
}

type StockUnitCategoryPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
}

type StockUnitCategorySubscriptionPayload {
  mutation: MutationType!
  node: StockUnitCategory
  updatedFields: [String!]
  previousValues: StockUnitCategoryPreviousValues
}

input StockUnitCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StockUnitCategoryWhereInput
  AND: [StockUnitCategorySubscriptionWhereInput!]
  OR: [StockUnitCategorySubscriptionWhereInput!]
  NOT: [StockUnitCategorySubscriptionWhereInput!]
}

input StockUnitCategoryUpdateDataInput {
  name: String
}

input StockUnitCategoryUpdateInput {
  name: String
}

input StockUnitCategoryUpdateManyMutationInput {
  name: String
}

input StockUnitCategoryUpdateOneInput {
  create: StockUnitCategoryCreateInput
  update: StockUnitCategoryUpdateDataInput
  upsert: StockUnitCategoryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: StockUnitCategoryWhereUniqueInput
}

input StockUnitCategoryUpsertNestedInput {
  update: StockUnitCategoryUpdateDataInput!
  create: StockUnitCategoryCreateInput!
}

input StockUnitCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [StockUnitCategoryWhereInput!]
  OR: [StockUnitCategoryWhereInput!]
  NOT: [StockUnitCategoryWhereInput!]
}

input StockUnitCategoryWhereUniqueInput {
  id: ID
  name: String
}

type StockUnitConnection {
  pageInfo: PageInfo!
  edges: [StockUnitEdge]!
  aggregate: AggregateStockUnit!
}

input StockUnitCreateInput {
  id: ID
  name: String!
  sku: String
  supplier: SupplierCreateManyInput
  stockUnitCategory: StockUnitCategoryCreateOneInput
}

input StockUnitCreateOneInput {
  create: StockUnitCreateInput
  connect: StockUnitWhereUniqueInput
}

type StockUnitEdge {
  node: StockUnit!
  cursor: String!
}

enum StockUnitOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  sku_ASC
  sku_DESC
  createdAt_ASC
  createdAt_DESC
}

type StockUnitPreviousValues {
  id: ID!
  name: String!
  sku: String
  createdAt: DateTime!
}

type StockUnitSubscriptionPayload {
  mutation: MutationType!
  node: StockUnit
  updatedFields: [String!]
  previousValues: StockUnitPreviousValues
}

input StockUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StockUnitWhereInput
  AND: [StockUnitSubscriptionWhereInput!]
  OR: [StockUnitSubscriptionWhereInput!]
  NOT: [StockUnitSubscriptionWhereInput!]
}

input StockUnitUpdateDataInput {
  name: String
  sku: String
  supplier: SupplierUpdateManyInput
  stockUnitCategory: StockUnitCategoryUpdateOneInput
}

input StockUnitUpdateInput {
  name: String
  sku: String
  supplier: SupplierUpdateManyInput
  stockUnitCategory: StockUnitCategoryUpdateOneInput
}

input StockUnitUpdateManyMutationInput {
  name: String
  sku: String
}

input StockUnitUpdateOneRequiredInput {
  create: StockUnitCreateInput
  update: StockUnitUpdateDataInput
  upsert: StockUnitUpsertNestedInput
  connect: StockUnitWhereUniqueInput
}

input StockUnitUpsertNestedInput {
  update: StockUnitUpdateDataInput!
  create: StockUnitCreateInput!
}

input StockUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  supplier_every: SupplierWhereInput
  supplier_some: SupplierWhereInput
  supplier_none: SupplierWhereInput
  stockUnitCategory: StockUnitCategoryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [StockUnitWhereInput!]
  OR: [StockUnitWhereInput!]
  NOT: [StockUnitWhereInput!]
}

input StockUnitWhereUniqueInput {
  id: ID
  name: String
  sku: String
}

type Subscription {
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  contact(where: ContactSubscriptionWhereInput): ContactSubscriptionPayload
  costUnit(where: CostUnitSubscriptionWhereInput): CostUnitSubscriptionPayload
  costUnitByLaborUnit(where: CostUnitByLaborUnitSubscriptionWhereInput): CostUnitByLaborUnitSubscriptionPayload
  costUnitByMenuItem(where: CostUnitByMenuItemSubscriptionWhereInput): CostUnitByMenuItemSubscriptionPayload
  costUnitByStockUnit(where: CostUnitByStockUnitSubscriptionWhereInput): CostUnitByStockUnitSubscriptionPayload
  currency(where: CurrencySubscriptionWhereInput): CurrencySubscriptionPayload
  inventory(where: InventorySubscriptionWhereInput): InventorySubscriptionPayload
  inventoryByStockUnit(where: InventoryByStockUnitSubscriptionWhereInput): InventoryByStockUnitSubscriptionPayload
  laborUnit(where: LaborUnitSubscriptionWhereInput): LaborUnitSubscriptionPayload
  measurementUnit(where: MeasurementUnitSubscriptionWhereInput): MeasurementUnitSubscriptionPayload
  menu(where: MenuSubscriptionWhereInput): MenuSubscriptionPayload
  menuItem(where: MenuItemSubscriptionWhereInput): MenuItemSubscriptionPayload
  menuItemByMenu(where: MenuItemByMenuSubscriptionWhereInput): MenuItemByMenuSubscriptionPayload
  menuItemByOrder(where: MenuItemByOrderSubscriptionWhereInput): MenuItemByOrderSubscriptionPayload
  menuItemCategory(where: MenuItemCategorySubscriptionWhereInput): MenuItemCategorySubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  price(where: PriceSubscriptionWhereInput): PriceSubscriptionPayload
  stockUnit(where: StockUnitSubscriptionWhereInput): StockUnitSubscriptionPayload
  stockUnitByMenuItem(where: StockUnitByMenuItemSubscriptionWhereInput): StockUnitByMenuItemSubscriptionPayload
  stockUnitCategory(where: StockUnitCategorySubscriptionWhereInput): StockUnitCategorySubscriptionPayload
  supplier(where: SupplierSubscriptionWhereInput): SupplierSubscriptionPayload
  supplierByStockUnit(where: SupplierByStockUnitSubscriptionWhereInput): SupplierByStockUnitSubscriptionPayload
  table(where: TableSubscriptionWhereInput): TableSubscriptionPayload
}

type Supplier {
  id: ID!
  name: String!
  contact: Contact
  address: Address
  createdAt: DateTime!
}

type SupplierByStockUnit {
  id: ID!
  stockUnit: StockUnit!
  supplier: Supplier!
}

type SupplierByStockUnitConnection {
  pageInfo: PageInfo!
  edges: [SupplierByStockUnitEdge]!
  aggregate: AggregateSupplierByStockUnit!
}

input SupplierByStockUnitCreateInput {
  id: ID
  stockUnit: StockUnitCreateOneInput!
  supplier: SupplierCreateOneInput!
}

type SupplierByStockUnitEdge {
  node: SupplierByStockUnit!
  cursor: String!
}

enum SupplierByStockUnitOrderByInput {
  id_ASC
  id_DESC
}

type SupplierByStockUnitPreviousValues {
  id: ID!
}

type SupplierByStockUnitSubscriptionPayload {
  mutation: MutationType!
  node: SupplierByStockUnit
  updatedFields: [String!]
  previousValues: SupplierByStockUnitPreviousValues
}

input SupplierByStockUnitSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SupplierByStockUnitWhereInput
  AND: [SupplierByStockUnitSubscriptionWhereInput!]
  OR: [SupplierByStockUnitSubscriptionWhereInput!]
  NOT: [SupplierByStockUnitSubscriptionWhereInput!]
}

input SupplierByStockUnitUpdateInput {
  stockUnit: StockUnitUpdateOneRequiredInput
  supplier: SupplierUpdateOneRequiredInput
}

input SupplierByStockUnitWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stockUnit: StockUnitWhereInput
  supplier: SupplierWhereInput
  AND: [SupplierByStockUnitWhereInput!]
  OR: [SupplierByStockUnitWhereInput!]
  NOT: [SupplierByStockUnitWhereInput!]
}

input SupplierByStockUnitWhereUniqueInput {
  id: ID
}

type SupplierConnection {
  pageInfo: PageInfo!
  edges: [SupplierEdge]!
  aggregate: AggregateSupplier!
}

input SupplierCreateInput {
  id: ID
  name: String!
  contact: ContactCreateOneInput
  address: AddressCreateOneInput
}

input SupplierCreateManyInput {
  create: [SupplierCreateInput!]
  connect: [SupplierWhereUniqueInput!]
}

input SupplierCreateOneInput {
  create: SupplierCreateInput
  connect: SupplierWhereUniqueInput
}

type SupplierEdge {
  node: Supplier!
  cursor: String!
}

enum SupplierOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
}

type SupplierPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
}

input SupplierScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [SupplierScalarWhereInput!]
  OR: [SupplierScalarWhereInput!]
  NOT: [SupplierScalarWhereInput!]
}

type SupplierSubscriptionPayload {
  mutation: MutationType!
  node: Supplier
  updatedFields: [String!]
  previousValues: SupplierPreviousValues
}

input SupplierSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SupplierWhereInput
  AND: [SupplierSubscriptionWhereInput!]
  OR: [SupplierSubscriptionWhereInput!]
  NOT: [SupplierSubscriptionWhereInput!]
}

input SupplierUpdateDataInput {
  name: String
  contact: ContactUpdateOneInput
  address: AddressUpdateOneInput
}

input SupplierUpdateInput {
  name: String
  contact: ContactUpdateOneInput
  address: AddressUpdateOneInput
}

input SupplierUpdateManyDataInput {
  name: String
}

input SupplierUpdateManyInput {
  create: [SupplierCreateInput!]
  update: [SupplierUpdateWithWhereUniqueNestedInput!]
  upsert: [SupplierUpsertWithWhereUniqueNestedInput!]
  delete: [SupplierWhereUniqueInput!]
  connect: [SupplierWhereUniqueInput!]
  set: [SupplierWhereUniqueInput!]
  disconnect: [SupplierWhereUniqueInput!]
  deleteMany: [SupplierScalarWhereInput!]
  updateMany: [SupplierUpdateManyWithWhereNestedInput!]
}

input SupplierUpdateManyMutationInput {
  name: String
}

input SupplierUpdateManyWithWhereNestedInput {
  where: SupplierScalarWhereInput!
  data: SupplierUpdateManyDataInput!
}

input SupplierUpdateOneRequiredInput {
  create: SupplierCreateInput
  update: SupplierUpdateDataInput
  upsert: SupplierUpsertNestedInput
  connect: SupplierWhereUniqueInput
}

input SupplierUpdateWithWhereUniqueNestedInput {
  where: SupplierWhereUniqueInput!
  data: SupplierUpdateDataInput!
}

input SupplierUpsertNestedInput {
  update: SupplierUpdateDataInput!
  create: SupplierCreateInput!
}

input SupplierUpsertWithWhereUniqueNestedInput {
  where: SupplierWhereUniqueInput!
  update: SupplierUpdateDataInput!
  create: SupplierCreateInput!
}

input SupplierWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  contact: ContactWhereInput
  address: AddressWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [SupplierWhereInput!]
  OR: [SupplierWhereInput!]
  NOT: [SupplierWhereInput!]
}

input SupplierWhereUniqueInput {
  id: ID
  name: String
}

type Table {
  id: ID!
  label: String!
  createdAt: DateTime!
}

type TableConnection {
  pageInfo: PageInfo!
  edges: [TableEdge]!
  aggregate: AggregateTable!
}

input TableCreateInput {
  id: ID
  label: String!
}

input TableCreateOneInput {
  create: TableCreateInput
  connect: TableWhereUniqueInput
}

type TableEdge {
  node: Table!
  cursor: String!
}

enum TableOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  createdAt_ASC
  createdAt_DESC
}

type TablePreviousValues {
  id: ID!
  label: String!
  createdAt: DateTime!
}

type TableSubscriptionPayload {
  mutation: MutationType!
  node: Table
  updatedFields: [String!]
  previousValues: TablePreviousValues
}

input TableSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TableWhereInput
  AND: [TableSubscriptionWhereInput!]
  OR: [TableSubscriptionWhereInput!]
  NOT: [TableSubscriptionWhereInput!]
}

input TableUpdateDataInput {
  label: String
}

input TableUpdateInput {
  label: String
}

input TableUpdateManyMutationInput {
  label: String
}

input TableUpdateOneRequiredInput {
  create: TableCreateInput
  update: TableUpdateDataInput
  upsert: TableUpsertNestedInput
  connect: TableWhereUniqueInput
}

input TableUpsertNestedInput {
  update: TableUpdateDataInput!
  create: TableCreateInput!
}

input TableWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [TableWhereInput!]
  OR: [TableWhereInput!]
  NOT: [TableWhereInput!]
}

input TableWhereUniqueInput {
  id: ID
}
`