// Code generated by Prisma (prisma@1.34.5). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  address: (where?: AddressWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  costUnit: (where?: CostUnitWhereInput) => Promise<boolean>;
  costUnitByLaborUnit: (
    where?: CostUnitByLaborUnitWhereInput
  ) => Promise<boolean>;
  costUnitByMenuItem: (
    where?: CostUnitByMenuItemWhereInput
  ) => Promise<boolean>;
  costUnitByStockUnit: (
    where?: CostUnitByStockUnitWhereInput
  ) => Promise<boolean>;
  currency: (where?: CurrencyWhereInput) => Promise<boolean>;
  inventory: (where?: InventoryWhereInput) => Promise<boolean>;
  inventoryByStockUnit: (
    where?: InventoryByStockUnitWhereInput
  ) => Promise<boolean>;
  laborUnit: (where?: LaborUnitWhereInput) => Promise<boolean>;
  measurementUnit: (where?: MeasurementUnitWhereInput) => Promise<boolean>;
  menu: (where?: MenuWhereInput) => Promise<boolean>;
  menuItem: (where?: MenuItemWhereInput) => Promise<boolean>;
  menuItemByMenu: (where?: MenuItemByMenuWhereInput) => Promise<boolean>;
  menuItemByOrder: (where?: MenuItemByOrderWhereInput) => Promise<boolean>;
  menuItemCategory: (where?: MenuItemCategoryWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  price: (where?: PriceWhereInput) => Promise<boolean>;
  stockUnit: (where?: StockUnitWhereInput) => Promise<boolean>;
  stockUnitByMenuItem: (
    where?: StockUnitByMenuItemWhereInput
  ) => Promise<boolean>;
  stockUnitCategory: (where?: StockUnitCategoryWhereInput) => Promise<boolean>;
  supplier: (where?: SupplierWhereInput) => Promise<boolean>;
  supplierByStockUnit: (
    where?: SupplierByStockUnitWhereInput
  ) => Promise<boolean>;
  table: (where?: TableWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  address: (where: AddressWhereUniqueInput) => AddressNullablePromise;
  addresses: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Address>;
  addressesConnection: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AddressConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactNullablePromise;
  contacts: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contact>;
  contactsConnection: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactConnectionPromise;
  costUnit: (where: CostUnitWhereUniqueInput) => CostUnitNullablePromise;
  costUnits: (args?: {
    where?: CostUnitWhereInput;
    orderBy?: CostUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CostUnit>;
  costUnitsConnection: (args?: {
    where?: CostUnitWhereInput;
    orderBy?: CostUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CostUnitConnectionPromise;
  costUnitByLaborUnit: (
    where: CostUnitByLaborUnitWhereUniqueInput
  ) => CostUnitByLaborUnitNullablePromise;
  costUnitByLaborUnits: (args?: {
    where?: CostUnitByLaborUnitWhereInput;
    orderBy?: CostUnitByLaborUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CostUnitByLaborUnit>;
  costUnitByLaborUnitsConnection: (args?: {
    where?: CostUnitByLaborUnitWhereInput;
    orderBy?: CostUnitByLaborUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CostUnitByLaborUnitConnectionPromise;
  costUnitByMenuItem: (
    where: CostUnitByMenuItemWhereUniqueInput
  ) => CostUnitByMenuItemNullablePromise;
  costUnitByMenuItems: (args?: {
    where?: CostUnitByMenuItemWhereInput;
    orderBy?: CostUnitByMenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CostUnitByMenuItem>;
  costUnitByMenuItemsConnection: (args?: {
    where?: CostUnitByMenuItemWhereInput;
    orderBy?: CostUnitByMenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CostUnitByMenuItemConnectionPromise;
  costUnitByStockUnit: (
    where: CostUnitByStockUnitWhereUniqueInput
  ) => CostUnitByStockUnitNullablePromise;
  costUnitByStockUnits: (args?: {
    where?: CostUnitByStockUnitWhereInput;
    orderBy?: CostUnitByStockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CostUnitByStockUnit>;
  costUnitByStockUnitsConnection: (args?: {
    where?: CostUnitByStockUnitWhereInput;
    orderBy?: CostUnitByStockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CostUnitByStockUnitConnectionPromise;
  currency: (where: CurrencyWhereUniqueInput) => CurrencyNullablePromise;
  currencies: (args?: {
    where?: CurrencyWhereInput;
    orderBy?: CurrencyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Currency>;
  currenciesConnection: (args?: {
    where?: CurrencyWhereInput;
    orderBy?: CurrencyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CurrencyConnectionPromise;
  inventory: (where: InventoryWhereUniqueInput) => InventoryNullablePromise;
  inventories: (args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Inventory>;
  inventoriesConnection: (args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InventoryConnectionPromise;
  inventoryByStockUnit: (
    where: InventoryByStockUnitWhereUniqueInput
  ) => InventoryByStockUnitNullablePromise;
  inventoryByStockUnits: (args?: {
    where?: InventoryByStockUnitWhereInput;
    orderBy?: InventoryByStockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<InventoryByStockUnit>;
  inventoryByStockUnitsConnection: (args?: {
    where?: InventoryByStockUnitWhereInput;
    orderBy?: InventoryByStockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InventoryByStockUnitConnectionPromise;
  laborUnit: (where: LaborUnitWhereUniqueInput) => LaborUnitNullablePromise;
  laborUnits: (args?: {
    where?: LaborUnitWhereInput;
    orderBy?: LaborUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LaborUnit>;
  laborUnitsConnection: (args?: {
    where?: LaborUnitWhereInput;
    orderBy?: LaborUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LaborUnitConnectionPromise;
  measurementUnit: (
    where: MeasurementUnitWhereUniqueInput
  ) => MeasurementUnitNullablePromise;
  measurementUnits: (args?: {
    where?: MeasurementUnitWhereInput;
    orderBy?: MeasurementUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MeasurementUnit>;
  measurementUnitsConnection: (args?: {
    where?: MeasurementUnitWhereInput;
    orderBy?: MeasurementUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MeasurementUnitConnectionPromise;
  menu: (where: MenuWhereUniqueInput) => MenuNullablePromise;
  menus: (args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Menu>;
  menusConnection: (args?: {
    where?: MenuWhereInput;
    orderBy?: MenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MenuConnectionPromise;
  menuItem: (where: MenuItemWhereUniqueInput) => MenuItemNullablePromise;
  menuItems: (args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MenuItem>;
  menuItemsConnection: (args?: {
    where?: MenuItemWhereInput;
    orderBy?: MenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MenuItemConnectionPromise;
  menuItemByMenu: (
    where: MenuItemByMenuWhereUniqueInput
  ) => MenuItemByMenuNullablePromise;
  menuItemByMenus: (args?: {
    where?: MenuItemByMenuWhereInput;
    orderBy?: MenuItemByMenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MenuItemByMenu>;
  menuItemByMenusConnection: (args?: {
    where?: MenuItemByMenuWhereInput;
    orderBy?: MenuItemByMenuOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MenuItemByMenuConnectionPromise;
  menuItemByOrder: (
    where: MenuItemByOrderWhereUniqueInput
  ) => MenuItemByOrderNullablePromise;
  menuItemByOrders: (args?: {
    where?: MenuItemByOrderWhereInput;
    orderBy?: MenuItemByOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MenuItemByOrder>;
  menuItemByOrdersConnection: (args?: {
    where?: MenuItemByOrderWhereInput;
    orderBy?: MenuItemByOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MenuItemByOrderConnectionPromise;
  menuItemCategory: (
    where: MenuItemCategoryWhereUniqueInput
  ) => MenuItemCategoryNullablePromise;
  menuItemCategories: (args?: {
    where?: MenuItemCategoryWhereInput;
    orderBy?: MenuItemCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MenuItemCategory>;
  menuItemCategoriesConnection: (args?: {
    where?: MenuItemCategoryWhereInput;
    orderBy?: MenuItemCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MenuItemCategoryConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  price: (where: PriceWhereUniqueInput) => PriceNullablePromise;
  prices: (args?: {
    where?: PriceWhereInput;
    orderBy?: PriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Price>;
  pricesConnection: (args?: {
    where?: PriceWhereInput;
    orderBy?: PriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PriceConnectionPromise;
  stockUnit: (where: StockUnitWhereUniqueInput) => StockUnitNullablePromise;
  stockUnits: (args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StockUnit>;
  stockUnitsConnection: (args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StockUnitConnectionPromise;
  stockUnitByMenuItem: (
    where: StockUnitByMenuItemWhereUniqueInput
  ) => StockUnitByMenuItemNullablePromise;
  stockUnitByMenuItems: (args?: {
    where?: StockUnitByMenuItemWhereInput;
    orderBy?: StockUnitByMenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StockUnitByMenuItem>;
  stockUnitByMenuItemsConnection: (args?: {
    where?: StockUnitByMenuItemWhereInput;
    orderBy?: StockUnitByMenuItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StockUnitByMenuItemConnectionPromise;
  stockUnitCategory: (
    where: StockUnitCategoryWhereUniqueInput
  ) => StockUnitCategoryNullablePromise;
  stockUnitCategories: (args?: {
    where?: StockUnitCategoryWhereInput;
    orderBy?: StockUnitCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StockUnitCategory>;
  stockUnitCategoriesConnection: (args?: {
    where?: StockUnitCategoryWhereInput;
    orderBy?: StockUnitCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StockUnitCategoryConnectionPromise;
  supplier: (where: SupplierWhereUniqueInput) => SupplierNullablePromise;
  suppliers: (args?: {
    where?: SupplierWhereInput;
    orderBy?: SupplierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Supplier>;
  suppliersConnection: (args?: {
    where?: SupplierWhereInput;
    orderBy?: SupplierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SupplierConnectionPromise;
  supplierByStockUnit: (
    where: SupplierByStockUnitWhereUniqueInput
  ) => SupplierByStockUnitNullablePromise;
  supplierByStockUnits: (args?: {
    where?: SupplierByStockUnitWhereInput;
    orderBy?: SupplierByStockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SupplierByStockUnit>;
  supplierByStockUnitsConnection: (args?: {
    where?: SupplierByStockUnitWhereInput;
    orderBy?: SupplierByStockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SupplierByStockUnitConnectionPromise;
  table: (where: TableWhereUniqueInput) => TableNullablePromise;
  tables: (args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Table>;
  tablesConnection: (args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TableConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (args: {
    data: AddressUpdateInput;
    where: AddressWhereUniqueInput;
  }) => AddressPromise;
  updateManyAddresses: (args: {
    data: AddressUpdateManyMutationInput;
    where?: AddressWhereInput;
  }) => BatchPayloadPromise;
  upsertAddress: (args: {
    where: AddressWhereUniqueInput;
    create: AddressCreateInput;
    update: AddressUpdateInput;
  }) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (args: {
    data: ContactUpdateInput;
    where: ContactWhereUniqueInput;
  }) => ContactPromise;
  updateManyContacts: (args: {
    data: ContactUpdateManyMutationInput;
    where?: ContactWhereInput;
  }) => BatchPayloadPromise;
  upsertContact: (args: {
    where: ContactWhereUniqueInput;
    create: ContactCreateInput;
    update: ContactUpdateInput;
  }) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createCostUnit: (data: CostUnitCreateInput) => CostUnitPromise;
  updateCostUnit: (args: {
    data: CostUnitUpdateInput;
    where: CostUnitWhereUniqueInput;
  }) => CostUnitPromise;
  updateManyCostUnits: (args: {
    data: CostUnitUpdateManyMutationInput;
    where?: CostUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertCostUnit: (args: {
    where: CostUnitWhereUniqueInput;
    create: CostUnitCreateInput;
    update: CostUnitUpdateInput;
  }) => CostUnitPromise;
  deleteCostUnit: (where: CostUnitWhereUniqueInput) => CostUnitPromise;
  deleteManyCostUnits: (where?: CostUnitWhereInput) => BatchPayloadPromise;
  createCostUnitByLaborUnit: (
    data: CostUnitByLaborUnitCreateInput
  ) => CostUnitByLaborUnitPromise;
  updateCostUnitByLaborUnit: (args: {
    data: CostUnitByLaborUnitUpdateInput;
    where: CostUnitByLaborUnitWhereUniqueInput;
  }) => CostUnitByLaborUnitPromise;
  upsertCostUnitByLaborUnit: (args: {
    where: CostUnitByLaborUnitWhereUniqueInput;
    create: CostUnitByLaborUnitCreateInput;
    update: CostUnitByLaborUnitUpdateInput;
  }) => CostUnitByLaborUnitPromise;
  deleteCostUnitByLaborUnit: (
    where: CostUnitByLaborUnitWhereUniqueInput
  ) => CostUnitByLaborUnitPromise;
  deleteManyCostUnitByLaborUnits: (
    where?: CostUnitByLaborUnitWhereInput
  ) => BatchPayloadPromise;
  createCostUnitByMenuItem: (
    data: CostUnitByMenuItemCreateInput
  ) => CostUnitByMenuItemPromise;
  updateCostUnitByMenuItem: (args: {
    data: CostUnitByMenuItemUpdateInput;
    where: CostUnitByMenuItemWhereUniqueInput;
  }) => CostUnitByMenuItemPromise;
  upsertCostUnitByMenuItem: (args: {
    where: CostUnitByMenuItemWhereUniqueInput;
    create: CostUnitByMenuItemCreateInput;
    update: CostUnitByMenuItemUpdateInput;
  }) => CostUnitByMenuItemPromise;
  deleteCostUnitByMenuItem: (
    where: CostUnitByMenuItemWhereUniqueInput
  ) => CostUnitByMenuItemPromise;
  deleteManyCostUnitByMenuItems: (
    where?: CostUnitByMenuItemWhereInput
  ) => BatchPayloadPromise;
  createCostUnitByStockUnit: (
    data: CostUnitByStockUnitCreateInput
  ) => CostUnitByStockUnitPromise;
  updateCostUnitByStockUnit: (args: {
    data: CostUnitByStockUnitUpdateInput;
    where: CostUnitByStockUnitWhereUniqueInput;
  }) => CostUnitByStockUnitPromise;
  upsertCostUnitByStockUnit: (args: {
    where: CostUnitByStockUnitWhereUniqueInput;
    create: CostUnitByStockUnitCreateInput;
    update: CostUnitByStockUnitUpdateInput;
  }) => CostUnitByStockUnitPromise;
  deleteCostUnitByStockUnit: (
    where: CostUnitByStockUnitWhereUniqueInput
  ) => CostUnitByStockUnitPromise;
  deleteManyCostUnitByStockUnits: (
    where?: CostUnitByStockUnitWhereInput
  ) => BatchPayloadPromise;
  createCurrency: (data: CurrencyCreateInput) => CurrencyPromise;
  updateCurrency: (args: {
    data: CurrencyUpdateInput;
    where: CurrencyWhereUniqueInput;
  }) => CurrencyPromise;
  updateManyCurrencies: (args: {
    data: CurrencyUpdateManyMutationInput;
    where?: CurrencyWhereInput;
  }) => BatchPayloadPromise;
  upsertCurrency: (args: {
    where: CurrencyWhereUniqueInput;
    create: CurrencyCreateInput;
    update: CurrencyUpdateInput;
  }) => CurrencyPromise;
  deleteCurrency: (where: CurrencyWhereUniqueInput) => CurrencyPromise;
  deleteManyCurrencies: (where?: CurrencyWhereInput) => BatchPayloadPromise;
  createInventory: (data: InventoryCreateInput) => InventoryPromise;
  updateInventory: (args: {
    data: InventoryUpdateInput;
    where: InventoryWhereUniqueInput;
  }) => InventoryPromise;
  updateManyInventories: (args: {
    data: InventoryUpdateManyMutationInput;
    where?: InventoryWhereInput;
  }) => BatchPayloadPromise;
  upsertInventory: (args: {
    where: InventoryWhereUniqueInput;
    create: InventoryCreateInput;
    update: InventoryUpdateInput;
  }) => InventoryPromise;
  deleteInventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  deleteManyInventories: (where?: InventoryWhereInput) => BatchPayloadPromise;
  createInventoryByStockUnit: (
    data: InventoryByStockUnitCreateInput
  ) => InventoryByStockUnitPromise;
  updateInventoryByStockUnit: (args: {
    data: InventoryByStockUnitUpdateInput;
    where: InventoryByStockUnitWhereUniqueInput;
  }) => InventoryByStockUnitPromise;
  updateManyInventoryByStockUnits: (args: {
    data: InventoryByStockUnitUpdateManyMutationInput;
    where?: InventoryByStockUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertInventoryByStockUnit: (args: {
    where: InventoryByStockUnitWhereUniqueInput;
    create: InventoryByStockUnitCreateInput;
    update: InventoryByStockUnitUpdateInput;
  }) => InventoryByStockUnitPromise;
  deleteInventoryByStockUnit: (
    where: InventoryByStockUnitWhereUniqueInput
  ) => InventoryByStockUnitPromise;
  deleteManyInventoryByStockUnits: (
    where?: InventoryByStockUnitWhereInput
  ) => BatchPayloadPromise;
  createLaborUnit: (data: LaborUnitCreateInput) => LaborUnitPromise;
  updateLaborUnit: (args: {
    data: LaborUnitUpdateInput;
    where: LaborUnitWhereUniqueInput;
  }) => LaborUnitPromise;
  updateManyLaborUnits: (args: {
    data: LaborUnitUpdateManyMutationInput;
    where?: LaborUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertLaborUnit: (args: {
    where: LaborUnitWhereUniqueInput;
    create: LaborUnitCreateInput;
    update: LaborUnitUpdateInput;
  }) => LaborUnitPromise;
  deleteLaborUnit: (where: LaborUnitWhereUniqueInput) => LaborUnitPromise;
  deleteManyLaborUnits: (where?: LaborUnitWhereInput) => BatchPayloadPromise;
  createMeasurementUnit: (
    data: MeasurementUnitCreateInput
  ) => MeasurementUnitPromise;
  updateMeasurementUnit: (args: {
    data: MeasurementUnitUpdateInput;
    where: MeasurementUnitWhereUniqueInput;
  }) => MeasurementUnitPromise;
  updateManyMeasurementUnits: (args: {
    data: MeasurementUnitUpdateManyMutationInput;
    where?: MeasurementUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertMeasurementUnit: (args: {
    where: MeasurementUnitWhereUniqueInput;
    create: MeasurementUnitCreateInput;
    update: MeasurementUnitUpdateInput;
  }) => MeasurementUnitPromise;
  deleteMeasurementUnit: (
    where: MeasurementUnitWhereUniqueInput
  ) => MeasurementUnitPromise;
  deleteManyMeasurementUnits: (
    where?: MeasurementUnitWhereInput
  ) => BatchPayloadPromise;
  createMenu: (data: MenuCreateInput) => MenuPromise;
  updateMenu: (args: {
    data: MenuUpdateInput;
    where: MenuWhereUniqueInput;
  }) => MenuPromise;
  updateManyMenus: (args: {
    data: MenuUpdateManyMutationInput;
    where?: MenuWhereInput;
  }) => BatchPayloadPromise;
  upsertMenu: (args: {
    where: MenuWhereUniqueInput;
    create: MenuCreateInput;
    update: MenuUpdateInput;
  }) => MenuPromise;
  deleteMenu: (where: MenuWhereUniqueInput) => MenuPromise;
  deleteManyMenus: (where?: MenuWhereInput) => BatchPayloadPromise;
  createMenuItem: (data: MenuItemCreateInput) => MenuItemPromise;
  updateMenuItem: (args: {
    data: MenuItemUpdateInput;
    where: MenuItemWhereUniqueInput;
  }) => MenuItemPromise;
  updateManyMenuItems: (args: {
    data: MenuItemUpdateManyMutationInput;
    where?: MenuItemWhereInput;
  }) => BatchPayloadPromise;
  upsertMenuItem: (args: {
    where: MenuItemWhereUniqueInput;
    create: MenuItemCreateInput;
    update: MenuItemUpdateInput;
  }) => MenuItemPromise;
  deleteMenuItem: (where: MenuItemWhereUniqueInput) => MenuItemPromise;
  deleteManyMenuItems: (where?: MenuItemWhereInput) => BatchPayloadPromise;
  createMenuItemByMenu: (
    data: MenuItemByMenuCreateInput
  ) => MenuItemByMenuPromise;
  updateMenuItemByMenu: (args: {
    data: MenuItemByMenuUpdateInput;
    where: MenuItemByMenuWhereUniqueInput;
  }) => MenuItemByMenuPromise;
  upsertMenuItemByMenu: (args: {
    where: MenuItemByMenuWhereUniqueInput;
    create: MenuItemByMenuCreateInput;
    update: MenuItemByMenuUpdateInput;
  }) => MenuItemByMenuPromise;
  deleteMenuItemByMenu: (
    where: MenuItemByMenuWhereUniqueInput
  ) => MenuItemByMenuPromise;
  deleteManyMenuItemByMenus: (
    where?: MenuItemByMenuWhereInput
  ) => BatchPayloadPromise;
  createMenuItemByOrder: (
    data: MenuItemByOrderCreateInput
  ) => MenuItemByOrderPromise;
  updateMenuItemByOrder: (args: {
    data: MenuItemByOrderUpdateInput;
    where: MenuItemByOrderWhereUniqueInput;
  }) => MenuItemByOrderPromise;
  upsertMenuItemByOrder: (args: {
    where: MenuItemByOrderWhereUniqueInput;
    create: MenuItemByOrderCreateInput;
    update: MenuItemByOrderUpdateInput;
  }) => MenuItemByOrderPromise;
  deleteMenuItemByOrder: (
    where: MenuItemByOrderWhereUniqueInput
  ) => MenuItemByOrderPromise;
  deleteManyMenuItemByOrders: (
    where?: MenuItemByOrderWhereInput
  ) => BatchPayloadPromise;
  createMenuItemCategory: (
    data: MenuItemCategoryCreateInput
  ) => MenuItemCategoryPromise;
  updateMenuItemCategory: (args: {
    data: MenuItemCategoryUpdateInput;
    where: MenuItemCategoryWhereUniqueInput;
  }) => MenuItemCategoryPromise;
  updateManyMenuItemCategories: (args: {
    data: MenuItemCategoryUpdateManyMutationInput;
    where?: MenuItemCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertMenuItemCategory: (args: {
    where: MenuItemCategoryWhereUniqueInput;
    create: MenuItemCategoryCreateInput;
    update: MenuItemCategoryUpdateInput;
  }) => MenuItemCategoryPromise;
  deleteMenuItemCategory: (
    where: MenuItemCategoryWhereUniqueInput
  ) => MenuItemCategoryPromise;
  deleteManyMenuItemCategories: (
    where?: MenuItemCategoryWhereInput
  ) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createPrice: (data: PriceCreateInput) => PricePromise;
  updatePrice: (args: {
    data: PriceUpdateInput;
    where: PriceWhereUniqueInput;
  }) => PricePromise;
  updateManyPrices: (args: {
    data: PriceUpdateManyMutationInput;
    where?: PriceWhereInput;
  }) => BatchPayloadPromise;
  upsertPrice: (args: {
    where: PriceWhereUniqueInput;
    create: PriceCreateInput;
    update: PriceUpdateInput;
  }) => PricePromise;
  deletePrice: (where: PriceWhereUniqueInput) => PricePromise;
  deleteManyPrices: (where?: PriceWhereInput) => BatchPayloadPromise;
  createStockUnit: (data: StockUnitCreateInput) => StockUnitPromise;
  updateStockUnit: (args: {
    data: StockUnitUpdateInput;
    where: StockUnitWhereUniqueInput;
  }) => StockUnitPromise;
  updateManyStockUnits: (args: {
    data: StockUnitUpdateManyMutationInput;
    where?: StockUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertStockUnit: (args: {
    where: StockUnitWhereUniqueInput;
    create: StockUnitCreateInput;
    update: StockUnitUpdateInput;
  }) => StockUnitPromise;
  deleteStockUnit: (where: StockUnitWhereUniqueInput) => StockUnitPromise;
  deleteManyStockUnits: (where?: StockUnitWhereInput) => BatchPayloadPromise;
  createStockUnitByMenuItem: (
    data: StockUnitByMenuItemCreateInput
  ) => StockUnitByMenuItemPromise;
  updateStockUnitByMenuItem: (args: {
    data: StockUnitByMenuItemUpdateInput;
    where: StockUnitByMenuItemWhereUniqueInput;
  }) => StockUnitByMenuItemPromise;
  updateManyStockUnitByMenuItems: (args: {
    data: StockUnitByMenuItemUpdateManyMutationInput;
    where?: StockUnitByMenuItemWhereInput;
  }) => BatchPayloadPromise;
  upsertStockUnitByMenuItem: (args: {
    where: StockUnitByMenuItemWhereUniqueInput;
    create: StockUnitByMenuItemCreateInput;
    update: StockUnitByMenuItemUpdateInput;
  }) => StockUnitByMenuItemPromise;
  deleteStockUnitByMenuItem: (
    where: StockUnitByMenuItemWhereUniqueInput
  ) => StockUnitByMenuItemPromise;
  deleteManyStockUnitByMenuItems: (
    where?: StockUnitByMenuItemWhereInput
  ) => BatchPayloadPromise;
  createStockUnitCategory: (
    data: StockUnitCategoryCreateInput
  ) => StockUnitCategoryPromise;
  updateStockUnitCategory: (args: {
    data: StockUnitCategoryUpdateInput;
    where: StockUnitCategoryWhereUniqueInput;
  }) => StockUnitCategoryPromise;
  updateManyStockUnitCategories: (args: {
    data: StockUnitCategoryUpdateManyMutationInput;
    where?: StockUnitCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertStockUnitCategory: (args: {
    where: StockUnitCategoryWhereUniqueInput;
    create: StockUnitCategoryCreateInput;
    update: StockUnitCategoryUpdateInput;
  }) => StockUnitCategoryPromise;
  deleteStockUnitCategory: (
    where: StockUnitCategoryWhereUniqueInput
  ) => StockUnitCategoryPromise;
  deleteManyStockUnitCategories: (
    where?: StockUnitCategoryWhereInput
  ) => BatchPayloadPromise;
  createSupplier: (data: SupplierCreateInput) => SupplierPromise;
  updateSupplier: (args: {
    data: SupplierUpdateInput;
    where: SupplierWhereUniqueInput;
  }) => SupplierPromise;
  updateManySuppliers: (args: {
    data: SupplierUpdateManyMutationInput;
    where?: SupplierWhereInput;
  }) => BatchPayloadPromise;
  upsertSupplier: (args: {
    where: SupplierWhereUniqueInput;
    create: SupplierCreateInput;
    update: SupplierUpdateInput;
  }) => SupplierPromise;
  deleteSupplier: (where: SupplierWhereUniqueInput) => SupplierPromise;
  deleteManySuppliers: (where?: SupplierWhereInput) => BatchPayloadPromise;
  createSupplierByStockUnit: (
    data: SupplierByStockUnitCreateInput
  ) => SupplierByStockUnitPromise;
  updateSupplierByStockUnit: (args: {
    data: SupplierByStockUnitUpdateInput;
    where: SupplierByStockUnitWhereUniqueInput;
  }) => SupplierByStockUnitPromise;
  upsertSupplierByStockUnit: (args: {
    where: SupplierByStockUnitWhereUniqueInput;
    create: SupplierByStockUnitCreateInput;
    update: SupplierByStockUnitUpdateInput;
  }) => SupplierByStockUnitPromise;
  deleteSupplierByStockUnit: (
    where: SupplierByStockUnitWhereUniqueInput
  ) => SupplierByStockUnitPromise;
  deleteManySupplierByStockUnits: (
    where?: SupplierByStockUnitWhereInput
  ) => BatchPayloadPromise;
  createTable: (data: TableCreateInput) => TablePromise;
  updateTable: (args: {
    data: TableUpdateInput;
    where: TableWhereUniqueInput;
  }) => TablePromise;
  updateManyTables: (args: {
    data: TableUpdateManyMutationInput;
    where?: TableWhereInput;
  }) => BatchPayloadPromise;
  upsertTable: (args: {
    where: TableWhereUniqueInput;
    create: TableCreateInput;
    update: TableUpdateInput;
  }) => TablePromise;
  deleteTable: (where: TableWhereUniqueInput) => TablePromise;
  deleteManyTables: (where?: TableWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  costUnit: (
    where?: CostUnitSubscriptionWhereInput
  ) => CostUnitSubscriptionPayloadSubscription;
  costUnitByLaborUnit: (
    where?: CostUnitByLaborUnitSubscriptionWhereInput
  ) => CostUnitByLaborUnitSubscriptionPayloadSubscription;
  costUnitByMenuItem: (
    where?: CostUnitByMenuItemSubscriptionWhereInput
  ) => CostUnitByMenuItemSubscriptionPayloadSubscription;
  costUnitByStockUnit: (
    where?: CostUnitByStockUnitSubscriptionWhereInput
  ) => CostUnitByStockUnitSubscriptionPayloadSubscription;
  currency: (
    where?: CurrencySubscriptionWhereInput
  ) => CurrencySubscriptionPayloadSubscription;
  inventory: (
    where?: InventorySubscriptionWhereInput
  ) => InventorySubscriptionPayloadSubscription;
  inventoryByStockUnit: (
    where?: InventoryByStockUnitSubscriptionWhereInput
  ) => InventoryByStockUnitSubscriptionPayloadSubscription;
  laborUnit: (
    where?: LaborUnitSubscriptionWhereInput
  ) => LaborUnitSubscriptionPayloadSubscription;
  measurementUnit: (
    where?: MeasurementUnitSubscriptionWhereInput
  ) => MeasurementUnitSubscriptionPayloadSubscription;
  menu: (
    where?: MenuSubscriptionWhereInput
  ) => MenuSubscriptionPayloadSubscription;
  menuItem: (
    where?: MenuItemSubscriptionWhereInput
  ) => MenuItemSubscriptionPayloadSubscription;
  menuItemByMenu: (
    where?: MenuItemByMenuSubscriptionWhereInput
  ) => MenuItemByMenuSubscriptionPayloadSubscription;
  menuItemByOrder: (
    where?: MenuItemByOrderSubscriptionWhereInput
  ) => MenuItemByOrderSubscriptionPayloadSubscription;
  menuItemCategory: (
    where?: MenuItemCategorySubscriptionWhereInput
  ) => MenuItemCategorySubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  price: (
    where?: PriceSubscriptionWhereInput
  ) => PriceSubscriptionPayloadSubscription;
  stockUnit: (
    where?: StockUnitSubscriptionWhereInput
  ) => StockUnitSubscriptionPayloadSubscription;
  stockUnitByMenuItem: (
    where?: StockUnitByMenuItemSubscriptionWhereInput
  ) => StockUnitByMenuItemSubscriptionPayloadSubscription;
  stockUnitCategory: (
    where?: StockUnitCategorySubscriptionWhereInput
  ) => StockUnitCategorySubscriptionPayloadSubscription;
  supplier: (
    where?: SupplierSubscriptionWhereInput
  ) => SupplierSubscriptionPayloadSubscription;
  supplierByStockUnit: (
    where?: SupplierByStockUnitSubscriptionWhereInput
  ) => SupplierByStockUnitSubscriptionPayloadSubscription;
  table: (
    where?: TableSubscriptionWhereInput
  ) => TableSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type MenuOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "label_ASC"
  | "label_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CostUnitByLaborUnitOrderByInput = "id_ASC" | "id_DESC";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type TableOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "label_ASC"
  | "label_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MeasurementUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "symbol_ASC"
  | "symbol_DESC"
  | "name_ASC"
  | "name_DESC";

export type StockUnitCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "en_EN_ASC"
  | "en_EN_DESC"
  | "es_ES_ASC"
  | "es_ES_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type LaborUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "label_ASC"
  | "label_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type StockUnitByMenuItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type InventoryByStockUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "expiresAt_ASC"
  | "expiresAt_DESC";

export type PriceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "label_ASC"
  | "label_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MeasurementUnitName =
  | "UNITS"
  | "MILILITERS"
  | "LITERS"
  | "GRAMS"
  | "KILOGRAMS"
  | "POUNDS"
  | "METERS"
  | "CENTIMETERS"
  | "CUPS"
  | "OUNCES";

export type MenuItemCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MeasurementUnitSymbol =
  | "U"
  | "ML"
  | "L"
  | "G"
  | "KG"
  | "LB"
  | "M"
  | "CM"
  | "CUP"
  | "OZ";

export type MenuItemByMenuOrderByInput = "id_ASC" | "id_DESC";

export type InventoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "label_ASC"
  | "label_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CurrencyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "symbol_ASC"
  | "symbol_DESC"
  | "isDefault_ASC"
  | "isDefault_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "line1_ASC"
  | "line1_DESC"
  | "line2_ASC"
  | "line2_DESC"
  | "city_ASC"
  | "city_DESC"
  | "region_ASC"
  | "region_DESC"
  | "country_ASC"
  | "country_DESC"
  | "zipCode_ASC"
  | "zipCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CostUnitByStockUnitOrderByInput = "id_ASC" | "id_DESC";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "orderedAt_ASC"
  | "orderedAt_DESC"
  | "paidAt_ASC"
  | "paidAt_DESC";

export type MenuItemCategoryName =
  | "STARTER"
  | "SIGNATURE"
  | "SOUP"
  | "DESSERT"
  | "BREAKFAST"
  | "POTS"
  | "WRAPS"
  | "COLD_DRINKS"
  | "HOT_DRINKS";

export type CostUnitByMenuItemOrderByInput = "id_ASC" | "id_DESC";

export type SupplierOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CostUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "label_ASC"
  | "label_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MenuItemByOrderOrderByInput = "id_ASC" | "id_DESC";

export type StockUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "sku_ASC"
  | "sku_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type SupplierByStockUnitOrderByInput = "id_ASC" | "id_DESC";

export type MenuItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface CurrencyUpdateDataInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export type AddressWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MenuItemByMenuCreateInput {
  id?: Maybe<ID_Input>;
  menu: MenuCreateOneInput;
  menuItem: MenuItemCreateOneInput;
}

export interface SupplierUpdateWithWhereUniqueNestedInput {
  where: SupplierWhereUniqueInput;
  data: SupplierUpdateDataInput;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MenuItemCreateOneInput {
  create?: Maybe<MenuItemCreateInput>;
  connect?: Maybe<MenuItemWhereUniqueInput>;
}

export interface MenuItemUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface LaborUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LaborUnitWhereInput[] | LaborUnitWhereInput>;
  OR?: Maybe<LaborUnitWhereInput[] | LaborUnitWhereInput>;
  NOT?: Maybe<LaborUnitWhereInput[] | LaborUnitWhereInput>;
}

export interface MenuItemUpdateInput {
  name?: Maybe<String>;
  category?: Maybe<MenuItemCategoryUpdateOneRequiredInput>;
}

export interface TableSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TableWhereInput>;
  AND?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
  OR?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
  NOT?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
}

export interface MenuUpdateManyMutationInput {
  label?: Maybe<String>;
}

export interface SupplierSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SupplierWhereInput>;
  AND?: Maybe<
    SupplierSubscriptionWhereInput[] | SupplierSubscriptionWhereInput
  >;
  OR?: Maybe<SupplierSubscriptionWhereInput[] | SupplierSubscriptionWhereInput>;
  NOT?: Maybe<
    SupplierSubscriptionWhereInput[] | SupplierSubscriptionWhereInput
  >;
}

export interface MenuUpdateInput {
  label?: Maybe<String>;
}

export interface StockUnitCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StockUnitCategoryWhereInput>;
  AND?: Maybe<
    | StockUnitCategorySubscriptionWhereInput[]
    | StockUnitCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | StockUnitCategorySubscriptionWhereInput[]
    | StockUnitCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | StockUnitCategorySubscriptionWhereInput[]
    | StockUnitCategorySubscriptionWhereInput
  >;
}

export type PriceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StockUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StockUnitWhereInput>;
  AND?: Maybe<
    StockUnitSubscriptionWhereInput[] | StockUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    StockUnitSubscriptionWhereInput[] | StockUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    StockUnitSubscriptionWhereInput[] | StockUnitSubscriptionWhereInput
  >;
}

export interface MenuCreateInput {
  id?: Maybe<ID_Input>;
  label: String;
}

export interface CostUnitByMenuItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  menuItem?: Maybe<MenuItemWhereInput>;
  costUnit?: Maybe<CostUnitWhereInput>;
  AND?: Maybe<CostUnitByMenuItemWhereInput[] | CostUnitByMenuItemWhereInput>;
  OR?: Maybe<CostUnitByMenuItemWhereInput[] | CostUnitByMenuItemWhereInput>;
  NOT?: Maybe<CostUnitByMenuItemWhereInput[] | CostUnitByMenuItemWhereInput>;
}

export interface PriceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  currency?: Maybe<CurrencyWhereInput>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PriceWhereInput[] | PriceWhereInput>;
  OR?: Maybe<PriceWhereInput[] | PriceWhereInput>;
  NOT?: Maybe<PriceWhereInput[] | PriceWhereInput>;
}

export interface MenuItemCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<MenuItemCategoryName>;
  name_not?: Maybe<MenuItemCategoryName>;
  name_in?: Maybe<MenuItemCategoryName[] | MenuItemCategoryName>;
  name_not_in?: Maybe<MenuItemCategoryName[] | MenuItemCategoryName>;
  AND?: Maybe<MenuItemCategoryWhereInput[] | MenuItemCategoryWhereInput>;
  OR?: Maybe<MenuItemCategoryWhereInput[] | MenuItemCategoryWhereInput>;
  NOT?: Maybe<MenuItemCategoryWhereInput[] | MenuItemCategoryWhereInput>;
}

export interface MeasurementUnitUpdateManyMutationInput {
  symbol?: Maybe<MeasurementUnitSymbol>;
  name?: Maybe<MeasurementUnitName>;
}

export interface MenuItemCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MenuItemCategoryWhereInput>;
  AND?: Maybe<
    | MenuItemCategorySubscriptionWhereInput[]
    | MenuItemCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | MenuItemCategorySubscriptionWhereInput[]
    | MenuItemCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MenuItemCategorySubscriptionWhereInput[]
    | MenuItemCategorySubscriptionWhereInput
  >;
}

export interface MeasurementUnitUpdateInput {
  symbol?: Maybe<MeasurementUnitSymbol>;
  name?: Maybe<MeasurementUnitName>;
}

export interface MenuItemByMenuSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MenuItemByMenuWhereInput>;
  AND?: Maybe<
    | MenuItemByMenuSubscriptionWhereInput[]
    | MenuItemByMenuSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MenuItemByMenuSubscriptionWhereInput[]
    | MenuItemByMenuSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MenuItemByMenuSubscriptionWhereInput[]
    | MenuItemByMenuSubscriptionWhereInput
  >;
}

export interface LaborUnitUpdateManyMutationInput {
  label?: Maybe<String>;
}

export interface MenuItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MenuItemWhereInput>;
  AND?: Maybe<
    MenuItemSubscriptionWhereInput[] | MenuItemSubscriptionWhereInput
  >;
  OR?: Maybe<MenuItemSubscriptionWhereInput[] | MenuItemSubscriptionWhereInput>;
  NOT?: Maybe<
    MenuItemSubscriptionWhereInput[] | MenuItemSubscriptionWhereInput
  >;
}

export interface LaborUnitUpdateInput {
  label?: Maybe<String>;
}

export interface SupplierWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  contact?: Maybe<ContactWhereInput>;
  address?: Maybe<AddressWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SupplierWhereInput[] | SupplierWhereInput>;
  OR?: Maybe<SupplierWhereInput[] | SupplierWhereInput>;
  NOT?: Maybe<SupplierWhereInput[] | SupplierWhereInput>;
}

export type StockUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
  sku?: Maybe<String>;
}>;

export interface LaborUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LaborUnitWhereInput>;
  AND?: Maybe<
    LaborUnitSubscriptionWhereInput[] | LaborUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    LaborUnitSubscriptionWhereInput[] | LaborUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    LaborUnitSubscriptionWhereInput[] | LaborUnitSubscriptionWhereInput
  >;
}

export interface InventoryByStockUnitUpdateManyMutationInput {
  amount?: Maybe<String>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface CostUnitByStockUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  stockUnit?: Maybe<StockUnitWhereInput>;
  costUnit?: Maybe<CostUnitWhereInput>;
  AND?: Maybe<CostUnitByStockUnitWhereInput[] | CostUnitByStockUnitWhereInput>;
  OR?: Maybe<CostUnitByStockUnitWhereInput[] | CostUnitByStockUnitWhereInput>;
  NOT?: Maybe<CostUnitByStockUnitWhereInput[] | CostUnitByStockUnitWhereInput>;
}

export interface MeasurementUnitUpsertNestedInput {
  update: MeasurementUnitUpdateDataInput;
  create: MeasurementUnitCreateInput;
}

export interface StockUnitCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  en_EN?: Maybe<String>;
  en_EN_not?: Maybe<String>;
  en_EN_in?: Maybe<String[] | String>;
  en_EN_not_in?: Maybe<String[] | String>;
  en_EN_lt?: Maybe<String>;
  en_EN_lte?: Maybe<String>;
  en_EN_gt?: Maybe<String>;
  en_EN_gte?: Maybe<String>;
  en_EN_contains?: Maybe<String>;
  en_EN_not_contains?: Maybe<String>;
  en_EN_starts_with?: Maybe<String>;
  en_EN_not_starts_with?: Maybe<String>;
  en_EN_ends_with?: Maybe<String>;
  en_EN_not_ends_with?: Maybe<String>;
  es_ES?: Maybe<String>;
  es_ES_not?: Maybe<String>;
  es_ES_in?: Maybe<String[] | String>;
  es_ES_not_in?: Maybe<String[] | String>;
  es_ES_lt?: Maybe<String>;
  es_ES_lte?: Maybe<String>;
  es_ES_gt?: Maybe<String>;
  es_ES_gte?: Maybe<String>;
  es_ES_contains?: Maybe<String>;
  es_ES_not_contains?: Maybe<String>;
  es_ES_starts_with?: Maybe<String>;
  es_ES_not_starts_with?: Maybe<String>;
  es_ES_ends_with?: Maybe<String>;
  es_ES_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StockUnitCategoryWhereInput[] | StockUnitCategoryWhereInput>;
  OR?: Maybe<StockUnitCategoryWhereInput[] | StockUnitCategoryWhereInput>;
  NOT?: Maybe<StockUnitCategoryWhereInput[] | StockUnitCategoryWhereInput>;
}

export interface MeasurementUnitUpdateDataInput {
  symbol?: Maybe<MeasurementUnitSymbol>;
  name?: Maybe<MeasurementUnitName>;
}

export interface InventorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InventoryWhereInput>;
  AND?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
  OR?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
}

export interface MeasurementUnitUpdateOneRequiredInput {
  create?: Maybe<MeasurementUnitCreateInput>;
  update?: Maybe<MeasurementUnitUpdateDataInput>;
  upsert?: Maybe<MeasurementUnitUpsertNestedInput>;
  connect?: Maybe<MeasurementUnitWhereUniqueInput>;
}

export interface CostUnitByStockUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CostUnitByStockUnitWhereInput>;
  AND?: Maybe<
    | CostUnitByStockUnitSubscriptionWhereInput[]
    | CostUnitByStockUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CostUnitByStockUnitSubscriptionWhereInput[]
    | CostUnitByStockUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CostUnitByStockUnitSubscriptionWhereInput[]
    | CostUnitByStockUnitSubscriptionWhereInput
  >;
}

export type StockUnitByMenuItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CostUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  currency?: Maybe<CurrencyWhereInput>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CostUnitWhereInput[] | CostUnitWhereInput>;
  OR?: Maybe<CostUnitWhereInput[] | CostUnitWhereInput>;
  NOT?: Maybe<CostUnitWhereInput[] | CostUnitWhereInput>;
}

export interface InventoryByStockUnitUpdateInput {
  amount?: Maybe<String>;
  stockUnit?: Maybe<StockUnitUpdateOneRequiredInput>;
  unit?: Maybe<MeasurementUnitUpdateOneRequiredInput>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface CostUnitByLaborUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CostUnitByLaborUnitWhereInput>;
  AND?: Maybe<
    | CostUnitByLaborUnitSubscriptionWhereInput[]
    | CostUnitByLaborUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CostUnitByLaborUnitSubscriptionWhereInput[]
    | CostUnitByLaborUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CostUnitByLaborUnitSubscriptionWhereInput[]
    | CostUnitByLaborUnitSubscriptionWhereInput
  >;
}

export interface StockUnitByMenuItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  menuItem?: Maybe<MenuItemWhereInput>;
  stockUnit?: Maybe<StockUnitWhereInput>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  AND?: Maybe<StockUnitByMenuItemWhereInput[] | StockUnitByMenuItemWhereInput>;
  OR?: Maybe<StockUnitByMenuItemWhereInput[] | StockUnitByMenuItemWhereInput>;
  NOT?: Maybe<StockUnitByMenuItemWhereInput[] | StockUnitByMenuItemWhereInput>;
}

export type InventoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MeasurementUnitCreateInput {
  id?: Maybe<ID_Input>;
  symbol: MeasurementUnitSymbol;
  name: MeasurementUnitName;
}

export interface InventoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
  OR?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
  NOT?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
}

export interface MeasurementUnitCreateOneInput {
  create?: Maybe<MeasurementUnitCreateInput>;
  connect?: Maybe<MeasurementUnitWhereUniqueInput>;
}

export interface TableUpdateManyMutationInput {
  label?: Maybe<String>;
}

export interface InventoryByStockUnitCreateInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  stockUnit: StockUnitCreateOneInput;
  unit: MeasurementUnitCreateOneInput;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface SupplierUpsertNestedInput {
  update: SupplierUpdateDataInput;
  create: SupplierCreateInput;
}

export interface InventoryUpdateManyMutationInput {
  label?: Maybe<String>;
}

export interface SupplierUpdateOneRequiredInput {
  create?: Maybe<SupplierCreateInput>;
  update?: Maybe<SupplierUpdateDataInput>;
  upsert?: Maybe<SupplierUpsertNestedInput>;
  connect?: Maybe<SupplierWhereUniqueInput>;
}

export type StockUnitCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  en_EN?: Maybe<String>;
  es_ES?: Maybe<String>;
}>;

export interface SupplierCreateOneInput {
  create?: Maybe<SupplierCreateInput>;
  connect?: Maybe<SupplierWhereUniqueInput>;
}

export interface AddressWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  line1?: Maybe<String>;
  line1_not?: Maybe<String>;
  line1_in?: Maybe<String[] | String>;
  line1_not_in?: Maybe<String[] | String>;
  line1_lt?: Maybe<String>;
  line1_lte?: Maybe<String>;
  line1_gt?: Maybe<String>;
  line1_gte?: Maybe<String>;
  line1_contains?: Maybe<String>;
  line1_not_contains?: Maybe<String>;
  line1_starts_with?: Maybe<String>;
  line1_not_starts_with?: Maybe<String>;
  line1_ends_with?: Maybe<String>;
  line1_not_ends_with?: Maybe<String>;
  line2?: Maybe<String>;
  line2_not?: Maybe<String>;
  line2_in?: Maybe<String[] | String>;
  line2_not_in?: Maybe<String[] | String>;
  line2_lt?: Maybe<String>;
  line2_lte?: Maybe<String>;
  line2_gt?: Maybe<String>;
  line2_gte?: Maybe<String>;
  line2_contains?: Maybe<String>;
  line2_not_contains?: Maybe<String>;
  line2_starts_with?: Maybe<String>;
  line2_not_starts_with?: Maybe<String>;
  line2_ends_with?: Maybe<String>;
  line2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  region?: Maybe<String>;
  region_not?: Maybe<String>;
  region_in?: Maybe<String[] | String>;
  region_not_in?: Maybe<String[] | String>;
  region_lt?: Maybe<String>;
  region_lte?: Maybe<String>;
  region_gt?: Maybe<String>;
  region_gte?: Maybe<String>;
  region_contains?: Maybe<String>;
  region_not_contains?: Maybe<String>;
  region_starts_with?: Maybe<String>;
  region_not_starts_with?: Maybe<String>;
  region_ends_with?: Maybe<String>;
  region_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  zipCode?: Maybe<String>;
  zipCode_not?: Maybe<String>;
  zipCode_in?: Maybe<String[] | String>;
  zipCode_not_in?: Maybe<String[] | String>;
  zipCode_lt?: Maybe<String>;
  zipCode_lte?: Maybe<String>;
  zipCode_gt?: Maybe<String>;
  zipCode_gte?: Maybe<String>;
  zipCode_contains?: Maybe<String>;
  zipCode_not_contains?: Maybe<String>;
  zipCode_starts_with?: Maybe<String>;
  zipCode_not_starts_with?: Maybe<String>;
  zipCode_ends_with?: Maybe<String>;
  zipCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  OR?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  NOT?: Maybe<AddressWhereInput[] | AddressWhereInput>;
}

export interface InventoryByStockUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  stockUnit?: Maybe<StockUnitWhereInput>;
  unit?: Maybe<MeasurementUnitWhereInput>;
  expiresAt?: Maybe<DateTimeInput>;
  expiresAt_not?: Maybe<DateTimeInput>;
  expiresAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiresAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiresAt_lt?: Maybe<DateTimeInput>;
  expiresAt_lte?: Maybe<DateTimeInput>;
  expiresAt_gt?: Maybe<DateTimeInput>;
  expiresAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    InventoryByStockUnitWhereInput[] | InventoryByStockUnitWhereInput
  >;
  OR?: Maybe<InventoryByStockUnitWhereInput[] | InventoryByStockUnitWhereInput>;
  NOT?: Maybe<
    InventoryByStockUnitWhereInput[] | InventoryByStockUnitWhereInput
  >;
}

export interface InventoryUpdateInput {
  label?: Maybe<String>;
}

export interface SupplierByStockUnitCreateInput {
  id?: Maybe<ID_Input>;
  stockUnit: StockUnitCreateOneInput;
  supplier: SupplierCreateOneInput;
}

export interface InventoryCreateInput {
  id?: Maybe<ID_Input>;
  label: String;
}

export interface SupplierUpdateInput {
  name?: Maybe<String>;
  contact?: Maybe<ContactUpdateOneInput>;
  address?: Maybe<AddressUpdateOneInput>;
}

export interface CurrencyUpdateManyMutationInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export type LaborUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SupplierWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface StockUnitByMenuItemUpdateManyMutationInput {
  amount?: Maybe<String>;
}

export interface CurrencyUpdateInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export interface StockUnitByMenuItemCreateInput {
  id?: Maybe<ID_Input>;
  menuItem: MenuItemCreateOneInput;
  stockUnit: StockUnitCreateOneInput;
  amount?: Maybe<String>;
}

export interface StockUnitUpsertNestedInput {
  update: StockUnitUpdateDataInput;
  create: StockUnitCreateInput;
}

export interface StockUnitUpdateManyMutationInput {
  name?: Maybe<String>;
  sku?: Maybe<String>;
}

export interface StockUnitCategoryUpsertNestedInput {
  update: StockUnitCategoryUpdateDataInput;
  create: StockUnitCategoryCreateInput;
}

export interface PriceUpdateManyMutationInput {
  amount?: Maybe<String>;
  label?: Maybe<String>;
}

export type SupplierByStockUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MenuWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  label?: Maybe<String>;
}>;

export interface StockUnitCategoryUpdateDataInput {
  en_EN?: Maybe<String>;
  es_ES?: Maybe<String>;
}

export interface MenuWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MenuWhereInput[] | MenuWhereInput>;
  OR?: Maybe<MenuWhereInput[] | MenuWhereInput>;
  NOT?: Maybe<MenuWhereInput[] | MenuWhereInput>;
}

export interface SupplierByStockUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  stockUnit?: Maybe<StockUnitWhereInput>;
  supplier?: Maybe<SupplierWhereInput>;
  AND?: Maybe<SupplierByStockUnitWhereInput[] | SupplierByStockUnitWhereInput>;
  OR?: Maybe<SupplierByStockUnitWhereInput[] | SupplierByStockUnitWhereInput>;
  NOT?: Maybe<SupplierByStockUnitWhereInput[] | SupplierByStockUnitWhereInput>;
}

export interface OrderUpdateManyMutationInput {
  amount?: Maybe<String>;
  orderedAt?: Maybe<DateTimeInput>;
  paidAt?: Maybe<DateTimeInput>;
}

export interface StockUnitCategoryUpdateOneInput {
  create?: Maybe<StockUnitCategoryCreateInput>;
  update?: Maybe<StockUnitCategoryUpdateDataInput>;
  upsert?: Maybe<StockUnitCategoryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StockUnitCategoryWhereUniqueInput>;
}

export interface MenuItemCategoryUpdateManyMutationInput {
  name?: Maybe<MenuItemCategoryName>;
}

export interface SupplierUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface MenuItemCategoryUpdateInput {
  name?: Maybe<MenuItemCategoryName>;
}

export interface SupplierUpdateManyWithWhereNestedInput {
  where: SupplierScalarWhereInput;
  data: SupplierUpdateManyDataInput;
}

export interface TableUpsertNestedInput {
  update: TableUpdateDataInput;
  create: TableCreateInput;
}

export interface SupplierScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SupplierScalarWhereInput[] | SupplierScalarWhereInput>;
  OR?: Maybe<SupplierScalarWhereInput[] | SupplierScalarWhereInput>;
  NOT?: Maybe<SupplierScalarWhereInput[] | SupplierScalarWhereInput>;
}

export type MenuItemByMenuWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TableWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MenuItemByMenuWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  menu?: Maybe<MenuWhereInput>;
  menuItem?: Maybe<MenuItemWhereInput>;
  AND?: Maybe<MenuItemByMenuWhereInput[] | MenuItemByMenuWhereInput>;
  OR?: Maybe<MenuItemByMenuWhereInput[] | MenuItemByMenuWhereInput>;
  NOT?: Maybe<MenuItemByMenuWhereInput[] | MenuItemByMenuWhereInput>;
}

export interface SupplierUpsertWithWhereUniqueNestedInput {
  where: SupplierWhereUniqueInput;
  update: SupplierUpdateDataInput;
  create: SupplierCreateInput;
}

export interface OrderUpdateDataInput {
  table?: Maybe<TableUpdateOneRequiredInput>;
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
  orderedAt?: Maybe<DateTimeInput>;
  paidAt?: Maybe<DateTimeInput>;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface MenuItemByOrderUpdateInput {
  order?: Maybe<OrderUpdateOneRequiredInput>;
  menuItem?: Maybe<MenuItemUpdateOneRequiredInput>;
}

export interface AddressUpdateDataInput {
  line1?: Maybe<String>;
  line2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  country?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export interface TableCreateInput {
  id?: Maybe<ID_Input>;
  label: String;
}

export interface AddressUpdateOneInput {
  create?: Maybe<AddressCreateInput>;
  update?: Maybe<AddressUpdateDataInput>;
  upsert?: Maybe<AddressUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface OrderCreateInput {
  id?: Maybe<ID_Input>;
  table: TableCreateOneInput;
  amount?: Maybe<String>;
  currency: CurrencyCreateOneInput;
  orderedAt: DateTimeInput;
  paidAt?: Maybe<DateTimeInput>;
}

export interface OrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  table?: Maybe<TableWhereInput>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  currency?: Maybe<CurrencyWhereInput>;
  orderedAt?: Maybe<DateTimeInput>;
  orderedAt_not?: Maybe<DateTimeInput>;
  orderedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  orderedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  orderedAt_lt?: Maybe<DateTimeInput>;
  orderedAt_lte?: Maybe<DateTimeInput>;
  orderedAt_gt?: Maybe<DateTimeInput>;
  orderedAt_gte?: Maybe<DateTimeInput>;
  paidAt?: Maybe<DateTimeInput>;
  paidAt_not?: Maybe<DateTimeInput>;
  paidAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  paidAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  paidAt_lt?: Maybe<DateTimeInput>;
  paidAt_lte?: Maybe<DateTimeInput>;
  paidAt_gt?: Maybe<DateTimeInput>;
  paidAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export interface OrderCreateOneInput {
  create?: Maybe<OrderCreateInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface AddressCreateInput {
  id?: Maybe<ID_Input>;
  line1?: Maybe<String>;
  line2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  country?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export interface MenuUpsertNestedInput {
  update: MenuUpdateDataInput;
  create: MenuCreateInput;
}

export interface AddressUpdateInput {
  line1?: Maybe<String>;
  line2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  country?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export type MenuItemCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<MenuItemCategoryName>;
}>;

export interface AddressUpdateManyMutationInput {
  line1?: Maybe<String>;
  line2?: Maybe<String>;
  city?: Maybe<String>;
  region?: Maybe<String>;
  country?: Maybe<String>;
  zipCode?: Maybe<String>;
}

export interface MenuItemByMenuUpdateInput {
  menu?: Maybe<MenuUpdateOneRequiredInput>;
  menuItem?: Maybe<MenuItemUpdateOneRequiredInput>;
}

export interface ContactUpsertNestedInput {
  update: ContactUpdateDataInput;
  create: ContactCreateInput;
}

export interface CostUnitByLaborUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  laborUnit?: Maybe<LaborUnitWhereInput>;
  costUnit?: Maybe<CostUnitWhereInput>;
  AND?: Maybe<CostUnitByLaborUnitWhereInput[] | CostUnitByLaborUnitWhereInput>;
  OR?: Maybe<CostUnitByLaborUnitWhereInput[] | CostUnitByLaborUnitWhereInput>;
  NOT?: Maybe<CostUnitByLaborUnitWhereInput[] | CostUnitByLaborUnitWhereInput>;
}

export interface ContactUpdateDataInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
}

export interface SupplierByStockUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SupplierByStockUnitWhereInput>;
  AND?: Maybe<
    | SupplierByStockUnitSubscriptionWhereInput[]
    | SupplierByStockUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    | SupplierByStockUnitSubscriptionWhereInput[]
    | SupplierByStockUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | SupplierByStockUnitSubscriptionWhereInput[]
    | SupplierByStockUnitSubscriptionWhereInput
  >;
}

export interface ContactCreateInput {
  id?: Maybe<ID_Input>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
}

export interface StockUnitByMenuItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StockUnitByMenuItemWhereInput>;
  AND?: Maybe<
    | StockUnitByMenuItemSubscriptionWhereInput[]
    | StockUnitByMenuItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    | StockUnitByMenuItemSubscriptionWhereInput[]
    | StockUnitByMenuItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | StockUnitByMenuItemSubscriptionWhereInput[]
    | StockUnitByMenuItemSubscriptionWhereInput
  >;
}

export interface ContactUpdateInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
}

export interface MenuItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  category?: Maybe<MenuItemCategoryWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MenuItemWhereInput[] | MenuItemWhereInput>;
  OR?: Maybe<MenuItemWhereInput[] | MenuItemWhereInput>;
  NOT?: Maybe<MenuItemWhereInput[] | MenuItemWhereInput>;
}

export interface ContactUpdateManyMutationInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  phoneNumber?: Maybe<String>;
}

export interface MenuItemByOrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MenuItemByOrderWhereInput>;
  AND?: Maybe<
    | MenuItemByOrderSubscriptionWhereInput[]
    | MenuItemByOrderSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MenuItemByOrderSubscriptionWhereInput[]
    | MenuItemByOrderSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MenuItemByOrderSubscriptionWhereInput[]
    | MenuItemByOrderSubscriptionWhereInput
  >;
}

export interface CostUnitCreateInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  currency: CurrencyCreateOneInput;
  label?: Maybe<String>;
}

export interface MenuSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MenuWhereInput>;
  AND?: Maybe<MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput>;
  OR?: Maybe<MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput>;
  NOT?: Maybe<MenuSubscriptionWhereInput[] | MenuSubscriptionWhereInput>;
}

export interface CurrencyCreateOneInput {
  create?: Maybe<CurrencyCreateInput>;
  connect?: Maybe<CurrencyWhereUniqueInput>;
}

export interface InventoryByStockUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InventoryByStockUnitWhereInput>;
  AND?: Maybe<
    | InventoryByStockUnitSubscriptionWhereInput[]
    | InventoryByStockUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    | InventoryByStockUnitSubscriptionWhereInput[]
    | InventoryByStockUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | InventoryByStockUnitSubscriptionWhereInput[]
    | InventoryByStockUnitSubscriptionWhereInput
  >;
}

export interface CurrencyCreateInput {
  id?: Maybe<ID_Input>;
  symbol: String;
  isDefault?: Maybe<Boolean>;
}

export interface CurrencyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  symbol?: Maybe<String>;
  symbol_not?: Maybe<String>;
  symbol_in?: Maybe<String[] | String>;
  symbol_not_in?: Maybe<String[] | String>;
  symbol_lt?: Maybe<String>;
  symbol_lte?: Maybe<String>;
  symbol_gt?: Maybe<String>;
  symbol_gte?: Maybe<String>;
  symbol_contains?: Maybe<String>;
  symbol_not_contains?: Maybe<String>;
  symbol_starts_with?: Maybe<String>;
  symbol_not_starts_with?: Maybe<String>;
  symbol_ends_with?: Maybe<String>;
  symbol_not_ends_with?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
  isDefault_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
  OR?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
  NOT?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
}

export interface CostUnitUpdateInput {
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
  label?: Maybe<String>;
}

export type CurrencyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CurrencyUpdateOneRequiredInput {
  create?: Maybe<CurrencyCreateInput>;
  update?: Maybe<CurrencyUpdateDataInput>;
  upsert?: Maybe<CurrencyUpsertNestedInput>;
  connect?: Maybe<CurrencyWhereUniqueInput>;
}

export interface CostUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CostUnitWhereInput>;
  AND?: Maybe<
    CostUnitSubscriptionWhereInput[] | CostUnitSubscriptionWhereInput
  >;
  OR?: Maybe<CostUnitSubscriptionWhereInput[] | CostUnitSubscriptionWhereInput>;
  NOT?: Maybe<
    CostUnitSubscriptionWhereInput[] | CostUnitSubscriptionWhereInput
  >;
}

export interface ContactUpdateOneInput {
  create?: Maybe<ContactCreateInput>;
  update?: Maybe<ContactUpdateDataInput>;
  upsert?: Maybe<ContactUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AddressWhereInput>;
  AND?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  OR?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  NOT?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
}

export interface CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput;
  create: CurrencyCreateInput;
}

export type InventoryByStockUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CostUnitUpdateManyMutationInput {
  amount?: Maybe<String>;
  label?: Maybe<String>;
}

export type CostUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CostUnitByLaborUnitCreateInput {
  id?: Maybe<ID_Input>;
  laborUnit: LaborUnitCreateOneInput;
  costUnit: CostUnitCreateOneInput;
}

export interface SupplierUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface LaborUnitCreateOneInput {
  create?: Maybe<LaborUnitCreateInput>;
  connect?: Maybe<LaborUnitWhereUniqueInput>;
}

export interface StockUnitCategoryUpdateInput {
  en_EN?: Maybe<String>;
  es_ES?: Maybe<String>;
}

export interface LaborUnitCreateInput {
  id?: Maybe<ID_Input>;
  label: String;
}

export type MeasurementUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CostUnitCreateOneInput {
  create?: Maybe<CostUnitCreateInput>;
  connect?: Maybe<CostUnitWhereUniqueInput>;
}

export interface PriceUpdateInput {
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
  label?: Maybe<String>;
}

export interface CostUnitByLaborUnitUpdateInput {
  laborUnit?: Maybe<LaborUnitUpdateOneRequiredInput>;
  costUnit?: Maybe<CostUnitUpdateOneRequiredInput>;
}

export interface ContactWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  OR?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  NOT?: Maybe<ContactWhereInput[] | ContactWhereInput>;
}

export interface LaborUnitUpdateOneRequiredInput {
  create?: Maybe<LaborUnitCreateInput>;
  update?: Maybe<LaborUnitUpdateDataInput>;
  upsert?: Maybe<LaborUnitUpsertNestedInput>;
  connect?: Maybe<LaborUnitWhereUniqueInput>;
}

export type MenuItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface LaborUnitUpdateDataInput {
  label?: Maybe<String>;
}

export interface TableUpdateDataInput {
  label?: Maybe<String>;
}

export interface LaborUnitUpsertNestedInput {
  update: LaborUnitUpdateDataInput;
  create: LaborUnitCreateInput;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface CostUnitUpdateOneRequiredInput {
  create?: Maybe<CostUnitCreateInput>;
  update?: Maybe<CostUnitUpdateDataInput>;
  upsert?: Maybe<CostUnitUpsertNestedInput>;
  connect?: Maybe<CostUnitWhereUniqueInput>;
}

export type MenuItemByOrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CostUnitUpdateDataInput {
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
  label?: Maybe<String>;
}

export interface MenuItemByOrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<OrderWhereInput>;
  menuItem?: Maybe<MenuItemWhereInput>;
  AND?: Maybe<MenuItemByOrderWhereInput[] | MenuItemByOrderWhereInput>;
  OR?: Maybe<MenuItemByOrderWhereInput[] | MenuItemByOrderWhereInput>;
  NOT?: Maybe<MenuItemByOrderWhereInput[] | MenuItemByOrderWhereInput>;
}

export interface CostUnitUpsertNestedInput {
  update: CostUnitUpdateDataInput;
  create: CostUnitCreateInput;
}

export interface MenuItemByOrderCreateInput {
  id?: Maybe<ID_Input>;
  order: OrderCreateOneInput;
  menuItem: MenuItemCreateOneInput;
}

export interface CostUnitByMenuItemCreateInput {
  id?: Maybe<ID_Input>;
  menuItem: MenuItemCreateOneInput;
  costUnit: CostUnitCreateOneInput;
}

export interface MenuUpdateOneRequiredInput {
  create?: Maybe<MenuCreateInput>;
  update?: Maybe<MenuUpdateDataInput>;
  upsert?: Maybe<MenuUpsertNestedInput>;
  connect?: Maybe<MenuWhereUniqueInput>;
}

export interface SupplierUpdateDataInput {
  name?: Maybe<String>;
  contact?: Maybe<ContactUpdateOneInput>;
  address?: Maybe<AddressUpdateOneInput>;
}

export type CostUnitByLaborUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MenuItemCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  category: MenuItemCategoryCreateOneInput;
}

export interface PriceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PriceWhereInput>;
  AND?: Maybe<PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput>;
  OR?: Maybe<PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput>;
  NOT?: Maybe<PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput>;
}

export interface MenuItemCategoryCreateOneInput {
  create?: Maybe<MenuItemCategoryCreateInput>;
  connect?: Maybe<MenuItemCategoryWhereUniqueInput>;
}

export type CostUnitByStockUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MenuItemCategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: MenuItemCategoryName;
}

export interface StockUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  supplier_every?: Maybe<SupplierWhereInput>;
  supplier_some?: Maybe<SupplierWhereInput>;
  supplier_none?: Maybe<SupplierWhereInput>;
  stockUnitCategory?: Maybe<StockUnitCategoryWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StockUnitWhereInput[] | StockUnitWhereInput>;
  OR?: Maybe<StockUnitWhereInput[] | StockUnitWhereInput>;
  NOT?: Maybe<StockUnitWhereInput[] | StockUnitWhereInput>;
}

export interface CostUnitByMenuItemUpdateInput {
  menuItem?: Maybe<MenuItemUpdateOneRequiredInput>;
  costUnit?: Maybe<CostUnitUpdateOneRequiredInput>;
}

export interface CostUnitByMenuItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CostUnitByMenuItemWhereInput>;
  AND?: Maybe<
    | CostUnitByMenuItemSubscriptionWhereInput[]
    | CostUnitByMenuItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CostUnitByMenuItemSubscriptionWhereInput[]
    | CostUnitByMenuItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CostUnitByMenuItemSubscriptionWhereInput[]
    | CostUnitByMenuItemSubscriptionWhereInput
  >;
}

export interface MenuItemUpdateOneRequiredInput {
  create?: Maybe<MenuItemCreateInput>;
  update?: Maybe<MenuItemUpdateDataInput>;
  upsert?: Maybe<MenuItemUpsertNestedInput>;
  connect?: Maybe<MenuItemWhereUniqueInput>;
}

export interface TableUpdateInput {
  label?: Maybe<String>;
}

export interface MenuItemUpdateDataInput {
  name?: Maybe<String>;
  category?: Maybe<MenuItemCategoryUpdateOneRequiredInput>;
}

export interface MeasurementUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  symbol?: Maybe<MeasurementUnitSymbol>;
  symbol_not?: Maybe<MeasurementUnitSymbol>;
  symbol_in?: Maybe<MeasurementUnitSymbol[] | MeasurementUnitSymbol>;
  symbol_not_in?: Maybe<MeasurementUnitSymbol[] | MeasurementUnitSymbol>;
  name?: Maybe<MeasurementUnitName>;
  name_not?: Maybe<MeasurementUnitName>;
  name_in?: Maybe<MeasurementUnitName[] | MeasurementUnitName>;
  name_not_in?: Maybe<MeasurementUnitName[] | MeasurementUnitName>;
  AND?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
  OR?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
  NOT?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
}

export interface MenuItemCategoryUpdateOneRequiredInput {
  create?: Maybe<MenuItemCategoryCreateInput>;
  update?: Maybe<MenuItemCategoryUpdateDataInput>;
  upsert?: Maybe<MenuItemCategoryUpsertNestedInput>;
  connect?: Maybe<MenuItemCategoryWhereUniqueInput>;
}

export interface StockUnitByMenuItemUpdateInput {
  menuItem?: Maybe<MenuItemUpdateOneRequiredInput>;
  stockUnit?: Maybe<StockUnitUpdateOneRequiredInput>;
  amount?: Maybe<String>;
}

export interface MenuItemCategoryUpdateDataInput {
  name?: Maybe<MenuItemCategoryName>;
}

export interface PriceCreateInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  currency: CurrencyCreateOneInput;
  label?: Maybe<String>;
}

export interface MenuItemCategoryUpsertNestedInput {
  update: MenuItemCategoryUpdateDataInput;
  create: MenuItemCategoryCreateInput;
}

export interface OrderUpsertNestedInput {
  update: OrderUpdateDataInput;
  create: OrderCreateInput;
}

export interface MenuItemUpsertNestedInput {
  update: MenuItemUpdateDataInput;
  create: MenuItemCreateInput;
}

export interface OrderUpdateOneRequiredInput {
  create?: Maybe<OrderCreateInput>;
  update?: Maybe<OrderUpdateDataInput>;
  upsert?: Maybe<OrderUpsertNestedInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface CostUnitByStockUnitCreateInput {
  id?: Maybe<ID_Input>;
  stockUnit: StockUnitCreateOneInput;
  costUnit: CostUnitCreateOneInput;
}

export interface TableWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TableWhereInput[] | TableWhereInput>;
  OR?: Maybe<TableWhereInput[] | TableWhereInput>;
  NOT?: Maybe<TableWhereInput[] | TableWhereInput>;
}

export interface StockUnitCreateOneInput {
  create?: Maybe<StockUnitCreateInput>;
  connect?: Maybe<StockUnitWhereUniqueInput>;
}

export interface MenuCreateOneInput {
  create?: Maybe<MenuCreateInput>;
  connect?: Maybe<MenuWhereUniqueInput>;
}

export interface StockUnitCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  sku?: Maybe<String>;
  supplier?: Maybe<SupplierCreateManyInput>;
  stockUnitCategory?: Maybe<StockUnitCategoryCreateOneInput>;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface SupplierCreateManyInput {
  create?: Maybe<SupplierCreateInput[] | SupplierCreateInput>;
  connect?: Maybe<SupplierWhereUniqueInput[] | SupplierWhereUniqueInput>;
}

export interface CurrencySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CurrencyWhereInput>;
  AND?: Maybe<
    CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput
  >;
  OR?: Maybe<CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput>;
  NOT?: Maybe<
    CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput
  >;
}

export interface SupplierCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  contact?: Maybe<ContactCreateOneInput>;
  address?: Maybe<AddressCreateOneInput>;
}

export interface SupplierByStockUnitUpdateInput {
  stockUnit?: Maybe<StockUnitUpdateOneRequiredInput>;
  supplier?: Maybe<SupplierUpdateOneRequiredInput>;
}

export interface ContactCreateOneInput {
  create?: Maybe<ContactCreateInput>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface StockUnitUpdateInput {
  name?: Maybe<String>;
  sku?: Maybe<String>;
  supplier?: Maybe<SupplierUpdateManyInput>;
  stockUnitCategory?: Maybe<StockUnitCategoryUpdateOneInput>;
}

export interface AddressCreateOneInput {
  create?: Maybe<AddressCreateInput>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface TableUpdateOneRequiredInput {
  create?: Maybe<TableCreateInput>;
  update?: Maybe<TableUpdateDataInput>;
  upsert?: Maybe<TableUpsertNestedInput>;
  connect?: Maybe<TableWhereUniqueInput>;
}

export interface StockUnitCategoryCreateOneInput {
  create?: Maybe<StockUnitCategoryCreateInput>;
  connect?: Maybe<StockUnitCategoryWhereUniqueInput>;
}

export interface MenuUpdateDataInput {
  label?: Maybe<String>;
}

export interface StockUnitCategoryCreateInput {
  id?: Maybe<ID_Input>;
  en_EN: String;
  es_ES: String;
}

export interface MeasurementUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MeasurementUnitWhereInput>;
  AND?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
}

export interface SupplierUpdateManyInput {
  create?: Maybe<SupplierCreateInput[] | SupplierCreateInput>;
  update?: Maybe<
    | SupplierUpdateWithWhereUniqueNestedInput[]
    | SupplierUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SupplierUpsertWithWhereUniqueNestedInput[]
    | SupplierUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<SupplierWhereUniqueInput[] | SupplierWhereUniqueInput>;
  connect?: Maybe<SupplierWhereUniqueInput[] | SupplierWhereUniqueInput>;
  set?: Maybe<SupplierWhereUniqueInput[] | SupplierWhereUniqueInput>;
  disconnect?: Maybe<SupplierWhereUniqueInput[] | SupplierWhereUniqueInput>;
  deleteMany?: Maybe<SupplierScalarWhereInput[] | SupplierScalarWhereInput>;
  updateMany?: Maybe<
    | SupplierUpdateManyWithWhereNestedInput[]
    | SupplierUpdateManyWithWhereNestedInput
  >;
}

export interface StockUnitUpdateDataInput {
  name?: Maybe<String>;
  sku?: Maybe<String>;
  supplier?: Maybe<SupplierUpdateManyInput>;
  stockUnitCategory?: Maybe<StockUnitCategoryUpdateOneInput>;
}

export interface StockUnitUpdateOneRequiredInput {
  create?: Maybe<StockUnitCreateInput>;
  update?: Maybe<StockUnitUpdateDataInput>;
  upsert?: Maybe<StockUnitUpsertNestedInput>;
  connect?: Maybe<StockUnitWhereUniqueInput>;
}

export interface CostUnitByStockUnitUpdateInput {
  stockUnit?: Maybe<StockUnitUpdateOneRequiredInput>;
  costUnit?: Maybe<CostUnitUpdateOneRequiredInput>;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactWhereInput>;
  AND?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  OR?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  NOT?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
}

export type CostUnitByMenuItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TableCreateOneInput {
  create?: Maybe<TableCreateInput>;
  connect?: Maybe<TableWhereUniqueInput>;
}

export interface OrderUpdateInput {
  table?: Maybe<TableUpdateOneRequiredInput>;
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
  orderedAt?: Maybe<DateTimeInput>;
  paidAt?: Maybe<DateTimeInput>;
}

export interface StockUnitCategoryUpdateManyMutationInput {
  en_EN?: Maybe<String>;
  es_ES?: Maybe<String>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface TablePreviousValues {
  id: ID_Output;
  label: String;
  createdAt: DateTimeOutput;
}

export interface TablePreviousValuesPromise
  extends Promise<TablePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface TablePreviousValuesSubscription
  extends Promise<AsyncIterator<TablePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateInventory {
  count: Int;
}

export interface AggregateInventoryPromise
  extends Promise<AggregateInventory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventorySubscription
  extends Promise<AsyncIterator<AggregateInventory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CostUnitByLaborUnit {
  id: ID_Output;
}

export interface CostUnitByLaborUnitPromise
  extends Promise<CostUnitByLaborUnit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  laborUnit: <T = LaborUnitPromise>() => T;
  costUnit: <T = CostUnitPromise>() => T;
}

export interface CostUnitByLaborUnitSubscription
  extends Promise<AsyncIterator<CostUnitByLaborUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  laborUnit: <T = LaborUnitSubscription>() => T;
  costUnit: <T = CostUnitSubscription>() => T;
}

export interface CostUnitByLaborUnitNullablePromise
  extends Promise<CostUnitByLaborUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  laborUnit: <T = LaborUnitPromise>() => T;
  costUnit: <T = CostUnitPromise>() => T;
}

export interface InventoryEdge {
  node: Inventory;
  cursor: String;
}

export interface InventoryEdgePromise
  extends Promise<InventoryEdge>,
    Fragmentable {
  node: <T = InventoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryEdgeSubscription
  extends Promise<AsyncIterator<InventoryEdge>>,
    Fragmentable {
  node: <T = InventorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LaborUnit {
  id: ID_Output;
  label: String;
  createdAt: DateTimeOutput;
}

export interface LaborUnitPromise extends Promise<LaborUnit>, Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface LaborUnitSubscription
  extends Promise<AsyncIterator<LaborUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LaborUnitNullablePromise
  extends Promise<LaborUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface InventoryConnection {
  pageInfo: PageInfo;
  edges: InventoryEdge[];
}

export interface InventoryConnectionPromise
  extends Promise<InventoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryEdge>>() => T;
  aggregate: <T = AggregateInventoryPromise>() => T;
}

export interface InventoryConnectionSubscription
  extends Promise<AsyncIterator<InventoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventorySubscription>() => T;
}

export interface AggregateTable {
  count: Int;
}

export interface AggregateTablePromise
  extends Promise<AggregateTable>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTableSubscription
  extends Promise<AsyncIterator<AggregateTable>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Currency {
  id: ID_Output;
  symbol: String;
  isDefault?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CurrencyPromise extends Promise<Currency>, Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CurrencySubscription
  extends Promise<AsyncIterator<Currency>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<String>>;
  isDefault: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CurrencyNullablePromise
  extends Promise<Currency | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface TableConnection {
  pageInfo: PageInfo;
  edges: TableEdge[];
}

export interface TableConnectionPromise
  extends Promise<TableConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TableEdge>>() => T;
  aggregate: <T = AggregateTablePromise>() => T;
}

export interface TableConnectionSubscription
  extends Promise<AsyncIterator<TableConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TableEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTableSubscription>() => T;
}

export interface Address {
  id: ID_Output;
  line1?: String;
  line2?: String;
  city?: String;
  region?: String;
  country?: String;
  zipCode?: String;
  createdAt: DateTimeOutput;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  line1: () => Promise<String>;
  line2: () => Promise<String>;
  city: () => Promise<String>;
  region: () => Promise<String>;
  country: () => Promise<String>;
  zipCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  line1: () => Promise<AsyncIterator<String>>;
  line2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AddressNullablePromise
  extends Promise<Address | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  line1: () => Promise<String>;
  line2: () => Promise<String>;
  city: () => Promise<String>;
  region: () => Promise<String>;
  country: () => Promise<String>;
  zipCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AggregateSupplierByStockUnit {
  count: Int;
}

export interface AggregateSupplierByStockUnitPromise
  extends Promise<AggregateSupplierByStockUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSupplierByStockUnitSubscription
  extends Promise<AsyncIterator<AggregateSupplierByStockUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface SupplierByStockUnitConnection {
  pageInfo: PageInfo;
  edges: SupplierByStockUnitEdge[];
}

export interface SupplierByStockUnitConnectionPromise
  extends Promise<SupplierByStockUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SupplierByStockUnitEdge>>() => T;
  aggregate: <T = AggregateSupplierByStockUnitPromise>() => T;
}

export interface SupplierByStockUnitConnectionSubscription
  extends Promise<AsyncIterator<SupplierByStockUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SupplierByStockUnitEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSupplierByStockUnitSubscription>() => T;
}

export interface AddressPreviousValues {
  id: ID_Output;
  line1?: String;
  line2?: String;
  city?: String;
  region?: String;
  country?: String;
  zipCode?: String;
  createdAt: DateTimeOutput;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  line1: () => Promise<String>;
  line2: () => Promise<String>;
  city: () => Promise<String>;
  region: () => Promise<String>;
  country: () => Promise<String>;
  zipCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  line1: () => Promise<AsyncIterator<String>>;
  line2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SupplierByStockUnit {
  id: ID_Output;
}

export interface SupplierByStockUnitPromise
  extends Promise<SupplierByStockUnit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  stockUnit: <T = StockUnitPromise>() => T;
  supplier: <T = SupplierPromise>() => T;
}

export interface SupplierByStockUnitSubscription
  extends Promise<AsyncIterator<SupplierByStockUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stockUnit: <T = StockUnitSubscription>() => T;
  supplier: <T = SupplierSubscription>() => T;
}

export interface SupplierByStockUnitNullablePromise
  extends Promise<SupplierByStockUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  stockUnit: <T = StockUnitPromise>() => T;
  supplier: <T = SupplierPromise>() => T;
}

export interface Inventory {
  id: ID_Output;
  label: String;
  createdAt: DateTimeOutput;
}

export interface InventoryPromise extends Promise<Inventory>, Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface InventorySubscription
  extends Promise<AsyncIterator<Inventory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryNullablePromise
  extends Promise<Inventory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface SupplierEdge {
  node: Supplier;
  cursor: String;
}

export interface SupplierEdgePromise
  extends Promise<SupplierEdge>,
    Fragmentable {
  node: <T = SupplierPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SupplierEdgeSubscription
  extends Promise<AsyncIterator<SupplierEdge>>,
    Fragmentable {
  node: <T = SupplierSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface AggregateStockUnitCategory {
  count: Int;
}

export interface AggregateStockUnitCategoryPromise
  extends Promise<AggregateStockUnitCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStockUnitCategorySubscription
  extends Promise<AsyncIterator<AggregateStockUnitCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactPreviousValues {
  id: ID_Output;
  email?: String;
  firstName?: String;
  lastName?: String;
  phoneNumber?: String;
  createdAt: DateTimeOutput;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StockUnitCategoryConnection {
  pageInfo: PageInfo;
  edges: StockUnitCategoryEdge[];
}

export interface StockUnitCategoryConnectionPromise
  extends Promise<StockUnitCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StockUnitCategoryEdge>>() => T;
  aggregate: <T = AggregateStockUnitCategoryPromise>() => T;
}

export interface StockUnitCategoryConnectionSubscription
  extends Promise<AsyncIterator<StockUnitCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StockUnitCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStockUnitCategorySubscription>() => T;
}

export interface AggregateCurrency {
  count: Int;
}

export interface AggregateCurrencyPromise
  extends Promise<AggregateCurrency>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCurrencySubscription
  extends Promise<AsyncIterator<AggregateCurrency>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StockUnitByMenuItemEdge {
  node: StockUnitByMenuItem;
  cursor: String;
}

export interface StockUnitByMenuItemEdgePromise
  extends Promise<StockUnitByMenuItemEdge>,
    Fragmentable {
  node: <T = StockUnitByMenuItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StockUnitByMenuItemEdgeSubscription
  extends Promise<AsyncIterator<StockUnitByMenuItemEdge>>,
    Fragmentable {
  node: <T = StockUnitByMenuItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStockUnitByMenuItem {
  count: Int;
}

export interface AggregateStockUnitByMenuItemPromise
  extends Promise<AggregateStockUnitByMenuItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStockUnitByMenuItemSubscription
  extends Promise<AsyncIterator<AggregateStockUnitByMenuItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CostUnitByLaborUnitEdge {
  node: CostUnitByLaborUnit;
  cursor: String;
}

export interface CostUnitByLaborUnitEdgePromise
  extends Promise<CostUnitByLaborUnitEdge>,
    Fragmentable {
  node: <T = CostUnitByLaborUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CostUnitByLaborUnitEdgeSubscription
  extends Promise<AsyncIterator<CostUnitByLaborUnitEdge>>,
    Fragmentable {
  node: <T = CostUnitByLaborUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StockUnitByMenuItemConnection {
  pageInfo: PageInfo;
  edges: StockUnitByMenuItemEdge[];
}

export interface StockUnitByMenuItemConnectionPromise
  extends Promise<StockUnitByMenuItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StockUnitByMenuItemEdge>>() => T;
  aggregate: <T = AggregateStockUnitByMenuItemPromise>() => T;
}

export interface StockUnitByMenuItemConnectionSubscription
  extends Promise<AsyncIterator<StockUnitByMenuItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<StockUnitByMenuItemEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateStockUnitByMenuItemSubscription>() => T;
}

export interface CostUnitSubscriptionPayload {
  mutation: MutationType;
  node: CostUnit;
  updatedFields: String[];
  previousValues: CostUnitPreviousValues;
}

export interface CostUnitSubscriptionPayloadPromise
  extends Promise<CostUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CostUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CostUnitPreviousValuesPromise>() => T;
}

export interface CostUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CostUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CostUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CostUnitPreviousValuesSubscription>() => T;
}

export interface StockUnitByMenuItem {
  id: ID_Output;
  amount: String;
}

export interface StockUnitByMenuItemPromise
  extends Promise<StockUnitByMenuItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  menuItem: <T = MenuItemPromise>() => T;
  stockUnit: <T = StockUnitPromise>() => T;
  amount: () => Promise<String>;
}

export interface StockUnitByMenuItemSubscription
  extends Promise<AsyncIterator<StockUnitByMenuItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  menuItem: <T = MenuItemSubscription>() => T;
  stockUnit: <T = StockUnitSubscription>() => T;
  amount: () => Promise<AsyncIterator<String>>;
}

export interface StockUnitByMenuItemNullablePromise
  extends Promise<StockUnitByMenuItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  menuItem: <T = MenuItemPromise>() => T;
  stockUnit: <T = StockUnitPromise>() => T;
  amount: () => Promise<String>;
}

export interface StockUnitEdge {
  node: StockUnit;
  cursor: String;
}

export interface StockUnitEdgePromise
  extends Promise<StockUnitEdge>,
    Fragmentable {
  node: <T = StockUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StockUnitEdgeSubscription
  extends Promise<AsyncIterator<StockUnitEdge>>,
    Fragmentable {
  node: <T = StockUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CostUnitPreviousValues {
  id: ID_Output;
  amount: String;
  label?: String;
  createdAt: DateTimeOutput;
}

export interface CostUnitPreviousValuesPromise
  extends Promise<CostUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CostUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<CostUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface CurrencyEdge {
  node: Currency;
  cursor: String;
}

export interface CurrencyEdgePromise
  extends Promise<CurrencyEdge>,
    Fragmentable {
  node: <T = CurrencyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CurrencyEdgeSubscription
  extends Promise<AsyncIterator<CurrencyEdge>>,
    Fragmentable {
  node: <T = CurrencySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PriceEdge {
  node: Price;
  cursor: String;
}

export interface PriceEdgePromise extends Promise<PriceEdge>, Fragmentable {
  node: <T = PricePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PriceEdgeSubscription
  extends Promise<AsyncIterator<PriceEdge>>,
    Fragmentable {
  node: <T = PriceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CostUnitByLaborUnitSubscriptionPayload {
  mutation: MutationType;
  node: CostUnitByLaborUnit;
  updatedFields: String[];
  previousValues: CostUnitByLaborUnitPreviousValues;
}

export interface CostUnitByLaborUnitSubscriptionPayloadPromise
  extends Promise<CostUnitByLaborUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CostUnitByLaborUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CostUnitByLaborUnitPreviousValuesPromise>() => T;
}

export interface CostUnitByLaborUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CostUnitByLaborUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CostUnitByLaborUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CostUnitByLaborUnitPreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CostUnitByLaborUnitPreviousValues {
  id: ID_Output;
}

export interface CostUnitByLaborUnitPreviousValuesPromise
  extends Promise<CostUnitByLaborUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CostUnitByLaborUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<CostUnitByLaborUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CurrencyConnection {
  pageInfo: PageInfo;
  edges: CurrencyEdge[];
}

export interface CurrencyConnectionPromise
  extends Promise<CurrencyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CurrencyEdge>>() => T;
  aggregate: <T = AggregateCurrencyPromise>() => T;
}

export interface CurrencyConnectionSubscription
  extends Promise<AsyncIterator<CurrencyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CurrencyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCurrencySubscription>() => T;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface CostUnitByMenuItemSubscriptionPayload {
  mutation: MutationType;
  node: CostUnitByMenuItem;
  updatedFields: String[];
  previousValues: CostUnitByMenuItemPreviousValues;
}

export interface CostUnitByMenuItemSubscriptionPayloadPromise
  extends Promise<CostUnitByMenuItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CostUnitByMenuItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CostUnitByMenuItemPreviousValuesPromise>() => T;
}

export interface CostUnitByMenuItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CostUnitByMenuItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CostUnitByMenuItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CostUnitByMenuItemPreviousValuesSubscription>() => T;
}

export interface AggregateMenuItemCategory {
  count: Int;
}

export interface AggregateMenuItemCategoryPromise
  extends Promise<AggregateMenuItemCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMenuItemCategorySubscription
  extends Promise<AsyncIterator<AggregateMenuItemCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CostUnitByMenuItemPreviousValues {
  id: ID_Output;
}

export interface CostUnitByMenuItemPreviousValuesPromise
  extends Promise<CostUnitByMenuItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CostUnitByMenuItemPreviousValuesSubscription
  extends Promise<AsyncIterator<CostUnitByMenuItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface MenuItemCategoryConnection {
  pageInfo: PageInfo;
  edges: MenuItemCategoryEdge[];
}

export interface MenuItemCategoryConnectionPromise
  extends Promise<MenuItemCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MenuItemCategoryEdge>>() => T;
  aggregate: <T = AggregateMenuItemCategoryPromise>() => T;
}

export interface MenuItemCategoryConnectionSubscription
  extends Promise<AsyncIterator<MenuItemCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MenuItemCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMenuItemCategorySubscription>() => T;
}

export interface AggregateCostUnitByStockUnit {
  count: Int;
}

export interface AggregateCostUnitByStockUnitPromise
  extends Promise<AggregateCostUnitByStockUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCostUnitByStockUnitSubscription
  extends Promise<AsyncIterator<AggregateCostUnitByStockUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateMenuItemByOrder {
  count: Int;
}

export interface AggregateMenuItemByOrderPromise
  extends Promise<AggregateMenuItemByOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMenuItemByOrderSubscription
  extends Promise<AsyncIterator<AggregateMenuItemByOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CostUnitByStockUnitSubscriptionPayload {
  mutation: MutationType;
  node: CostUnitByStockUnit;
  updatedFields: String[];
  previousValues: CostUnitByStockUnitPreviousValues;
}

export interface CostUnitByStockUnitSubscriptionPayloadPromise
  extends Promise<CostUnitByStockUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CostUnitByStockUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CostUnitByStockUnitPreviousValuesPromise>() => T;
}

export interface CostUnitByStockUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CostUnitByStockUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CostUnitByStockUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CostUnitByStockUnitPreviousValuesSubscription>() => T;
}

export interface MenuItemByOrderConnection {
  pageInfo: PageInfo;
  edges: MenuItemByOrderEdge[];
}

export interface MenuItemByOrderConnectionPromise
  extends Promise<MenuItemByOrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MenuItemByOrderEdge>>() => T;
  aggregate: <T = AggregateMenuItemByOrderPromise>() => T;
}

export interface MenuItemByOrderConnectionSubscription
  extends Promise<AsyncIterator<MenuItemByOrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MenuItemByOrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMenuItemByOrderSubscription>() => T;
}

export interface CostUnitByStockUnitPreviousValues {
  id: ID_Output;
}

export interface CostUnitByStockUnitPreviousValuesPromise
  extends Promise<CostUnitByStockUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CostUnitByStockUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<CostUnitByStockUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Table {
  id: ID_Output;
  label: String;
  createdAt: DateTimeOutput;
}

export interface TablePromise extends Promise<Table>, Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface TableSubscription
  extends Promise<AsyncIterator<Table>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TableNullablePromise
  extends Promise<Table | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CostUnitByStockUnitEdge {
  node: CostUnitByStockUnit;
  cursor: String;
}

export interface CostUnitByStockUnitEdgePromise
  extends Promise<CostUnitByStockUnitEdge>,
    Fragmentable {
  node: <T = CostUnitByStockUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CostUnitByStockUnitEdgeSubscription
  extends Promise<AsyncIterator<CostUnitByStockUnitEdge>>,
    Fragmentable {
  node: <T = CostUnitByStockUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MenuItemByOrder {
  id: ID_Output;
}

export interface MenuItemByOrderPromise
  extends Promise<MenuItemByOrder>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: <T = OrderPromise>() => T;
  menuItem: <T = MenuItemPromise>() => T;
}

export interface MenuItemByOrderSubscription
  extends Promise<AsyncIterator<MenuItemByOrder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: <T = OrderSubscription>() => T;
  menuItem: <T = MenuItemSubscription>() => T;
}

export interface MenuItemByOrderNullablePromise
  extends Promise<MenuItemByOrder | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: <T = OrderPromise>() => T;
  menuItem: <T = MenuItemPromise>() => T;
}

export interface CurrencySubscriptionPayload {
  mutation: MutationType;
  node: Currency;
  updatedFields: String[];
  previousValues: CurrencyPreviousValues;
}

export interface CurrencySubscriptionPayloadPromise
  extends Promise<CurrencySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CurrencyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CurrencyPreviousValuesPromise>() => T;
}

export interface CurrencySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CurrencySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CurrencySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CurrencyPreviousValuesSubscription>() => T;
}

export interface MenuItemByMenuEdge {
  node: MenuItemByMenu;
  cursor: String;
}

export interface MenuItemByMenuEdgePromise
  extends Promise<MenuItemByMenuEdge>,
    Fragmentable {
  node: <T = MenuItemByMenuPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MenuItemByMenuEdgeSubscription
  extends Promise<AsyncIterator<MenuItemByMenuEdge>>,
    Fragmentable {
  node: <T = MenuItemByMenuSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CurrencyPreviousValues {
  id: ID_Output;
  symbol: String;
  isDefault?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CurrencyPreviousValuesPromise
  extends Promise<CurrencyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CurrencyPreviousValuesSubscription
  extends Promise<AsyncIterator<CurrencyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<String>>;
  isDefault: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MenuItemByMenu {
  id: ID_Output;
}

export interface MenuItemByMenuPromise
  extends Promise<MenuItemByMenu>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  menu: <T = MenuPromise>() => T;
  menuItem: <T = MenuItemPromise>() => T;
}

export interface MenuItemByMenuSubscription
  extends Promise<AsyncIterator<MenuItemByMenu>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  menu: <T = MenuSubscription>() => T;
  menuItem: <T = MenuItemSubscription>() => T;
}

export interface MenuItemByMenuNullablePromise
  extends Promise<MenuItemByMenu | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  menu: <T = MenuPromise>() => T;
  menuItem: <T = MenuItemPromise>() => T;
}

export interface CostUnitByStockUnitConnection {
  pageInfo: PageInfo;
  edges: CostUnitByStockUnitEdge[];
}

export interface CostUnitByStockUnitConnectionPromise
  extends Promise<CostUnitByStockUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CostUnitByStockUnitEdge>>() => T;
  aggregate: <T = AggregateCostUnitByStockUnitPromise>() => T;
}

export interface CostUnitByStockUnitConnectionSubscription
  extends Promise<AsyncIterator<CostUnitByStockUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CostUnitByStockUnitEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCostUnitByStockUnitSubscription>() => T;
}

export interface MenuItemEdge {
  node: MenuItem;
  cursor: String;
}

export interface MenuItemEdgePromise
  extends Promise<MenuItemEdge>,
    Fragmentable {
  node: <T = MenuItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MenuItemEdgeSubscription
  extends Promise<AsyncIterator<MenuItemEdge>>,
    Fragmentable {
  node: <T = MenuItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InventorySubscriptionPayload {
  mutation: MutationType;
  node: Inventory;
  updatedFields: String[];
  previousValues: InventoryPreviousValues;
}

export interface InventorySubscriptionPayloadPromise
  extends Promise<InventorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryPreviousValuesPromise>() => T;
}

export interface InventorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryPreviousValuesSubscription>() => T;
}

export interface Contact {
  id: ID_Output;
  email?: String;
  firstName?: String;
  lastName?: String;
  phoneNumber?: String;
  createdAt: DateTimeOutput;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContactNullablePromise
  extends Promise<Contact | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface InventoryPreviousValues {
  id: ID_Output;
  label: String;
  createdAt: DateTimeOutput;
}

export interface InventoryPreviousValuesPromise
  extends Promise<InventoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface InventoryPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MenuEdge {
  node: Menu;
  cursor: String;
}

export interface MenuEdgePromise extends Promise<MenuEdge>, Fragmentable {
  node: <T = MenuPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MenuEdgeSubscription
  extends Promise<AsyncIterator<MenuEdge>>,
    Fragmentable {
  node: <T = MenuSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StockUnitCategory {
  id: ID_Output;
  en_EN: String;
  es_ES: String;
  createdAt: DateTimeOutput;
}

export interface StockUnitCategoryPromise
  extends Promise<StockUnitCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  en_EN: () => Promise<String>;
  es_ES: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface StockUnitCategorySubscription
  extends Promise<AsyncIterator<StockUnitCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  en_EN: () => Promise<AsyncIterator<String>>;
  es_ES: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StockUnitCategoryNullablePromise
  extends Promise<StockUnitCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  en_EN: () => Promise<String>;
  es_ES: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Menu {
  id: ID_Output;
  label: String;
  createdAt: DateTimeOutput;
}

export interface MenuPromise extends Promise<Menu>, Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MenuSubscription
  extends Promise<AsyncIterator<Menu>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MenuNullablePromise
  extends Promise<Menu | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface InventoryByStockUnitSubscriptionPayload {
  mutation: MutationType;
  node: InventoryByStockUnit;
  updatedFields: String[];
  previousValues: InventoryByStockUnitPreviousValues;
}

export interface InventoryByStockUnitSubscriptionPayloadPromise
  extends Promise<InventoryByStockUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryByStockUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryByStockUnitPreviousValuesPromise>() => T;
}

export interface InventoryByStockUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventoryByStockUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventoryByStockUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryByStockUnitPreviousValuesSubscription>() => T;
}

export interface MeasurementUnitEdge {
  node: MeasurementUnit;
  cursor: String;
}

export interface MeasurementUnitEdgePromise
  extends Promise<MeasurementUnitEdge>,
    Fragmentable {
  node: <T = MeasurementUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MeasurementUnitEdgeSubscription
  extends Promise<AsyncIterator<MeasurementUnitEdge>>,
    Fragmentable {
  node: <T = MeasurementUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InventoryByStockUnitPreviousValues {
  id: ID_Output;
  amount: String;
  expiresAt?: DateTimeOutput;
}

export interface InventoryByStockUnitPreviousValuesPromise
  extends Promise<InventoryByStockUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  expiresAt: () => Promise<DateTimeOutput>;
}

export interface InventoryByStockUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryByStockUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  expiresAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface Supplier {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
}

export interface SupplierPromise extends Promise<Supplier>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  contact: <T = ContactPromise>() => T;
  address: <T = AddressPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface SupplierSubscription
  extends Promise<AsyncIterator<Supplier>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  contact: <T = ContactSubscription>() => T;
  address: <T = AddressSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SupplierNullablePromise
  extends Promise<Supplier | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  contact: <T = ContactPromise>() => T;
  address: <T = AddressPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface LaborUnitEdge {
  node: LaborUnit;
  cursor: String;
}

export interface LaborUnitEdgePromise
  extends Promise<LaborUnitEdge>,
    Fragmentable {
  node: <T = LaborUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LaborUnitEdgeSubscription
  extends Promise<AsyncIterator<LaborUnitEdge>>,
    Fragmentable {
  node: <T = LaborUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LaborUnitSubscriptionPayload {
  mutation: MutationType;
  node: LaborUnit;
  updatedFields: String[];
  previousValues: LaborUnitPreviousValues;
}

export interface LaborUnitSubscriptionPayloadPromise
  extends Promise<LaborUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LaborUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LaborUnitPreviousValuesPromise>() => T;
}

export interface LaborUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LaborUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LaborUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LaborUnitPreviousValuesSubscription>() => T;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LaborUnitPreviousValues {
  id: ID_Output;
  label: String;
  createdAt: DateTimeOutput;
}

export interface LaborUnitPreviousValuesPromise
  extends Promise<LaborUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface LaborUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<LaborUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryByStockUnitEdge {
  node: InventoryByStockUnit;
  cursor: String;
}

export interface InventoryByStockUnitEdgePromise
  extends Promise<InventoryByStockUnitEdge>,
    Fragmentable {
  node: <T = InventoryByStockUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryByStockUnitEdgeSubscription
  extends Promise<AsyncIterator<InventoryByStockUnitEdge>>,
    Fragmentable {
  node: <T = InventoryByStockUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CostUnitConnection {
  pageInfo: PageInfo;
  edges: CostUnitEdge[];
}

export interface CostUnitConnectionPromise
  extends Promise<CostUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CostUnitEdge>>() => T;
  aggregate: <T = AggregateCostUnitPromise>() => T;
}

export interface CostUnitConnectionSubscription
  extends Promise<AsyncIterator<CostUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CostUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCostUnitSubscription>() => T;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MeasurementUnitSubscriptionPayload {
  mutation: MutationType;
  node: MeasurementUnit;
  updatedFields: String[];
  previousValues: MeasurementUnitPreviousValues;
}

export interface MeasurementUnitSubscriptionPayloadPromise
  extends Promise<MeasurementUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MeasurementUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MeasurementUnitPreviousValuesPromise>() => T;
}

export interface MeasurementUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MeasurementUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MeasurementUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MeasurementUnitPreviousValuesSubscription>() => T;
}

export interface MeasurementUnit {
  id: ID_Output;
  symbol: MeasurementUnitSymbol;
  name: MeasurementUnitName;
}

export interface MeasurementUnitPromise
  extends Promise<MeasurementUnit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<MeasurementUnitSymbol>;
  name: () => Promise<MeasurementUnitName>;
}

export interface MeasurementUnitSubscription
  extends Promise<AsyncIterator<MeasurementUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<MeasurementUnitSymbol>>;
  name: () => Promise<AsyncIterator<MeasurementUnitName>>;
}

export interface MeasurementUnitNullablePromise
  extends Promise<MeasurementUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<MeasurementUnitSymbol>;
  name: () => Promise<MeasurementUnitName>;
}

export interface MeasurementUnitPreviousValues {
  id: ID_Output;
  symbol: MeasurementUnitSymbol;
  name: MeasurementUnitName;
}

export interface MeasurementUnitPreviousValuesPromise
  extends Promise<MeasurementUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<MeasurementUnitSymbol>;
  name: () => Promise<MeasurementUnitName>;
}

export interface MeasurementUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<MeasurementUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<MeasurementUnitSymbol>>;
  name: () => Promise<AsyncIterator<MeasurementUnitName>>;
}

export interface CostUnitByLaborUnitConnection {
  pageInfo: PageInfo;
  edges: CostUnitByLaborUnitEdge[];
}

export interface CostUnitByLaborUnitConnectionPromise
  extends Promise<CostUnitByLaborUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CostUnitByLaborUnitEdge>>() => T;
  aggregate: <T = AggregateCostUnitByLaborUnitPromise>() => T;
}

export interface CostUnitByLaborUnitConnectionSubscription
  extends Promise<AsyncIterator<CostUnitByLaborUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CostUnitByLaborUnitEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCostUnitByLaborUnitSubscription>() => T;
}

export interface StockUnit {
  id: ID_Output;
  name: String;
  sku?: String;
  createdAt: DateTimeOutput;
}

export interface StockUnitPromise extends Promise<StockUnit>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  sku: () => Promise<String>;
  supplier: <T = FragmentableArray<Supplier>>(args?: {
    where?: SupplierWhereInput;
    orderBy?: SupplierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stockUnitCategory: <T = StockUnitCategoryPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface StockUnitSubscription
  extends Promise<AsyncIterator<StockUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  sku: () => Promise<AsyncIterator<String>>;
  supplier: <T = Promise<AsyncIterator<SupplierSubscription>>>(args?: {
    where?: SupplierWhereInput;
    orderBy?: SupplierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stockUnitCategory: <T = StockUnitCategorySubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StockUnitNullablePromise
  extends Promise<StockUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  sku: () => Promise<String>;
  supplier: <T = FragmentableArray<Supplier>>(args?: {
    where?: SupplierWhereInput;
    orderBy?: SupplierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stockUnitCategory: <T = StockUnitCategoryPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface TableEdge {
  node: Table;
  cursor: String;
}

export interface TableEdgePromise extends Promise<TableEdge>, Fragmentable {
  node: <T = TablePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TableEdgeSubscription
  extends Promise<AsyncIterator<TableEdge>>,
    Fragmentable {
  node: <T = TableSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MenuSubscriptionPayload {
  mutation: MutationType;
  node: Menu;
  updatedFields: String[];
  previousValues: MenuPreviousValues;
}

export interface MenuSubscriptionPayloadPromise
  extends Promise<MenuSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MenuPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MenuPreviousValuesPromise>() => T;
}

export interface MenuSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MenuSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MenuPreviousValuesSubscription>() => T;
}

export interface SupplierByStockUnitEdge {
  node: SupplierByStockUnit;
  cursor: String;
}

export interface SupplierByStockUnitEdgePromise
  extends Promise<SupplierByStockUnitEdge>,
    Fragmentable {
  node: <T = SupplierByStockUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SupplierByStockUnitEdgeSubscription
  extends Promise<AsyncIterator<SupplierByStockUnitEdge>>,
    Fragmentable {
  node: <T = SupplierByStockUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MenuPreviousValues {
  id: ID_Output;
  label: String;
  createdAt: DateTimeOutput;
}

export interface MenuPreviousValuesPromise
  extends Promise<MenuPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MenuPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateSupplier {
  count: Int;
}

export interface AggregateSupplierPromise
  extends Promise<AggregateSupplier>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSupplierSubscription
  extends Promise<AsyncIterator<AggregateSupplier>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CostUnitByStockUnit {
  id: ID_Output;
}

export interface CostUnitByStockUnitPromise
  extends Promise<CostUnitByStockUnit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  stockUnit: <T = StockUnitPromise>() => T;
  costUnit: <T = CostUnitPromise>() => T;
}

export interface CostUnitByStockUnitSubscription
  extends Promise<AsyncIterator<CostUnitByStockUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stockUnit: <T = StockUnitSubscription>() => T;
  costUnit: <T = CostUnitSubscription>() => T;
}

export interface CostUnitByStockUnitNullablePromise
  extends Promise<CostUnitByStockUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  stockUnit: <T = StockUnitPromise>() => T;
  costUnit: <T = CostUnitPromise>() => T;
}

export interface StockUnitCategoryEdge {
  node: StockUnitCategory;
  cursor: String;
}

export interface StockUnitCategoryEdgePromise
  extends Promise<StockUnitCategoryEdge>,
    Fragmentable {
  node: <T = StockUnitCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StockUnitCategoryEdgeSubscription
  extends Promise<AsyncIterator<StockUnitCategoryEdge>>,
    Fragmentable {
  node: <T = StockUnitCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MenuItemSubscriptionPayload {
  mutation: MutationType;
  node: MenuItem;
  updatedFields: String[];
  previousValues: MenuItemPreviousValues;
}

export interface MenuItemSubscriptionPayloadPromise
  extends Promise<MenuItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MenuItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MenuItemPreviousValuesPromise>() => T;
}

export interface MenuItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MenuItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MenuItemPreviousValuesSubscription>() => T;
}

export interface StockUnitConnection {
  pageInfo: PageInfo;
  edges: StockUnitEdge[];
}

export interface StockUnitConnectionPromise
  extends Promise<StockUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StockUnitEdge>>() => T;
  aggregate: <T = AggregateStockUnitPromise>() => T;
}

export interface StockUnitConnectionSubscription
  extends Promise<AsyncIterator<StockUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StockUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStockUnitSubscription>() => T;
}

export interface MenuItemPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MenuItemPreviousValuesPromise
  extends Promise<MenuItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MenuItemPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PriceConnection {
  pageInfo: PageInfo;
  edges: PriceEdge[];
}

export interface PriceConnectionPromise
  extends Promise<PriceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PriceEdge>>() => T;
  aggregate: <T = AggregatePricePromise>() => T;
}

export interface PriceConnectionSubscription
  extends Promise<AsyncIterator<PriceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PriceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePriceSubscription>() => T;
}

export interface AggregateCostUnitByMenuItem {
  count: Int;
}

export interface AggregateCostUnitByMenuItemPromise
  extends Promise<AggregateCostUnitByMenuItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCostUnitByMenuItemSubscription
  extends Promise<AsyncIterator<AggregateCostUnitByMenuItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MenuItemByMenuSubscriptionPayload {
  mutation: MutationType;
  node: MenuItemByMenu;
  updatedFields: String[];
  previousValues: MenuItemByMenuPreviousValues;
}

export interface MenuItemByMenuSubscriptionPayloadPromise
  extends Promise<MenuItemByMenuSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MenuItemByMenuPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MenuItemByMenuPreviousValuesPromise>() => T;
}

export interface MenuItemByMenuSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuItemByMenuSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MenuItemByMenuSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MenuItemByMenuPreviousValuesSubscription>() => T;
}

export interface MenuItemCategoryEdge {
  node: MenuItemCategory;
  cursor: String;
}

export interface MenuItemCategoryEdgePromise
  extends Promise<MenuItemCategoryEdge>,
    Fragmentable {
  node: <T = MenuItemCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MenuItemCategoryEdgeSubscription
  extends Promise<AsyncIterator<MenuItemCategoryEdge>>,
    Fragmentable {
  node: <T = MenuItemCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MenuItemByMenuPreviousValues {
  id: ID_Output;
}

export interface MenuItemByMenuPreviousValuesPromise
  extends Promise<MenuItemByMenuPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface MenuItemByMenuPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuItemByMenuPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface MenuItemByOrderEdge {
  node: MenuItemByOrder;
  cursor: String;
}

export interface MenuItemByOrderEdgePromise
  extends Promise<MenuItemByOrderEdge>,
    Fragmentable {
  node: <T = MenuItemByOrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MenuItemByOrderEdgeSubscription
  extends Promise<AsyncIterator<MenuItemByOrderEdge>>,
    Fragmentable {
  node: <T = MenuItemByOrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CostUnitByMenuItemEdge {
  node: CostUnitByMenuItem;
  cursor: String;
}

export interface CostUnitByMenuItemEdgePromise
  extends Promise<CostUnitByMenuItemEdge>,
    Fragmentable {
  node: <T = CostUnitByMenuItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CostUnitByMenuItemEdgeSubscription
  extends Promise<AsyncIterator<CostUnitByMenuItemEdge>>,
    Fragmentable {
  node: <T = CostUnitByMenuItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Order {
  id: ID_Output;
  amount: String;
  orderedAt: DateTimeOutput;
  paidAt?: DateTimeOutput;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  table: <T = TablePromise>() => T;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  orderedAt: () => Promise<DateTimeOutput>;
  paidAt: () => Promise<DateTimeOutput>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  table: <T = TableSubscription>() => T;
  amount: () => Promise<AsyncIterator<String>>;
  currency: <T = CurrencySubscription>() => T;
  orderedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  paidAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  table: <T = TablePromise>() => T;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  orderedAt: () => Promise<DateTimeOutput>;
  paidAt: () => Promise<DateTimeOutput>;
}

export interface MenuItemByOrderSubscriptionPayload {
  mutation: MutationType;
  node: MenuItemByOrder;
  updatedFields: String[];
  previousValues: MenuItemByOrderPreviousValues;
}

export interface MenuItemByOrderSubscriptionPayloadPromise
  extends Promise<MenuItemByOrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MenuItemByOrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MenuItemByOrderPreviousValuesPromise>() => T;
}

export interface MenuItemByOrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuItemByOrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MenuItemByOrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MenuItemByOrderPreviousValuesSubscription>() => T;
}

export interface MenuItemByMenuConnection {
  pageInfo: PageInfo;
  edges: MenuItemByMenuEdge[];
}

export interface MenuItemByMenuConnectionPromise
  extends Promise<MenuItemByMenuConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MenuItemByMenuEdge>>() => T;
  aggregate: <T = AggregateMenuItemByMenuPromise>() => T;
}

export interface MenuItemByMenuConnectionSubscription
  extends Promise<AsyncIterator<MenuItemByMenuConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MenuItemByMenuEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMenuItemByMenuSubscription>() => T;
}

export interface MenuItemByOrderPreviousValues {
  id: ID_Output;
}

export interface MenuItemByOrderPreviousValuesPromise
  extends Promise<MenuItemByOrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface MenuItemByOrderPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuItemByOrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface MenuItemConnection {
  pageInfo: PageInfo;
  edges: MenuItemEdge[];
}

export interface MenuItemConnectionPromise
  extends Promise<MenuItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MenuItemEdge>>() => T;
  aggregate: <T = AggregateMenuItemPromise>() => T;
}

export interface MenuItemConnectionSubscription
  extends Promise<AsyncIterator<MenuItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MenuItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMenuItemSubscription>() => T;
}

export interface CostUnitByMenuItemConnection {
  pageInfo: PageInfo;
  edges: CostUnitByMenuItemEdge[];
}

export interface CostUnitByMenuItemConnectionPromise
  extends Promise<CostUnitByMenuItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CostUnitByMenuItemEdge>>() => T;
  aggregate: <T = AggregateCostUnitByMenuItemPromise>() => T;
}

export interface CostUnitByMenuItemConnectionSubscription
  extends Promise<AsyncIterator<CostUnitByMenuItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CostUnitByMenuItemEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCostUnitByMenuItemSubscription>() => T;
}

export interface MenuConnection {
  pageInfo: PageInfo;
  edges: MenuEdge[];
}

export interface MenuConnectionPromise
  extends Promise<MenuConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MenuEdge>>() => T;
  aggregate: <T = AggregateMenuPromise>() => T;
}

export interface MenuConnectionSubscription
  extends Promise<AsyncIterator<MenuConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MenuEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMenuSubscription>() => T;
}

export interface MenuItemCategorySubscriptionPayload {
  mutation: MutationType;
  node: MenuItemCategory;
  updatedFields: String[];
  previousValues: MenuItemCategoryPreviousValues;
}

export interface MenuItemCategorySubscriptionPayloadPromise
  extends Promise<MenuItemCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MenuItemCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MenuItemCategoryPreviousValuesPromise>() => T;
}

export interface MenuItemCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MenuItemCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MenuItemCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MenuItemCategoryPreviousValuesSubscription>() => T;
}

export interface MeasurementUnitConnection {
  pageInfo: PageInfo;
  edges: MeasurementUnitEdge[];
}

export interface MeasurementUnitConnectionPromise
  extends Promise<MeasurementUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MeasurementUnitEdge>>() => T;
  aggregate: <T = AggregateMeasurementUnitPromise>() => T;
}

export interface MeasurementUnitConnectionSubscription
  extends Promise<AsyncIterator<MeasurementUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MeasurementUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMeasurementUnitSubscription>() => T;
}

export interface MenuItemCategoryPreviousValues {
  id: ID_Output;
  name: MenuItemCategoryName;
}

export interface MenuItemCategoryPreviousValuesPromise
  extends Promise<MenuItemCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<MenuItemCategoryName>;
}

export interface MenuItemCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<MenuItemCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<MenuItemCategoryName>>;
}

export interface LaborUnitConnection {
  pageInfo: PageInfo;
  edges: LaborUnitEdge[];
}

export interface LaborUnitConnectionPromise
  extends Promise<LaborUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LaborUnitEdge>>() => T;
  aggregate: <T = AggregateLaborUnitPromise>() => T;
}

export interface LaborUnitConnectionSubscription
  extends Promise<AsyncIterator<LaborUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LaborUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLaborUnitSubscription>() => T;
}

export interface CostUnitEdge {
  node: CostUnit;
  cursor: String;
}

export interface CostUnitEdgePromise
  extends Promise<CostUnitEdge>,
    Fragmentable {
  node: <T = CostUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CostUnitEdgeSubscription
  extends Promise<AsyncIterator<CostUnitEdge>>,
    Fragmentable {
  node: <T = CostUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InventoryByStockUnitConnection {
  pageInfo: PageInfo;
  edges: InventoryByStockUnitEdge[];
}

export interface InventoryByStockUnitConnectionPromise
  extends Promise<InventoryByStockUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryByStockUnitEdge>>() => T;
  aggregate: <T = AggregateInventoryByStockUnitPromise>() => T;
}

export interface InventoryByStockUnitConnectionSubscription
  extends Promise<AsyncIterator<InventoryByStockUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<InventoryByStockUnitEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateInventoryByStockUnitSubscription>() => T;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface InventoryByStockUnit {
  id: ID_Output;
  amount: String;
  expiresAt?: DateTimeOutput;
}

export interface InventoryByStockUnitPromise
  extends Promise<InventoryByStockUnit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  stockUnit: <T = StockUnitPromise>() => T;
  unit: <T = MeasurementUnitPromise>() => T;
  expiresAt: () => Promise<DateTimeOutput>;
}

export interface InventoryByStockUnitSubscription
  extends Promise<AsyncIterator<InventoryByStockUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  stockUnit: <T = StockUnitSubscription>() => T;
  unit: <T = MeasurementUnitSubscription>() => T;
  expiresAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryByStockUnitNullablePromise
  extends Promise<InventoryByStockUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  stockUnit: <T = StockUnitPromise>() => T;
  unit: <T = MeasurementUnitPromise>() => T;
  expiresAt: () => Promise<DateTimeOutput>;
}

export interface OrderPreviousValues {
  id: ID_Output;
  amount: String;
  orderedAt: DateTimeOutput;
  paidAt?: DateTimeOutput;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  orderedAt: () => Promise<DateTimeOutput>;
  paidAt: () => Promise<DateTimeOutput>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  orderedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  paidAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SupplierByStockUnitPreviousValues {
  id: ID_Output;
}

export interface SupplierByStockUnitPreviousValuesPromise
  extends Promise<SupplierByStockUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SupplierByStockUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<SupplierByStockUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateCostUnit {
  count: Int;
}

export interface AggregateCostUnitPromise
  extends Promise<AggregateCostUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCostUnitSubscription
  extends Promise<AsyncIterator<AggregateCostUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SupplierConnection {
  pageInfo: PageInfo;
  edges: SupplierEdge[];
}

export interface SupplierConnectionPromise
  extends Promise<SupplierConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SupplierEdge>>() => T;
  aggregate: <T = AggregateSupplierPromise>() => T;
}

export interface SupplierConnectionSubscription
  extends Promise<AsyncIterator<SupplierConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SupplierEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSupplierSubscription>() => T;
}

export interface PriceSubscriptionPayload {
  mutation: MutationType;
  node: Price;
  updatedFields: String[];
  previousValues: PricePreviousValues;
}

export interface PriceSubscriptionPayloadPromise
  extends Promise<PriceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PricePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PricePreviousValuesPromise>() => T;
}

export interface PriceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PriceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PriceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PricePreviousValuesSubscription>() => T;
}

export interface AggregatePrice {
  count: Int;
}

export interface AggregatePricePromise
  extends Promise<AggregatePrice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePriceSubscription
  extends Promise<AsyncIterator<AggregatePrice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PricePreviousValues {
  id: ID_Output;
  amount: String;
  label?: String;
  createdAt: DateTimeOutput;
}

export interface PricePreviousValuesPromise
  extends Promise<PricePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface PricePreviousValuesSubscription
  extends Promise<AsyncIterator<PricePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TableSubscriptionPayload {
  mutation: MutationType;
  node: Table;
  updatedFields: String[];
  previousValues: TablePreviousValues;
}

export interface TableSubscriptionPayloadPromise
  extends Promise<TableSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TablePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TablePreviousValuesPromise>() => T;
}

export interface TableSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TableSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TableSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TablePreviousValuesSubscription>() => T;
}

export interface MenuItemCategory {
  id: ID_Output;
  name: MenuItemCategoryName;
}

export interface MenuItemCategoryPromise
  extends Promise<MenuItemCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<MenuItemCategoryName>;
}

export interface MenuItemCategorySubscription
  extends Promise<AsyncIterator<MenuItemCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<MenuItemCategoryName>>;
}

export interface MenuItemCategoryNullablePromise
  extends Promise<MenuItemCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<MenuItemCategoryName>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StockUnitSubscriptionPayload {
  mutation: MutationType;
  node: StockUnit;
  updatedFields: String[];
  previousValues: StockUnitPreviousValues;
}

export interface StockUnitSubscriptionPayloadPromise
  extends Promise<StockUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StockUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StockUnitPreviousValuesPromise>() => T;
}

export interface StockUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StockUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StockUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StockUnitPreviousValuesSubscription>() => T;
}

export interface AggregateMenuItem {
  count: Int;
}

export interface AggregateMenuItemPromise
  extends Promise<AggregateMenuItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMenuItemSubscription
  extends Promise<AsyncIterator<AggregateMenuItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StockUnitPreviousValues {
  id: ID_Output;
  name: String;
  sku?: String;
  createdAt: DateTimeOutput;
}

export interface StockUnitPreviousValuesPromise
  extends Promise<StockUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  sku: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface StockUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<StockUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  sku: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateMeasurementUnit {
  count: Int;
}

export interface AggregateMeasurementUnitPromise
  extends Promise<AggregateMeasurementUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMeasurementUnitSubscription
  extends Promise<AsyncIterator<AggregateMeasurementUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MenuItem {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MenuItemPromise extends Promise<MenuItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: <T = MenuItemCategoryPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MenuItemSubscription
  extends Promise<AsyncIterator<MenuItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: <T = MenuItemCategorySubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MenuItemNullablePromise
  extends Promise<MenuItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: <T = MenuItemCategoryPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateInventoryByStockUnit {
  count: Int;
}

export interface AggregateInventoryByStockUnitPromise
  extends Promise<AggregateInventoryByStockUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventoryByStockUnitSubscription
  extends Promise<AsyncIterator<AggregateInventoryByStockUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StockUnitByMenuItemSubscriptionPayload {
  mutation: MutationType;
  node: StockUnitByMenuItem;
  updatedFields: String[];
  previousValues: StockUnitByMenuItemPreviousValues;
}

export interface StockUnitByMenuItemSubscriptionPayloadPromise
  extends Promise<StockUnitByMenuItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StockUnitByMenuItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StockUnitByMenuItemPreviousValuesPromise>() => T;
}

export interface StockUnitByMenuItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StockUnitByMenuItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StockUnitByMenuItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StockUnitByMenuItemPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface StockUnitByMenuItemPreviousValues {
  id: ID_Output;
  amount: String;
}

export interface StockUnitByMenuItemPreviousValuesPromise
  extends Promise<StockUnitByMenuItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
}

export interface StockUnitByMenuItemPreviousValuesSubscription
  extends Promise<AsyncIterator<StockUnitByMenuItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStockUnit {
  count: Int;
}

export interface AggregateStockUnitPromise
  extends Promise<AggregateStockUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStockUnitSubscription
  extends Promise<AsyncIterator<AggregateStockUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CostUnitByMenuItem {
  id: ID_Output;
}

export interface CostUnitByMenuItemPromise
  extends Promise<CostUnitByMenuItem>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  menuItem: <T = MenuItemPromise>() => T;
  costUnit: <T = CostUnitPromise>() => T;
}

export interface CostUnitByMenuItemSubscription
  extends Promise<AsyncIterator<CostUnitByMenuItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  menuItem: <T = MenuItemSubscription>() => T;
  costUnit: <T = CostUnitSubscription>() => T;
}

export interface CostUnitByMenuItemNullablePromise
  extends Promise<CostUnitByMenuItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  menuItem: <T = MenuItemPromise>() => T;
  costUnit: <T = CostUnitPromise>() => T;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StockUnitCategorySubscriptionPayload {
  mutation: MutationType;
  node: StockUnitCategory;
  updatedFields: String[];
  previousValues: StockUnitCategoryPreviousValues;
}

export interface StockUnitCategorySubscriptionPayloadPromise
  extends Promise<StockUnitCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StockUnitCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StockUnitCategoryPreviousValuesPromise>() => T;
}

export interface StockUnitCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StockUnitCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StockUnitCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StockUnitCategoryPreviousValuesSubscription>() => T;
}

export interface AggregateMenu {
  count: Int;
}

export interface AggregateMenuPromise
  extends Promise<AggregateMenu>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMenuSubscription
  extends Promise<AsyncIterator<AggregateMenu>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CostUnit {
  id: ID_Output;
  amount: String;
  label?: String;
  createdAt: DateTimeOutput;
}

export interface CostUnitPromise extends Promise<CostUnit>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CostUnitSubscription
  extends Promise<AsyncIterator<CostUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  currency: <T = CurrencySubscription>() => T;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CostUnitNullablePromise
  extends Promise<CostUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface SupplierPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
}

export interface SupplierPreviousValuesPromise
  extends Promise<SupplierPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface SupplierPreviousValuesSubscription
  extends Promise<AsyncIterator<SupplierPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SupplierSubscriptionPayload {
  mutation: MutationType;
  node: Supplier;
  updatedFields: String[];
  previousValues: SupplierPreviousValues;
}

export interface SupplierSubscriptionPayloadPromise
  extends Promise<SupplierSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SupplierPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SupplierPreviousValuesPromise>() => T;
}

export interface SupplierSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SupplierSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SupplierSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SupplierPreviousValuesSubscription>() => T;
}

export interface AggregateCostUnitByLaborUnit {
  count: Int;
}

export interface AggregateCostUnitByLaborUnitPromise
  extends Promise<AggregateCostUnitByLaborUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCostUnitByLaborUnitSubscription
  extends Promise<AsyncIterator<AggregateCostUnitByLaborUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StockUnitCategoryPreviousValues {
  id: ID_Output;
  en_EN: String;
  es_ES: String;
  createdAt: DateTimeOutput;
}

export interface StockUnitCategoryPreviousValuesPromise
  extends Promise<StockUnitCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  en_EN: () => Promise<String>;
  es_ES: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface StockUnitCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<StockUnitCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  en_EN: () => Promise<AsyncIterator<String>>;
  es_ES: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SupplierByStockUnitSubscriptionPayload {
  mutation: MutationType;
  node: SupplierByStockUnit;
  updatedFields: String[];
  previousValues: SupplierByStockUnitPreviousValues;
}

export interface SupplierByStockUnitSubscriptionPayloadPromise
  extends Promise<SupplierByStockUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SupplierByStockUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SupplierByStockUnitPreviousValuesPromise>() => T;
}

export interface SupplierByStockUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SupplierByStockUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SupplierByStockUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SupplierByStockUnitPreviousValuesSubscription>() => T;
}

export interface AggregateLaborUnit {
  count: Int;
}

export interface AggregateLaborUnitPromise
  extends Promise<AggregateLaborUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLaborUnitSubscription
  extends Promise<AsyncIterator<AggregateLaborUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateMenuItemByMenu {
  count: Int;
}

export interface AggregateMenuItemByMenuPromise
  extends Promise<AggregateMenuItemByMenu>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMenuItemByMenuSubscription
  extends Promise<AsyncIterator<AggregateMenuItemByMenu>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Price {
  id: ID_Output;
  amount: String;
  label?: String;
  createdAt: DateTimeOutput;
}

export interface PricePromise extends Promise<Price>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface PriceSubscription
  extends Promise<AsyncIterator<Price>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  currency: <T = CurrencySubscription>() => T;
  label: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PriceNullablePromise
  extends Promise<Price | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  label: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Price",
    embedded: false
  },
  {
    name: "CostUnit",
    embedded: false
  },
  {
    name: "Currency",
    embedded: false
  },
  {
    name: "CostUnitByStockUnit",
    embedded: false
  },
  {
    name: "LaborUnit",
    embedded: false
  },
  {
    name: "CostUnitByLaborUnit",
    embedded: false
  },
  {
    name: "StockUnit",
    embedded: false
  },
  {
    name: "StockUnitCategory",
    embedded: false
  },
  {
    name: "Supplier",
    embedded: false
  },
  {
    name: "SupplierByStockUnit",
    embedded: false
  },
  {
    name: "Contact",
    embedded: false
  },
  {
    name: "Address",
    embedded: false
  },
  {
    name: "MeasurementUnit",
    embedded: false
  },
  {
    name: "MeasurementUnitName",
    embedded: false
  },
  {
    name: "MeasurementUnitSymbol",
    embedded: false
  },
  {
    name: "Inventory",
    embedded: false
  },
  {
    name: "InventoryByStockUnit",
    embedded: false
  },
  {
    name: "MenuItem",
    embedded: false
  },
  {
    name: "MenuItemCategory",
    embedded: false
  },
  {
    name: "MenuItemCategoryName",
    embedded: false
  },
  {
    name: "CostUnitByMenuItem",
    embedded: false
  },
  {
    name: "StockUnitByMenuItem",
    embedded: false
  },
  {
    name: "Menu",
    embedded: false
  },
  {
    name: "MenuItemByMenu",
    embedded: false
  },
  {
    name: "Table",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "MenuItemByOrder",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
