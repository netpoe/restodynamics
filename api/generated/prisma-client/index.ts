// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  currency: (where?: CurrencyWhereInput) => Promise<boolean>;
  expenseUnit: (where?: ExpenseUnitWhereInput) => Promise<boolean>;
  expenseUnitCategory: (
    where?: ExpenseUnitCategoryWhereInput
  ) => Promise<boolean>;
  inventory: (where?: InventoryWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  measurementUnit: (where?: MeasurementUnitWhereInput) => Promise<boolean>;
  merchandise: (where?: MerchandiseWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  currency: (where: CurrencyWhereUniqueInput) => CurrencyNullablePromise;
  currencies: (args?: {
    where?: CurrencyWhereInput;
    orderBy?: CurrencyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Currency>;
  currenciesConnection: (args?: {
    where?: CurrencyWhereInput;
    orderBy?: CurrencyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CurrencyConnectionPromise;
  expenseUnit: (
    where: ExpenseUnitWhereUniqueInput
  ) => ExpenseUnitNullablePromise;
  expenseUnits: (args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExpenseUnit>;
  expenseUnitsConnection: (args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpenseUnitConnectionPromise;
  expenseUnitCategory: (
    where: ExpenseUnitCategoryWhereUniqueInput
  ) => ExpenseUnitCategoryNullablePromise;
  expenseUnitCategories: (args?: {
    where?: ExpenseUnitCategoryWhereInput;
    orderBy?: ExpenseUnitCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExpenseUnitCategory>;
  expenseUnitCategoriesConnection: (args?: {
    where?: ExpenseUnitCategoryWhereInput;
    orderBy?: ExpenseUnitCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpenseUnitCategoryConnectionPromise;
  inventory: (where: InventoryWhereUniqueInput) => InventoryNullablePromise;
  inventories: (args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Inventory>;
  inventoriesConnection: (args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InventoryConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  measurementUnit: (
    where: MeasurementUnitWhereUniqueInput
  ) => MeasurementUnitNullablePromise;
  measurementUnits: (args?: {
    where?: MeasurementUnitWhereInput;
    orderBy?: MeasurementUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MeasurementUnit>;
  measurementUnitsConnection: (args?: {
    where?: MeasurementUnitWhereInput;
    orderBy?: MeasurementUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MeasurementUnitConnectionPromise;
  merchandise: (
    where: MerchandiseWhereUniqueInput
  ) => MerchandiseNullablePromise;
  merchandises: (args?: {
    where?: MerchandiseWhereInput;
    orderBy?: MerchandiseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Merchandise>;
  merchandisesConnection: (args?: {
    where?: MerchandiseWhereInput;
    orderBy?: MerchandiseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MerchandiseConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCurrency: (data: CurrencyCreateInput) => CurrencyPromise;
  updateCurrency: (args: {
    data: CurrencyUpdateInput;
    where: CurrencyWhereUniqueInput;
  }) => CurrencyPromise;
  updateManyCurrencies: (args: {
    data: CurrencyUpdateManyMutationInput;
    where?: CurrencyWhereInput;
  }) => BatchPayloadPromise;
  upsertCurrency: (args: {
    where: CurrencyWhereUniqueInput;
    create: CurrencyCreateInput;
    update: CurrencyUpdateInput;
  }) => CurrencyPromise;
  deleteCurrency: (where: CurrencyWhereUniqueInput) => CurrencyPromise;
  deleteManyCurrencies: (where?: CurrencyWhereInput) => BatchPayloadPromise;
  createExpenseUnit: (data: ExpenseUnitCreateInput) => ExpenseUnitPromise;
  updateExpenseUnit: (args: {
    data: ExpenseUnitUpdateInput;
    where: ExpenseUnitWhereUniqueInput;
  }) => ExpenseUnitPromise;
  updateManyExpenseUnits: (args: {
    data: ExpenseUnitUpdateManyMutationInput;
    where?: ExpenseUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertExpenseUnit: (args: {
    where: ExpenseUnitWhereUniqueInput;
    create: ExpenseUnitCreateInput;
    update: ExpenseUnitUpdateInput;
  }) => ExpenseUnitPromise;
  deleteExpenseUnit: (where: ExpenseUnitWhereUniqueInput) => ExpenseUnitPromise;
  deleteManyExpenseUnits: (
    where?: ExpenseUnitWhereInput
  ) => BatchPayloadPromise;
  createExpenseUnitCategory: (
    data: ExpenseUnitCategoryCreateInput
  ) => ExpenseUnitCategoryPromise;
  updateExpenseUnitCategory: (args: {
    data: ExpenseUnitCategoryUpdateInput;
    where: ExpenseUnitCategoryWhereUniqueInput;
  }) => ExpenseUnitCategoryPromise;
  updateManyExpenseUnitCategories: (args: {
    data: ExpenseUnitCategoryUpdateManyMutationInput;
    where?: ExpenseUnitCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertExpenseUnitCategory: (args: {
    where: ExpenseUnitCategoryWhereUniqueInput;
    create: ExpenseUnitCategoryCreateInput;
    update: ExpenseUnitCategoryUpdateInput;
  }) => ExpenseUnitCategoryPromise;
  deleteExpenseUnitCategory: (
    where: ExpenseUnitCategoryWhereUniqueInput
  ) => ExpenseUnitCategoryPromise;
  deleteManyExpenseUnitCategories: (
    where?: ExpenseUnitCategoryWhereInput
  ) => BatchPayloadPromise;
  createInventory: (data: InventoryCreateInput) => InventoryPromise;
  updateInventory: (args: {
    data: InventoryUpdateInput;
    where: InventoryWhereUniqueInput;
  }) => InventoryPromise;
  updateManyInventories: (args: {
    data: InventoryUpdateManyMutationInput;
    where?: InventoryWhereInput;
  }) => BatchPayloadPromise;
  upsertInventory: (args: {
    where: InventoryWhereUniqueInput;
    create: InventoryCreateInput;
    update: InventoryUpdateInput;
  }) => InventoryPromise;
  deleteInventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  deleteManyInventories: (where?: InventoryWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createMeasurementUnit: (
    data: MeasurementUnitCreateInput
  ) => MeasurementUnitPromise;
  updateMeasurementUnit: (args: {
    data: MeasurementUnitUpdateInput;
    where: MeasurementUnitWhereUniqueInput;
  }) => MeasurementUnitPromise;
  updateManyMeasurementUnits: (args: {
    data: MeasurementUnitUpdateManyMutationInput;
    where?: MeasurementUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertMeasurementUnit: (args: {
    where: MeasurementUnitWhereUniqueInput;
    create: MeasurementUnitCreateInput;
    update: MeasurementUnitUpdateInput;
  }) => MeasurementUnitPromise;
  deleteMeasurementUnit: (
    where: MeasurementUnitWhereUniqueInput
  ) => MeasurementUnitPromise;
  deleteManyMeasurementUnits: (
    where?: MeasurementUnitWhereInput
  ) => BatchPayloadPromise;
  createMerchandise: (data: MerchandiseCreateInput) => MerchandisePromise;
  updateMerchandise: (args: {
    data: MerchandiseUpdateInput;
    where: MerchandiseWhereUniqueInput;
  }) => MerchandisePromise;
  updateManyMerchandises: (args: {
    data: MerchandiseUpdateManyMutationInput;
    where?: MerchandiseWhereInput;
  }) => BatchPayloadPromise;
  upsertMerchandise: (args: {
    where: MerchandiseWhereUniqueInput;
    create: MerchandiseCreateInput;
    update: MerchandiseUpdateInput;
  }) => MerchandisePromise;
  deleteMerchandise: (where: MerchandiseWhereUniqueInput) => MerchandisePromise;
  deleteManyMerchandises: (
    where?: MerchandiseWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  currency: (
    where?: CurrencySubscriptionWhereInput
  ) => CurrencySubscriptionPayloadSubscription;
  expenseUnit: (
    where?: ExpenseUnitSubscriptionWhereInput
  ) => ExpenseUnitSubscriptionPayloadSubscription;
  expenseUnitCategory: (
    where?: ExpenseUnitCategorySubscriptionWhereInput
  ) => ExpenseUnitCategorySubscriptionPayloadSubscription;
  inventory: (
    where?: InventorySubscriptionWhereInput
  ) => InventorySubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  measurementUnit: (
    where?: MeasurementUnitSubscriptionWhereInput
  ) => MeasurementUnitSubscriptionPayloadSubscription;
  merchandise: (
    where?: MerchandiseSubscriptionWhereInput
  ) => MerchandiseSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CurrencyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "symbol_ASC"
  | "symbol_DESC"
  | "isDefault_ASC"
  | "isDefault_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ItemOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type ExpenseUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ExpenseUnitCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type InventoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MeasurementUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "symbol_ASC"
  | "symbol_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MerchandiseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CurrencyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CurrencyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  symbol?: Maybe<String>;
  symbol_not?: Maybe<String>;
  symbol_in?: Maybe<String[] | String>;
  symbol_not_in?: Maybe<String[] | String>;
  symbol_lt?: Maybe<String>;
  symbol_lte?: Maybe<String>;
  symbol_gt?: Maybe<String>;
  symbol_gte?: Maybe<String>;
  symbol_contains?: Maybe<String>;
  symbol_not_contains?: Maybe<String>;
  symbol_starts_with?: Maybe<String>;
  symbol_not_starts_with?: Maybe<String>;
  symbol_ends_with?: Maybe<String>;
  symbol_not_ends_with?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
  isDefault_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
  OR?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
  NOT?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
}

export type ExpenseUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface ExpenseUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  currency?: Maybe<CurrencyWhereInput>;
  item_every?: Maybe<ItemWhereInput>;
  item_some?: Maybe<ItemWhereInput>;
  item_none?: Maybe<ItemWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExpenseUnitWhereInput[] | ExpenseUnitWhereInput>;
  OR?: Maybe<ExpenseUnitWhereInput[] | ExpenseUnitWhereInput>;
  NOT?: Maybe<ExpenseUnitWhereInput[] | ExpenseUnitWhereInput>;
}

export type ExpenseUnitCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface ExpenseUnitCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ExpenseUnitCategoryWhereInput[] | ExpenseUnitCategoryWhereInput>;
  OR?: Maybe<ExpenseUnitCategoryWhereInput[] | ExpenseUnitCategoryWhereInput>;
  NOT?: Maybe<ExpenseUnitCategoryWhereInput[] | ExpenseUnitCategoryWhereInput>;
}

export type InventoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface InventoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<String>;
  quantity_not?: Maybe<String>;
  quantity_in?: Maybe<String[] | String>;
  quantity_not_in?: Maybe<String[] | String>;
  quantity_lt?: Maybe<String>;
  quantity_lte?: Maybe<String>;
  quantity_gt?: Maybe<String>;
  quantity_gte?: Maybe<String>;
  quantity_contains?: Maybe<String>;
  quantity_not_contains?: Maybe<String>;
  quantity_starts_with?: Maybe<String>;
  quantity_not_starts_with?: Maybe<String>;
  quantity_ends_with?: Maybe<String>;
  quantity_not_ends_with?: Maybe<String>;
  unit?: Maybe<MeasurementUnitWhereInput>;
  item_every?: Maybe<ItemWhereInput>;
  item_some?: Maybe<ItemWhereInput>;
  item_none?: Maybe<ItemWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
  OR?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
  NOT?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
}

export interface MeasurementUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  symbol?: Maybe<String>;
  symbol_not?: Maybe<String>;
  symbol_in?: Maybe<String[] | String>;
  symbol_not_in?: Maybe<String[] | String>;
  symbol_lt?: Maybe<String>;
  symbol_lte?: Maybe<String>;
  symbol_gt?: Maybe<String>;
  symbol_gte?: Maybe<String>;
  symbol_contains?: Maybe<String>;
  symbol_not_contains?: Maybe<String>;
  symbol_starts_with?: Maybe<String>;
  symbol_not_starts_with?: Maybe<String>;
  symbol_ends_with?: Maybe<String>;
  symbol_not_ends_with?: Maybe<String>;
  AND?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
  OR?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
  NOT?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MeasurementUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MerchandiseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface MerchandiseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<String>;
  quantity_not?: Maybe<String>;
  quantity_in?: Maybe<String[] | String>;
  quantity_not_in?: Maybe<String[] | String>;
  quantity_lt?: Maybe<String>;
  quantity_lte?: Maybe<String>;
  quantity_gt?: Maybe<String>;
  quantity_gte?: Maybe<String>;
  quantity_contains?: Maybe<String>;
  quantity_not_contains?: Maybe<String>;
  quantity_starts_with?: Maybe<String>;
  quantity_not_starts_with?: Maybe<String>;
  quantity_ends_with?: Maybe<String>;
  quantity_not_ends_with?: Maybe<String>;
  product_every?: Maybe<ProductWhereInput>;
  product_some?: Maybe<ProductWhereInput>;
  product_none?: Maybe<ProductWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MerchandiseWhereInput[] | MerchandiseWhereInput>;
  OR?: Maybe<MerchandiseWhereInput[] | MerchandiseWhereInput>;
  NOT?: Maybe<MerchandiseWhereInput[] | MerchandiseWhereInput>;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CurrencyCreateInput {
  id?: Maybe<ID_Input>;
  symbol: String;
  isDefault?: Maybe<Boolean>;
}

export interface CurrencyUpdateInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export interface CurrencyUpdateManyMutationInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export interface ExpenseUnitCreateInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  currency: CurrencyCreateOneInput;
  item?: Maybe<ItemCreateManyInput>;
}

export interface CurrencyCreateOneInput {
  create?: Maybe<CurrencyCreateInput>;
  connect?: Maybe<CurrencyWhereUniqueInput>;
}

export interface ItemCreateManyInput {
  create?: Maybe<ItemCreateInput[] | ItemCreateInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface ItemCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface ExpenseUnitUpdateInput {
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
  item?: Maybe<ItemUpdateManyInput>;
}

export interface CurrencyUpdateOneRequiredInput {
  create?: Maybe<CurrencyCreateInput>;
  update?: Maybe<CurrencyUpdateDataInput>;
  upsert?: Maybe<CurrencyUpsertNestedInput>;
  connect?: Maybe<CurrencyWhereUniqueInput>;
}

export interface CurrencyUpdateDataInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export interface CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput;
  create: CurrencyCreateInput;
}

export interface ItemUpdateManyInput {
  create?: Maybe<ItemCreateInput[] | ItemCreateInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueNestedInput[]
    | ItemUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueNestedInput[]
    | ItemUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateDataInput;
}

export interface ItemUpdateDataInput {
  name?: Maybe<String>;
}

export interface ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateDataInput;
  create: ItemCreateInput;
}

export interface ItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  OR?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  NOT?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface ItemUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface ExpenseUnitUpdateManyMutationInput {
  amount?: Maybe<String>;
}

export interface ExpenseUnitCategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ExpenseUnitCategoryUpdateInput {
  name?: Maybe<String>;
}

export interface ExpenseUnitCategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface InventoryCreateInput {
  id?: Maybe<ID_Input>;
  quantity?: Maybe<String>;
  unit: MeasurementUnitCreateOneInput;
  item?: Maybe<ItemCreateManyInput>;
}

export interface MeasurementUnitCreateOneInput {
  create?: Maybe<MeasurementUnitCreateInput>;
  connect?: Maybe<MeasurementUnitWhereUniqueInput>;
}

export interface MeasurementUnitCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  symbol: String;
}

export interface InventoryUpdateInput {
  quantity?: Maybe<String>;
  unit?: Maybe<MeasurementUnitUpdateOneRequiredInput>;
  item?: Maybe<ItemUpdateManyInput>;
}

export interface MeasurementUnitUpdateOneRequiredInput {
  create?: Maybe<MeasurementUnitCreateInput>;
  update?: Maybe<MeasurementUnitUpdateDataInput>;
  upsert?: Maybe<MeasurementUnitUpsertNestedInput>;
  connect?: Maybe<MeasurementUnitWhereUniqueInput>;
}

export interface MeasurementUnitUpdateDataInput {
  name?: Maybe<String>;
  symbol?: Maybe<String>;
}

export interface MeasurementUnitUpsertNestedInput {
  update: MeasurementUnitUpdateDataInput;
  create: MeasurementUnitCreateInput;
}

export interface InventoryUpdateManyMutationInput {
  quantity?: Maybe<String>;
}

export interface ItemUpdateInput {
  name?: Maybe<String>;
}

export interface ItemUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface MeasurementUnitUpdateInput {
  name?: Maybe<String>;
  symbol?: Maybe<String>;
}

export interface MeasurementUnitUpdateManyMutationInput {
  name?: Maybe<String>;
  symbol?: Maybe<String>;
}

export interface MerchandiseCreateInput {
  id?: Maybe<ID_Input>;
  quantity?: Maybe<String>;
  product?: Maybe<ProductCreateManyInput>;
}

export interface ProductCreateManyInput {
  create?: Maybe<ProductCreateInput[] | ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface MerchandiseUpdateInput {
  quantity?: Maybe<String>;
  product?: Maybe<ProductUpdateManyInput>;
}

export interface ProductUpdateManyInput {
  create?: Maybe<ProductCreateInput[] | ProductCreateInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueNestedInput[]
    | ProductUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueNestedInput[]
    | ProductUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateDataInput;
}

export interface ProductUpdateDataInput {
  name?: Maybe<String>;
}

export interface ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface ProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  OR?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  NOT?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface ProductUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface MerchandiseUpdateManyMutationInput {
  quantity?: Maybe<String>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CurrencySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CurrencyWhereInput>;
  AND?: Maybe<
    CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput
  >;
  OR?: Maybe<CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput>;
  NOT?: Maybe<
    CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput
  >;
}

export interface ExpenseUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpenseUnitWhereInput>;
  AND?: Maybe<
    ExpenseUnitSubscriptionWhereInput[] | ExpenseUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    ExpenseUnitSubscriptionWhereInput[] | ExpenseUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ExpenseUnitSubscriptionWhereInput[] | ExpenseUnitSubscriptionWhereInput
  >;
}

export interface ExpenseUnitCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpenseUnitCategoryWhereInput>;
  AND?: Maybe<
    | ExpenseUnitCategorySubscriptionWhereInput[]
    | ExpenseUnitCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | ExpenseUnitCategorySubscriptionWhereInput[]
    | ExpenseUnitCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ExpenseUnitCategorySubscriptionWhereInput[]
    | ExpenseUnitCategorySubscriptionWhereInput
  >;
}

export interface InventorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InventoryWhereInput>;
  AND?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
  OR?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface MeasurementUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MeasurementUnitWhereInput>;
  AND?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
}

export interface MerchandiseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MerchandiseWhereInput>;
  AND?: Maybe<
    MerchandiseSubscriptionWhereInput[] | MerchandiseSubscriptionWhereInput
  >;
  OR?: Maybe<
    MerchandiseSubscriptionWhereInput[] | MerchandiseSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MerchandiseSubscriptionWhereInput[] | MerchandiseSubscriptionWhereInput
  >;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Currency {
  id: ID_Output;
  symbol: String;
  isDefault?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CurrencyPromise extends Promise<Currency>, Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CurrencySubscription
  extends Promise<AsyncIterator<Currency>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<String>>;
  isDefault: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CurrencyNullablePromise
  extends Promise<Currency | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CurrencyConnection {
  pageInfo: PageInfo;
  edges: CurrencyEdge[];
}

export interface CurrencyConnectionPromise
  extends Promise<CurrencyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CurrencyEdge>>() => T;
  aggregate: <T = AggregateCurrencyPromise>() => T;
}

export interface CurrencyConnectionSubscription
  extends Promise<AsyncIterator<CurrencyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CurrencyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCurrencySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CurrencyEdge {
  node: Currency;
  cursor: String;
}

export interface CurrencyEdgePromise
  extends Promise<CurrencyEdge>,
    Fragmentable {
  node: <T = CurrencyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CurrencyEdgeSubscription
  extends Promise<AsyncIterator<CurrencyEdge>>,
    Fragmentable {
  node: <T = CurrencySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCurrency {
  count: Int;
}

export interface AggregateCurrencyPromise
  extends Promise<AggregateCurrency>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCurrencySubscription
  extends Promise<AsyncIterator<AggregateCurrency>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpenseUnit {
  id: ID_Output;
  amount: String;
  createdAt: DateTimeOutput;
}

export interface ExpenseUnitPromise extends Promise<ExpenseUnit>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  item: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ExpenseUnitSubscription
  extends Promise<AsyncIterator<ExpenseUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  currency: <T = CurrencySubscription>() => T;
  item: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpenseUnitNullablePromise
  extends Promise<ExpenseUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  item: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Item {
  id: ID_Output;
  name?: String;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ExpenseUnitConnection {
  pageInfo: PageInfo;
  edges: ExpenseUnitEdge[];
}

export interface ExpenseUnitConnectionPromise
  extends Promise<ExpenseUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpenseUnitEdge>>() => T;
  aggregate: <T = AggregateExpenseUnitPromise>() => T;
}

export interface ExpenseUnitConnectionSubscription
  extends Promise<AsyncIterator<ExpenseUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpenseUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpenseUnitSubscription>() => T;
}

export interface ExpenseUnitEdge {
  node: ExpenseUnit;
  cursor: String;
}

export interface ExpenseUnitEdgePromise
  extends Promise<ExpenseUnitEdge>,
    Fragmentable {
  node: <T = ExpenseUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpenseUnitEdgeSubscription
  extends Promise<AsyncIterator<ExpenseUnitEdge>>,
    Fragmentable {
  node: <T = ExpenseUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpenseUnit {
  count: Int;
}

export interface AggregateExpenseUnitPromise
  extends Promise<AggregateExpenseUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpenseUnitSubscription
  extends Promise<AsyncIterator<AggregateExpenseUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpenseUnitCategory {
  id: ID_Output;
  name: String;
}

export interface ExpenseUnitCategoryPromise
  extends Promise<ExpenseUnitCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ExpenseUnitCategorySubscription
  extends Promise<AsyncIterator<ExpenseUnitCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ExpenseUnitCategoryNullablePromise
  extends Promise<ExpenseUnitCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ExpenseUnitCategoryConnection {
  pageInfo: PageInfo;
  edges: ExpenseUnitCategoryEdge[];
}

export interface ExpenseUnitCategoryConnectionPromise
  extends Promise<ExpenseUnitCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpenseUnitCategoryEdge>>() => T;
  aggregate: <T = AggregateExpenseUnitCategoryPromise>() => T;
}

export interface ExpenseUnitCategoryConnectionSubscription
  extends Promise<AsyncIterator<ExpenseUnitCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExpenseUnitCategoryEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExpenseUnitCategorySubscription>() => T;
}

export interface ExpenseUnitCategoryEdge {
  node: ExpenseUnitCategory;
  cursor: String;
}

export interface ExpenseUnitCategoryEdgePromise
  extends Promise<ExpenseUnitCategoryEdge>,
    Fragmentable {
  node: <T = ExpenseUnitCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpenseUnitCategoryEdgeSubscription
  extends Promise<AsyncIterator<ExpenseUnitCategoryEdge>>,
    Fragmentable {
  node: <T = ExpenseUnitCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpenseUnitCategory {
  count: Int;
}

export interface AggregateExpenseUnitCategoryPromise
  extends Promise<AggregateExpenseUnitCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpenseUnitCategorySubscription
  extends Promise<AsyncIterator<AggregateExpenseUnitCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Inventory {
  id: ID_Output;
  quantity: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InventoryPromise extends Promise<Inventory>, Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<String>;
  unit: <T = MeasurementUnitPromise>() => T;
  item: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventorySubscription
  extends Promise<AsyncIterator<Inventory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<String>>;
  unit: <T = MeasurementUnitSubscription>() => T;
  item: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryNullablePromise
  extends Promise<Inventory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<String>;
  unit: <T = MeasurementUnitPromise>() => T;
  item: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MeasurementUnit {
  id: ID_Output;
  name: String;
  symbol: String;
}

export interface MeasurementUnitPromise
  extends Promise<MeasurementUnit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  symbol: () => Promise<String>;
}

export interface MeasurementUnitSubscription
  extends Promise<AsyncIterator<MeasurementUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  symbol: () => Promise<AsyncIterator<String>>;
}

export interface MeasurementUnitNullablePromise
  extends Promise<MeasurementUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  symbol: () => Promise<String>;
}

export interface InventoryConnection {
  pageInfo: PageInfo;
  edges: InventoryEdge[];
}

export interface InventoryConnectionPromise
  extends Promise<InventoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryEdge>>() => T;
  aggregate: <T = AggregateInventoryPromise>() => T;
}

export interface InventoryConnectionSubscription
  extends Promise<AsyncIterator<InventoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventorySubscription>() => T;
}

export interface InventoryEdge {
  node: Inventory;
  cursor: String;
}

export interface InventoryEdgePromise
  extends Promise<InventoryEdge>,
    Fragmentable {
  node: <T = InventoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryEdgeSubscription
  extends Promise<AsyncIterator<InventoryEdge>>,
    Fragmentable {
  node: <T = InventorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInventory {
  count: Int;
}

export interface AggregateInventoryPromise
  extends Promise<AggregateInventory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventorySubscription
  extends Promise<AsyncIterator<AggregateInventory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MeasurementUnitConnection {
  pageInfo: PageInfo;
  edges: MeasurementUnitEdge[];
}

export interface MeasurementUnitConnectionPromise
  extends Promise<MeasurementUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MeasurementUnitEdge>>() => T;
  aggregate: <T = AggregateMeasurementUnitPromise>() => T;
}

export interface MeasurementUnitConnectionSubscription
  extends Promise<AsyncIterator<MeasurementUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MeasurementUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMeasurementUnitSubscription>() => T;
}

export interface MeasurementUnitEdge {
  node: MeasurementUnit;
  cursor: String;
}

export interface MeasurementUnitEdgePromise
  extends Promise<MeasurementUnitEdge>,
    Fragmentable {
  node: <T = MeasurementUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MeasurementUnitEdgeSubscription
  extends Promise<AsyncIterator<MeasurementUnitEdge>>,
    Fragmentable {
  node: <T = MeasurementUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMeasurementUnit {
  count: Int;
}

export interface AggregateMeasurementUnitPromise
  extends Promise<AggregateMeasurementUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMeasurementUnitSubscription
  extends Promise<AsyncIterator<AggregateMeasurementUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Merchandise {
  id: ID_Output;
  quantity: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MerchandisePromise extends Promise<Merchandise>, Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<String>;
  product: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MerchandiseSubscription
  extends Promise<AsyncIterator<Merchandise>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<String>>;
  product: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MerchandiseNullablePromise
  extends Promise<Merchandise | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<String>;
  product: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Product {
  id: ID_Output;
  name?: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface MerchandiseConnection {
  pageInfo: PageInfo;
  edges: MerchandiseEdge[];
}

export interface MerchandiseConnectionPromise
  extends Promise<MerchandiseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MerchandiseEdge>>() => T;
  aggregate: <T = AggregateMerchandisePromise>() => T;
}

export interface MerchandiseConnectionSubscription
  extends Promise<AsyncIterator<MerchandiseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MerchandiseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMerchandiseSubscription>() => T;
}

export interface MerchandiseEdge {
  node: Merchandise;
  cursor: String;
}

export interface MerchandiseEdgePromise
  extends Promise<MerchandiseEdge>,
    Fragmentable {
  node: <T = MerchandisePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MerchandiseEdgeSubscription
  extends Promise<AsyncIterator<MerchandiseEdge>>,
    Fragmentable {
  node: <T = MerchandiseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMerchandise {
  count: Int;
}

export interface AggregateMerchandisePromise
  extends Promise<AggregateMerchandise>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMerchandiseSubscription
  extends Promise<AsyncIterator<AggregateMerchandise>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CurrencySubscriptionPayload {
  mutation: MutationType;
  node: Currency;
  updatedFields: String[];
  previousValues: CurrencyPreviousValues;
}

export interface CurrencySubscriptionPayloadPromise
  extends Promise<CurrencySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CurrencyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CurrencyPreviousValuesPromise>() => T;
}

export interface CurrencySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CurrencySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CurrencySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CurrencyPreviousValuesSubscription>() => T;
}

export interface CurrencyPreviousValues {
  id: ID_Output;
  symbol: String;
  isDefault?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CurrencyPreviousValuesPromise
  extends Promise<CurrencyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CurrencyPreviousValuesSubscription
  extends Promise<AsyncIterator<CurrencyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<String>>;
  isDefault: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpenseUnitSubscriptionPayload {
  mutation: MutationType;
  node: ExpenseUnit;
  updatedFields: String[];
  previousValues: ExpenseUnitPreviousValues;
}

export interface ExpenseUnitSubscriptionPayloadPromise
  extends Promise<ExpenseUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpenseUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpenseUnitPreviousValuesPromise>() => T;
}

export interface ExpenseUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpenseUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpenseUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpenseUnitPreviousValuesSubscription>() => T;
}

export interface ExpenseUnitPreviousValues {
  id: ID_Output;
  amount: String;
  createdAt: DateTimeOutput;
}

export interface ExpenseUnitPreviousValuesPromise
  extends Promise<ExpenseUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ExpenseUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<ExpenseUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpenseUnitCategorySubscriptionPayload {
  mutation: MutationType;
  node: ExpenseUnitCategory;
  updatedFields: String[];
  previousValues: ExpenseUnitCategoryPreviousValues;
}

export interface ExpenseUnitCategorySubscriptionPayloadPromise
  extends Promise<ExpenseUnitCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpenseUnitCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpenseUnitCategoryPreviousValuesPromise>() => T;
}

export interface ExpenseUnitCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpenseUnitCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpenseUnitCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpenseUnitCategoryPreviousValuesSubscription>() => T;
}

export interface ExpenseUnitCategoryPreviousValues {
  id: ID_Output;
  name: String;
}

export interface ExpenseUnitCategoryPreviousValuesPromise
  extends Promise<ExpenseUnitCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ExpenseUnitCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ExpenseUnitCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface InventorySubscriptionPayload {
  mutation: MutationType;
  node: Inventory;
  updatedFields: String[];
  previousValues: InventoryPreviousValues;
}

export interface InventorySubscriptionPayloadPromise
  extends Promise<InventorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryPreviousValuesPromise>() => T;
}

export interface InventorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryPreviousValuesSubscription>() => T;
}

export interface InventoryPreviousValues {
  id: ID_Output;
  quantity: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InventoryPreviousValuesPromise
  extends Promise<InventoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventoryPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface MeasurementUnitSubscriptionPayload {
  mutation: MutationType;
  node: MeasurementUnit;
  updatedFields: String[];
  previousValues: MeasurementUnitPreviousValues;
}

export interface MeasurementUnitSubscriptionPayloadPromise
  extends Promise<MeasurementUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MeasurementUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MeasurementUnitPreviousValuesPromise>() => T;
}

export interface MeasurementUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MeasurementUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MeasurementUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MeasurementUnitPreviousValuesSubscription>() => T;
}

export interface MeasurementUnitPreviousValues {
  id: ID_Output;
  name: String;
  symbol: String;
}

export interface MeasurementUnitPreviousValuesPromise
  extends Promise<MeasurementUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  symbol: () => Promise<String>;
}

export interface MeasurementUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<MeasurementUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  symbol: () => Promise<AsyncIterator<String>>;
}

export interface MerchandiseSubscriptionPayload {
  mutation: MutationType;
  node: Merchandise;
  updatedFields: String[];
  previousValues: MerchandisePreviousValues;
}

export interface MerchandiseSubscriptionPayloadPromise
  extends Promise<MerchandiseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MerchandisePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MerchandisePreviousValuesPromise>() => T;
}

export interface MerchandiseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MerchandiseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MerchandiseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MerchandisePreviousValuesSubscription>() => T;
}

export interface MerchandisePreviousValues {
  id: ID_Output;
  quantity: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MerchandisePreviousValuesPromise
  extends Promise<MerchandisePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MerchandisePreviousValuesSubscription
  extends Promise<AsyncIterator<MerchandisePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "ExpenseUnit",
    embedded: false
  },
  {
    name: "ExpenseUnitCategory",
    embedded: false
  },
  {
    name: "Inventory",
    embedded: false
  },
  {
    name: "Merchandise",
    embedded: false
  },
  {
    name: "MeasurementUnit",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Currency",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
