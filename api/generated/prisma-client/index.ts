// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  component: (where?: ComponentWhereInput) => Promise<boolean>;
  currency: (where?: CurrencyWhereInput) => Promise<boolean>;
  expenseUnit: (where?: ExpenseUnitWhereInput) => Promise<boolean>;
  inventory: (where?: InventoryWhereInput) => Promise<boolean>;
  inventoryUnit: (where?: InventoryUnitWhereInput) => Promise<boolean>;
  measurementUnit: (where?: MeasurementUnitWhereInput) => Promise<boolean>;
  stockUnit: (where?: StockUnitWhereInput) => Promise<boolean>;
  stockUnitCategory: (where?: StockUnitCategoryWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  component: (where: ComponentWhereUniqueInput) => ComponentNullablePromise;
  components: (args?: {
    where?: ComponentWhereInput;
    orderBy?: ComponentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Component>;
  componentsConnection: (args?: {
    where?: ComponentWhereInput;
    orderBy?: ComponentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ComponentConnectionPromise;
  currency: (where: CurrencyWhereUniqueInput) => CurrencyNullablePromise;
  currencies: (args?: {
    where?: CurrencyWhereInput;
    orderBy?: CurrencyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Currency>;
  currenciesConnection: (args?: {
    where?: CurrencyWhereInput;
    orderBy?: CurrencyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CurrencyConnectionPromise;
  expenseUnit: (
    where: ExpenseUnitWhereUniqueInput
  ) => ExpenseUnitNullablePromise;
  expenseUnits: (args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExpenseUnit>;
  expenseUnitsConnection: (args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpenseUnitConnectionPromise;
  inventory: (where: InventoryWhereUniqueInput) => InventoryNullablePromise;
  inventories: (args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Inventory>;
  inventoriesConnection: (args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InventoryConnectionPromise;
  inventoryUnit: (
    where: InventoryUnitWhereUniqueInput
  ) => InventoryUnitNullablePromise;
  inventoryUnits: (args?: {
    where?: InventoryUnitWhereInput;
    orderBy?: InventoryUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<InventoryUnit>;
  inventoryUnitsConnection: (args?: {
    where?: InventoryUnitWhereInput;
    orderBy?: InventoryUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InventoryUnitConnectionPromise;
  measurementUnit: (
    where: MeasurementUnitWhereUniqueInput
  ) => MeasurementUnitNullablePromise;
  measurementUnits: (args?: {
    where?: MeasurementUnitWhereInput;
    orderBy?: MeasurementUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MeasurementUnit>;
  measurementUnitsConnection: (args?: {
    where?: MeasurementUnitWhereInput;
    orderBy?: MeasurementUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MeasurementUnitConnectionPromise;
  stockUnit: (where: StockUnitWhereUniqueInput) => StockUnitNullablePromise;
  stockUnits: (args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StockUnit>;
  stockUnitsConnection: (args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StockUnitConnectionPromise;
  stockUnitCategory: (
    where: StockUnitCategoryWhereUniqueInput
  ) => StockUnitCategoryNullablePromise;
  stockUnitCategories: (args?: {
    where?: StockUnitCategoryWhereInput;
    orderBy?: StockUnitCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StockUnitCategory>;
  stockUnitCategoriesConnection: (args?: {
    where?: StockUnitCategoryWhereInput;
    orderBy?: StockUnitCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StockUnitCategoryConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createComponent: (data: ComponentCreateInput) => ComponentPromise;
  updateComponent: (args: {
    data: ComponentUpdateInput;
    where: ComponentWhereUniqueInput;
  }) => ComponentPromise;
  upsertComponent: (args: {
    where: ComponentWhereUniqueInput;
    create: ComponentCreateInput;
    update: ComponentUpdateInput;
  }) => ComponentPromise;
  deleteComponent: (where: ComponentWhereUniqueInput) => ComponentPromise;
  deleteManyComponents: (where?: ComponentWhereInput) => BatchPayloadPromise;
  createCurrency: (data: CurrencyCreateInput) => CurrencyPromise;
  updateCurrency: (args: {
    data: CurrencyUpdateInput;
    where: CurrencyWhereUniqueInput;
  }) => CurrencyPromise;
  updateManyCurrencies: (args: {
    data: CurrencyUpdateManyMutationInput;
    where?: CurrencyWhereInput;
  }) => BatchPayloadPromise;
  upsertCurrency: (args: {
    where: CurrencyWhereUniqueInput;
    create: CurrencyCreateInput;
    update: CurrencyUpdateInput;
  }) => CurrencyPromise;
  deleteCurrency: (where: CurrencyWhereUniqueInput) => CurrencyPromise;
  deleteManyCurrencies: (where?: CurrencyWhereInput) => BatchPayloadPromise;
  createExpenseUnit: (data: ExpenseUnitCreateInput) => ExpenseUnitPromise;
  updateExpenseUnit: (args: {
    data: ExpenseUnitUpdateInput;
    where: ExpenseUnitWhereUniqueInput;
  }) => ExpenseUnitPromise;
  updateManyExpenseUnits: (args: {
    data: ExpenseUnitUpdateManyMutationInput;
    where?: ExpenseUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertExpenseUnit: (args: {
    where: ExpenseUnitWhereUniqueInput;
    create: ExpenseUnitCreateInput;
    update: ExpenseUnitUpdateInput;
  }) => ExpenseUnitPromise;
  deleteExpenseUnit: (where: ExpenseUnitWhereUniqueInput) => ExpenseUnitPromise;
  deleteManyExpenseUnits: (
    where?: ExpenseUnitWhereInput
  ) => BatchPayloadPromise;
  createInventory: (data: InventoryCreateInput) => InventoryPromise;
  updateInventory: (args: {
    data: InventoryUpdateInput;
    where: InventoryWhereUniqueInput;
  }) => InventoryPromise;
  upsertInventory: (args: {
    where: InventoryWhereUniqueInput;
    create: InventoryCreateInput;
    update: InventoryUpdateInput;
  }) => InventoryPromise;
  deleteInventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  deleteManyInventories: (where?: InventoryWhereInput) => BatchPayloadPromise;
  createInventoryUnit: (data: InventoryUnitCreateInput) => InventoryUnitPromise;
  updateInventoryUnit: (args: {
    data: InventoryUnitUpdateInput;
    where: InventoryUnitWhereUniqueInput;
  }) => InventoryUnitPromise;
  updateManyInventoryUnits: (args: {
    data: InventoryUnitUpdateManyMutationInput;
    where?: InventoryUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertInventoryUnit: (args: {
    where: InventoryUnitWhereUniqueInput;
    create: InventoryUnitCreateInput;
    update: InventoryUnitUpdateInput;
  }) => InventoryUnitPromise;
  deleteInventoryUnit: (
    where: InventoryUnitWhereUniqueInput
  ) => InventoryUnitPromise;
  deleteManyInventoryUnits: (
    where?: InventoryUnitWhereInput
  ) => BatchPayloadPromise;
  createMeasurementUnit: (
    data: MeasurementUnitCreateInput
  ) => MeasurementUnitPromise;
  updateMeasurementUnit: (args: {
    data: MeasurementUnitUpdateInput;
    where: MeasurementUnitWhereUniqueInput;
  }) => MeasurementUnitPromise;
  updateManyMeasurementUnits: (args: {
    data: MeasurementUnitUpdateManyMutationInput;
    where?: MeasurementUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertMeasurementUnit: (args: {
    where: MeasurementUnitWhereUniqueInput;
    create: MeasurementUnitCreateInput;
    update: MeasurementUnitUpdateInput;
  }) => MeasurementUnitPromise;
  deleteMeasurementUnit: (
    where: MeasurementUnitWhereUniqueInput
  ) => MeasurementUnitPromise;
  deleteManyMeasurementUnits: (
    where?: MeasurementUnitWhereInput
  ) => BatchPayloadPromise;
  createStockUnit: (data: StockUnitCreateInput) => StockUnitPromise;
  updateStockUnit: (args: {
    data: StockUnitUpdateInput;
    where: StockUnitWhereUniqueInput;
  }) => StockUnitPromise;
  updateManyStockUnits: (args: {
    data: StockUnitUpdateManyMutationInput;
    where?: StockUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertStockUnit: (args: {
    where: StockUnitWhereUniqueInput;
    create: StockUnitCreateInput;
    update: StockUnitUpdateInput;
  }) => StockUnitPromise;
  deleteStockUnit: (where: StockUnitWhereUniqueInput) => StockUnitPromise;
  deleteManyStockUnits: (where?: StockUnitWhereInput) => BatchPayloadPromise;
  createStockUnitCategory: (
    data: StockUnitCategoryCreateInput
  ) => StockUnitCategoryPromise;
  updateStockUnitCategory: (args: {
    data: StockUnitCategoryUpdateInput;
    where: StockUnitCategoryWhereUniqueInput;
  }) => StockUnitCategoryPromise;
  updateManyStockUnitCategories: (args: {
    data: StockUnitCategoryUpdateManyMutationInput;
    where?: StockUnitCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertStockUnitCategory: (args: {
    where: StockUnitCategoryWhereUniqueInput;
    create: StockUnitCategoryCreateInput;
    update: StockUnitCategoryUpdateInput;
  }) => StockUnitCategoryPromise;
  deleteStockUnitCategory: (
    where: StockUnitCategoryWhereUniqueInput
  ) => StockUnitCategoryPromise;
  deleteManyStockUnitCategories: (
    where?: StockUnitCategoryWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  component: (
    where?: ComponentSubscriptionWhereInput
  ) => ComponentSubscriptionPayloadSubscription;
  currency: (
    where?: CurrencySubscriptionWhereInput
  ) => CurrencySubscriptionPayloadSubscription;
  expenseUnit: (
    where?: ExpenseUnitSubscriptionWhereInput
  ) => ExpenseUnitSubscriptionPayloadSubscription;
  inventory: (
    where?: InventorySubscriptionWhereInput
  ) => InventorySubscriptionPayloadSubscription;
  inventoryUnit: (
    where?: InventoryUnitSubscriptionWhereInput
  ) => InventoryUnitSubscriptionPayloadSubscription;
  measurementUnit: (
    where?: MeasurementUnitSubscriptionWhereInput
  ) => MeasurementUnitSubscriptionPayloadSubscription;
  stockUnit: (
    where?: StockUnitSubscriptionWhereInput
  ) => StockUnitSubscriptionPayloadSubscription;
  stockUnitCategory: (
    where?: StockUnitCategorySubscriptionWhereInput
  ) => StockUnitCategorySubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type InventoryUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "expiresAt_ASC"
  | "expiresAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExpenseUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ComponentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CurrencyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "symbol_ASC"
  | "symbol_DESC"
  | "isDefault_ASC"
  | "isDefault_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type InventoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MeasurementUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "symbol_ASC"
  | "symbol_DESC";

export type StockUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type StockUnitCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ComponentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface InventoryUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  inventory?: Maybe<InventoryWhereInput>;
  quantity?: Maybe<String>;
  quantity_not?: Maybe<String>;
  quantity_in?: Maybe<String[] | String>;
  quantity_not_in?: Maybe<String[] | String>;
  quantity_lt?: Maybe<String>;
  quantity_lte?: Maybe<String>;
  quantity_gt?: Maybe<String>;
  quantity_gte?: Maybe<String>;
  quantity_contains?: Maybe<String>;
  quantity_not_contains?: Maybe<String>;
  quantity_starts_with?: Maybe<String>;
  quantity_not_starts_with?: Maybe<String>;
  quantity_ends_with?: Maybe<String>;
  quantity_not_ends_with?: Maybe<String>;
  unit?: Maybe<MeasurementUnitWhereInput>;
  expenseUnit?: Maybe<ExpenseUnitWhereInput>;
  stockUnit?: Maybe<StockUnitWhereInput>;
  expiresAt?: Maybe<DateTimeInput>;
  expiresAt_not?: Maybe<DateTimeInput>;
  expiresAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiresAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiresAt_lt?: Maybe<DateTimeInput>;
  expiresAt_lte?: Maybe<DateTimeInput>;
  expiresAt_gt?: Maybe<DateTimeInput>;
  expiresAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InventoryUnitWhereInput[] | InventoryUnitWhereInput>;
  OR?: Maybe<InventoryUnitWhereInput[] | InventoryUnitWhereInput>;
  NOT?: Maybe<InventoryUnitWhereInput[] | InventoryUnitWhereInput>;
}

export interface InventoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  inventoryUnits_every?: Maybe<InventoryUnitWhereInput>;
  inventoryUnits_some?: Maybe<InventoryUnitWhereInput>;
  inventoryUnits_none?: Maybe<InventoryUnitWhereInput>;
  AND?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
  OR?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
  NOT?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
}

export interface MeasurementUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  symbol?: Maybe<String>;
  symbol_not?: Maybe<String>;
  symbol_in?: Maybe<String[] | String>;
  symbol_not_in?: Maybe<String[] | String>;
  symbol_lt?: Maybe<String>;
  symbol_lte?: Maybe<String>;
  symbol_gt?: Maybe<String>;
  symbol_gte?: Maybe<String>;
  symbol_contains?: Maybe<String>;
  symbol_not_contains?: Maybe<String>;
  symbol_starts_with?: Maybe<String>;
  symbol_not_starts_with?: Maybe<String>;
  symbol_ends_with?: Maybe<String>;
  symbol_not_ends_with?: Maybe<String>;
  AND?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
  OR?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
  NOT?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
}

export interface ExpenseUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  currency?: Maybe<CurrencyWhereInput>;
  stockUnit?: Maybe<StockUnitWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExpenseUnitWhereInput[] | ExpenseUnitWhereInput>;
  OR?: Maybe<ExpenseUnitWhereInput[] | ExpenseUnitWhereInput>;
  NOT?: Maybe<ExpenseUnitWhereInput[] | ExpenseUnitWhereInput>;
}

export interface CurrencyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  symbol?: Maybe<String>;
  symbol_not?: Maybe<String>;
  symbol_in?: Maybe<String[] | String>;
  symbol_not_in?: Maybe<String[] | String>;
  symbol_lt?: Maybe<String>;
  symbol_lte?: Maybe<String>;
  symbol_gt?: Maybe<String>;
  symbol_gte?: Maybe<String>;
  symbol_contains?: Maybe<String>;
  symbol_not_contains?: Maybe<String>;
  symbol_starts_with?: Maybe<String>;
  symbol_not_starts_with?: Maybe<String>;
  symbol_ends_with?: Maybe<String>;
  symbol_not_ends_with?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
  isDefault_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
  OR?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
  NOT?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
}

export interface StockUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  category?: Maybe<StockUnitCategoryWhereInput>;
  inventoryUnits_every?: Maybe<InventoryUnitWhereInput>;
  inventoryUnits_some?: Maybe<InventoryUnitWhereInput>;
  inventoryUnits_none?: Maybe<InventoryUnitWhereInput>;
  expenseUnits_every?: Maybe<ExpenseUnitWhereInput>;
  expenseUnits_some?: Maybe<ExpenseUnitWhereInput>;
  expenseUnits_none?: Maybe<ExpenseUnitWhereInput>;
  components_every?: Maybe<ComponentWhereInput>;
  components_some?: Maybe<ComponentWhereInput>;
  components_none?: Maybe<ComponentWhereInput>;
  AND?: Maybe<StockUnitWhereInput[] | StockUnitWhereInput>;
  OR?: Maybe<StockUnitWhereInput[] | StockUnitWhereInput>;
  NOT?: Maybe<StockUnitWhereInput[] | StockUnitWhereInput>;
}

export interface StockUnitCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<StockUnitCategoryWhereInput[] | StockUnitCategoryWhereInput>;
  OR?: Maybe<StockUnitCategoryWhereInput[] | StockUnitCategoryWhereInput>;
  NOT?: Maybe<StockUnitCategoryWhereInput[] | StockUnitCategoryWhereInput>;
}

export interface ComponentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  stockUnit?: Maybe<StockUnitWhereInput>;
  inventoryUnit?: Maybe<InventoryUnitWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ComponentWhereInput[] | ComponentWhereInput>;
  OR?: Maybe<ComponentWhereInput[] | ComponentWhereInput>;
  NOT?: Maybe<ComponentWhereInput[] | ComponentWhereInput>;
}

export type CurrencyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  symbol?: Maybe<String>;
}>;

export type ExpenseUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type InventoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type InventoryUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MeasurementUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
  symbol?: Maybe<String>;
}>;

export type StockUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type StockUnitCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface ComponentCreateInput {
  id?: Maybe<ID_Input>;
  stockUnit: StockUnitCreateOneWithoutComponentsInput;
  inventoryUnit?: Maybe<InventoryUnitCreateOneInput>;
}

export interface StockUnitCreateOneWithoutComponentsInput {
  create?: Maybe<StockUnitCreateWithoutComponentsInput>;
  connect?: Maybe<StockUnitWhereUniqueInput>;
}

export interface StockUnitCreateWithoutComponentsInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  category?: Maybe<StockUnitCategoryCreateOneInput>;
  inventoryUnits?: Maybe<InventoryUnitCreateManyWithoutStockUnitInput>;
  expenseUnits?: Maybe<ExpenseUnitCreateManyWithoutStockUnitInput>;
}

export interface StockUnitCategoryCreateOneInput {
  create?: Maybe<StockUnitCategoryCreateInput>;
  connect?: Maybe<StockUnitCategoryWhereUniqueInput>;
}

export interface StockUnitCategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface InventoryUnitCreateManyWithoutStockUnitInput {
  create?: Maybe<
    | InventoryUnitCreateWithoutStockUnitInput[]
    | InventoryUnitCreateWithoutStockUnitInput
  >;
  connect?: Maybe<
    InventoryUnitWhereUniqueInput[] | InventoryUnitWhereUniqueInput
  >;
}

export interface InventoryUnitCreateWithoutStockUnitInput {
  id?: Maybe<ID_Input>;
  inventory?: Maybe<InventoryCreateOneWithoutInventoryUnitsInput>;
  quantity?: Maybe<String>;
  unit: MeasurementUnitCreateOneInput;
  expenseUnit?: Maybe<ExpenseUnitCreateOneInput>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface InventoryCreateOneWithoutInventoryUnitsInput {
  create?: Maybe<InventoryCreateWithoutInventoryUnitsInput>;
  connect?: Maybe<InventoryWhereUniqueInput>;
}

export interface InventoryCreateWithoutInventoryUnitsInput {
  id?: Maybe<ID_Input>;
}

export interface MeasurementUnitCreateOneInput {
  create?: Maybe<MeasurementUnitCreateInput>;
  connect?: Maybe<MeasurementUnitWhereUniqueInput>;
}

export interface MeasurementUnitCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  symbol: String;
}

export interface ExpenseUnitCreateOneInput {
  create?: Maybe<ExpenseUnitCreateInput>;
  connect?: Maybe<ExpenseUnitWhereUniqueInput>;
}

export interface ExpenseUnitCreateInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  currency: CurrencyCreateOneInput;
  stockUnit: StockUnitCreateOneWithoutExpenseUnitsInput;
}

export interface CurrencyCreateOneInput {
  create?: Maybe<CurrencyCreateInput>;
  connect?: Maybe<CurrencyWhereUniqueInput>;
}

export interface CurrencyCreateInput {
  id?: Maybe<ID_Input>;
  symbol: String;
  isDefault?: Maybe<Boolean>;
}

export interface StockUnitCreateOneWithoutExpenseUnitsInput {
  create?: Maybe<StockUnitCreateWithoutExpenseUnitsInput>;
  connect?: Maybe<StockUnitWhereUniqueInput>;
}

export interface StockUnitCreateWithoutExpenseUnitsInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  category?: Maybe<StockUnitCategoryCreateOneInput>;
  inventoryUnits?: Maybe<InventoryUnitCreateManyWithoutStockUnitInput>;
  components?: Maybe<ComponentCreateManyWithoutStockUnitInput>;
}

export interface ComponentCreateManyWithoutStockUnitInput {
  create?: Maybe<
    | ComponentCreateWithoutStockUnitInput[]
    | ComponentCreateWithoutStockUnitInput
  >;
  connect?: Maybe<ComponentWhereUniqueInput[] | ComponentWhereUniqueInput>;
}

export interface ComponentCreateWithoutStockUnitInput {
  id?: Maybe<ID_Input>;
  inventoryUnit?: Maybe<InventoryUnitCreateOneInput>;
}

export interface InventoryUnitCreateOneInput {
  create?: Maybe<InventoryUnitCreateInput>;
  connect?: Maybe<InventoryUnitWhereUniqueInput>;
}

export interface InventoryUnitCreateInput {
  id?: Maybe<ID_Input>;
  inventory?: Maybe<InventoryCreateOneWithoutInventoryUnitsInput>;
  quantity?: Maybe<String>;
  unit: MeasurementUnitCreateOneInput;
  expenseUnit?: Maybe<ExpenseUnitCreateOneInput>;
  stockUnit?: Maybe<StockUnitCreateOneWithoutInventoryUnitsInput>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface StockUnitCreateOneWithoutInventoryUnitsInput {
  create?: Maybe<StockUnitCreateWithoutInventoryUnitsInput>;
  connect?: Maybe<StockUnitWhereUniqueInput>;
}

export interface StockUnitCreateWithoutInventoryUnitsInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  category?: Maybe<StockUnitCategoryCreateOneInput>;
  expenseUnits?: Maybe<ExpenseUnitCreateManyWithoutStockUnitInput>;
  components?: Maybe<ComponentCreateManyWithoutStockUnitInput>;
}

export interface ExpenseUnitCreateManyWithoutStockUnitInput {
  create?: Maybe<
    | ExpenseUnitCreateWithoutStockUnitInput[]
    | ExpenseUnitCreateWithoutStockUnitInput
  >;
  connect?: Maybe<ExpenseUnitWhereUniqueInput[] | ExpenseUnitWhereUniqueInput>;
}

export interface ExpenseUnitCreateWithoutStockUnitInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  currency: CurrencyCreateOneInput;
}

export interface ComponentUpdateInput {
  stockUnit?: Maybe<StockUnitUpdateOneRequiredWithoutComponentsInput>;
  inventoryUnit?: Maybe<InventoryUnitUpdateOneInput>;
}

export interface StockUnitUpdateOneRequiredWithoutComponentsInput {
  create?: Maybe<StockUnitCreateWithoutComponentsInput>;
  update?: Maybe<StockUnitUpdateWithoutComponentsDataInput>;
  upsert?: Maybe<StockUnitUpsertWithoutComponentsInput>;
  connect?: Maybe<StockUnitWhereUniqueInput>;
}

export interface StockUnitUpdateWithoutComponentsDataInput {
  name?: Maybe<String>;
  category?: Maybe<StockUnitCategoryUpdateOneInput>;
  inventoryUnits?: Maybe<InventoryUnitUpdateManyWithoutStockUnitInput>;
  expenseUnits?: Maybe<ExpenseUnitUpdateManyWithoutStockUnitInput>;
}

export interface StockUnitCategoryUpdateOneInput {
  create?: Maybe<StockUnitCategoryCreateInput>;
  update?: Maybe<StockUnitCategoryUpdateDataInput>;
  upsert?: Maybe<StockUnitCategoryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StockUnitCategoryWhereUniqueInput>;
}

export interface StockUnitCategoryUpdateDataInput {
  name?: Maybe<String>;
}

export interface StockUnitCategoryUpsertNestedInput {
  update: StockUnitCategoryUpdateDataInput;
  create: StockUnitCategoryCreateInput;
}

export interface InventoryUnitUpdateManyWithoutStockUnitInput {
  create?: Maybe<
    | InventoryUnitCreateWithoutStockUnitInput[]
    | InventoryUnitCreateWithoutStockUnitInput
  >;
  delete?: Maybe<
    InventoryUnitWhereUniqueInput[] | InventoryUnitWhereUniqueInput
  >;
  connect?: Maybe<
    InventoryUnitWhereUniqueInput[] | InventoryUnitWhereUniqueInput
  >;
  set?: Maybe<InventoryUnitWhereUniqueInput[] | InventoryUnitWhereUniqueInput>;
  disconnect?: Maybe<
    InventoryUnitWhereUniqueInput[] | InventoryUnitWhereUniqueInput
  >;
  update?: Maybe<
    | InventoryUnitUpdateWithWhereUniqueWithoutStockUnitInput[]
    | InventoryUnitUpdateWithWhereUniqueWithoutStockUnitInput
  >;
  upsert?: Maybe<
    | InventoryUnitUpsertWithWhereUniqueWithoutStockUnitInput[]
    | InventoryUnitUpsertWithWhereUniqueWithoutStockUnitInput
  >;
  deleteMany?: Maybe<
    InventoryUnitScalarWhereInput[] | InventoryUnitScalarWhereInput
  >;
  updateMany?: Maybe<
    | InventoryUnitUpdateManyWithWhereNestedInput[]
    | InventoryUnitUpdateManyWithWhereNestedInput
  >;
}

export interface InventoryUnitUpdateWithWhereUniqueWithoutStockUnitInput {
  where: InventoryUnitWhereUniqueInput;
  data: InventoryUnitUpdateWithoutStockUnitDataInput;
}

export interface InventoryUnitUpdateWithoutStockUnitDataInput {
  inventory?: Maybe<InventoryUpdateOneWithoutInventoryUnitsInput>;
  quantity?: Maybe<String>;
  unit?: Maybe<MeasurementUnitUpdateOneRequiredInput>;
  expenseUnit?: Maybe<ExpenseUnitUpdateOneInput>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface InventoryUpdateOneWithoutInventoryUnitsInput {
  create?: Maybe<InventoryCreateWithoutInventoryUnitsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<InventoryWhereUniqueInput>;
}

export interface MeasurementUnitUpdateOneRequiredInput {
  create?: Maybe<MeasurementUnitCreateInput>;
  update?: Maybe<MeasurementUnitUpdateDataInput>;
  upsert?: Maybe<MeasurementUnitUpsertNestedInput>;
  connect?: Maybe<MeasurementUnitWhereUniqueInput>;
}

export interface MeasurementUnitUpdateDataInput {
  name?: Maybe<String>;
  symbol?: Maybe<String>;
}

export interface MeasurementUnitUpsertNestedInput {
  update: MeasurementUnitUpdateDataInput;
  create: MeasurementUnitCreateInput;
}

export interface ExpenseUnitUpdateOneInput {
  create?: Maybe<ExpenseUnitCreateInput>;
  update?: Maybe<ExpenseUnitUpdateDataInput>;
  upsert?: Maybe<ExpenseUnitUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ExpenseUnitWhereUniqueInput>;
}

export interface ExpenseUnitUpdateDataInput {
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
  stockUnit?: Maybe<StockUnitUpdateOneRequiredWithoutExpenseUnitsInput>;
}

export interface CurrencyUpdateOneRequiredInput {
  create?: Maybe<CurrencyCreateInput>;
  update?: Maybe<CurrencyUpdateDataInput>;
  upsert?: Maybe<CurrencyUpsertNestedInput>;
  connect?: Maybe<CurrencyWhereUniqueInput>;
}

export interface CurrencyUpdateDataInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export interface CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput;
  create: CurrencyCreateInput;
}

export interface StockUnitUpdateOneRequiredWithoutExpenseUnitsInput {
  create?: Maybe<StockUnitCreateWithoutExpenseUnitsInput>;
  update?: Maybe<StockUnitUpdateWithoutExpenseUnitsDataInput>;
  upsert?: Maybe<StockUnitUpsertWithoutExpenseUnitsInput>;
  connect?: Maybe<StockUnitWhereUniqueInput>;
}

export interface StockUnitUpdateWithoutExpenseUnitsDataInput {
  name?: Maybe<String>;
  category?: Maybe<StockUnitCategoryUpdateOneInput>;
  inventoryUnits?: Maybe<InventoryUnitUpdateManyWithoutStockUnitInput>;
  components?: Maybe<ComponentUpdateManyWithoutStockUnitInput>;
}

export interface ComponentUpdateManyWithoutStockUnitInput {
  create?: Maybe<
    | ComponentCreateWithoutStockUnitInput[]
    | ComponentCreateWithoutStockUnitInput
  >;
  delete?: Maybe<ComponentWhereUniqueInput[] | ComponentWhereUniqueInput>;
  connect?: Maybe<ComponentWhereUniqueInput[] | ComponentWhereUniqueInput>;
  set?: Maybe<ComponentWhereUniqueInput[] | ComponentWhereUniqueInput>;
  disconnect?: Maybe<ComponentWhereUniqueInput[] | ComponentWhereUniqueInput>;
  update?: Maybe<
    | ComponentUpdateWithWhereUniqueWithoutStockUnitInput[]
    | ComponentUpdateWithWhereUniqueWithoutStockUnitInput
  >;
  upsert?: Maybe<
    | ComponentUpsertWithWhereUniqueWithoutStockUnitInput[]
    | ComponentUpsertWithWhereUniqueWithoutStockUnitInput
  >;
  deleteMany?: Maybe<ComponentScalarWhereInput[] | ComponentScalarWhereInput>;
}

export interface ComponentUpdateWithWhereUniqueWithoutStockUnitInput {
  where: ComponentWhereUniqueInput;
  data: ComponentUpdateWithoutStockUnitDataInput;
}

export interface ComponentUpdateWithoutStockUnitDataInput {
  inventoryUnit?: Maybe<InventoryUnitUpdateOneInput>;
}

export interface InventoryUnitUpdateOneInput {
  create?: Maybe<InventoryUnitCreateInput>;
  update?: Maybe<InventoryUnitUpdateDataInput>;
  upsert?: Maybe<InventoryUnitUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<InventoryUnitWhereUniqueInput>;
}

export interface InventoryUnitUpdateDataInput {
  inventory?: Maybe<InventoryUpdateOneWithoutInventoryUnitsInput>;
  quantity?: Maybe<String>;
  unit?: Maybe<MeasurementUnitUpdateOneRequiredInput>;
  expenseUnit?: Maybe<ExpenseUnitUpdateOneInput>;
  stockUnit?: Maybe<StockUnitUpdateOneWithoutInventoryUnitsInput>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface StockUnitUpdateOneWithoutInventoryUnitsInput {
  create?: Maybe<StockUnitCreateWithoutInventoryUnitsInput>;
  update?: Maybe<StockUnitUpdateWithoutInventoryUnitsDataInput>;
  upsert?: Maybe<StockUnitUpsertWithoutInventoryUnitsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StockUnitWhereUniqueInput>;
}

export interface StockUnitUpdateWithoutInventoryUnitsDataInput {
  name?: Maybe<String>;
  category?: Maybe<StockUnitCategoryUpdateOneInput>;
  expenseUnits?: Maybe<ExpenseUnitUpdateManyWithoutStockUnitInput>;
  components?: Maybe<ComponentUpdateManyWithoutStockUnitInput>;
}

export interface ExpenseUnitUpdateManyWithoutStockUnitInput {
  create?: Maybe<
    | ExpenseUnitCreateWithoutStockUnitInput[]
    | ExpenseUnitCreateWithoutStockUnitInput
  >;
  delete?: Maybe<ExpenseUnitWhereUniqueInput[] | ExpenseUnitWhereUniqueInput>;
  connect?: Maybe<ExpenseUnitWhereUniqueInput[] | ExpenseUnitWhereUniqueInput>;
  set?: Maybe<ExpenseUnitWhereUniqueInput[] | ExpenseUnitWhereUniqueInput>;
  disconnect?: Maybe<
    ExpenseUnitWhereUniqueInput[] | ExpenseUnitWhereUniqueInput
  >;
  update?: Maybe<
    | ExpenseUnitUpdateWithWhereUniqueWithoutStockUnitInput[]
    | ExpenseUnitUpdateWithWhereUniqueWithoutStockUnitInput
  >;
  upsert?: Maybe<
    | ExpenseUnitUpsertWithWhereUniqueWithoutStockUnitInput[]
    | ExpenseUnitUpsertWithWhereUniqueWithoutStockUnitInput
  >;
  deleteMany?: Maybe<
    ExpenseUnitScalarWhereInput[] | ExpenseUnitScalarWhereInput
  >;
  updateMany?: Maybe<
    | ExpenseUnitUpdateManyWithWhereNestedInput[]
    | ExpenseUnitUpdateManyWithWhereNestedInput
  >;
}

export interface ExpenseUnitUpdateWithWhereUniqueWithoutStockUnitInput {
  where: ExpenseUnitWhereUniqueInput;
  data: ExpenseUnitUpdateWithoutStockUnitDataInput;
}

export interface ExpenseUnitUpdateWithoutStockUnitDataInput {
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
}

export interface ExpenseUnitUpsertWithWhereUniqueWithoutStockUnitInput {
  where: ExpenseUnitWhereUniqueInput;
  update: ExpenseUnitUpdateWithoutStockUnitDataInput;
  create: ExpenseUnitCreateWithoutStockUnitInput;
}

export interface ExpenseUnitScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExpenseUnitScalarWhereInput[] | ExpenseUnitScalarWhereInput>;
  OR?: Maybe<ExpenseUnitScalarWhereInput[] | ExpenseUnitScalarWhereInput>;
  NOT?: Maybe<ExpenseUnitScalarWhereInput[] | ExpenseUnitScalarWhereInput>;
}

export interface ExpenseUnitUpdateManyWithWhereNestedInput {
  where: ExpenseUnitScalarWhereInput;
  data: ExpenseUnitUpdateManyDataInput;
}

export interface ExpenseUnitUpdateManyDataInput {
  amount?: Maybe<String>;
}

export interface StockUnitUpsertWithoutInventoryUnitsInput {
  update: StockUnitUpdateWithoutInventoryUnitsDataInput;
  create: StockUnitCreateWithoutInventoryUnitsInput;
}

export interface InventoryUnitUpsertNestedInput {
  update: InventoryUnitUpdateDataInput;
  create: InventoryUnitCreateInput;
}

export interface ComponentUpsertWithWhereUniqueWithoutStockUnitInput {
  where: ComponentWhereUniqueInput;
  update: ComponentUpdateWithoutStockUnitDataInput;
  create: ComponentCreateWithoutStockUnitInput;
}

export interface ComponentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ComponentScalarWhereInput[] | ComponentScalarWhereInput>;
  OR?: Maybe<ComponentScalarWhereInput[] | ComponentScalarWhereInput>;
  NOT?: Maybe<ComponentScalarWhereInput[] | ComponentScalarWhereInput>;
}

export interface StockUnitUpsertWithoutExpenseUnitsInput {
  update: StockUnitUpdateWithoutExpenseUnitsDataInput;
  create: StockUnitCreateWithoutExpenseUnitsInput;
}

export interface ExpenseUnitUpsertNestedInput {
  update: ExpenseUnitUpdateDataInput;
  create: ExpenseUnitCreateInput;
}

export interface InventoryUnitUpsertWithWhereUniqueWithoutStockUnitInput {
  where: InventoryUnitWhereUniqueInput;
  update: InventoryUnitUpdateWithoutStockUnitDataInput;
  create: InventoryUnitCreateWithoutStockUnitInput;
}

export interface InventoryUnitScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<String>;
  quantity_not?: Maybe<String>;
  quantity_in?: Maybe<String[] | String>;
  quantity_not_in?: Maybe<String[] | String>;
  quantity_lt?: Maybe<String>;
  quantity_lte?: Maybe<String>;
  quantity_gt?: Maybe<String>;
  quantity_gte?: Maybe<String>;
  quantity_contains?: Maybe<String>;
  quantity_not_contains?: Maybe<String>;
  quantity_starts_with?: Maybe<String>;
  quantity_not_starts_with?: Maybe<String>;
  quantity_ends_with?: Maybe<String>;
  quantity_not_ends_with?: Maybe<String>;
  expiresAt?: Maybe<DateTimeInput>;
  expiresAt_not?: Maybe<DateTimeInput>;
  expiresAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiresAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiresAt_lt?: Maybe<DateTimeInput>;
  expiresAt_lte?: Maybe<DateTimeInput>;
  expiresAt_gt?: Maybe<DateTimeInput>;
  expiresAt_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InventoryUnitScalarWhereInput[] | InventoryUnitScalarWhereInput>;
  OR?: Maybe<InventoryUnitScalarWhereInput[] | InventoryUnitScalarWhereInput>;
  NOT?: Maybe<InventoryUnitScalarWhereInput[] | InventoryUnitScalarWhereInput>;
}

export interface InventoryUnitUpdateManyWithWhereNestedInput {
  where: InventoryUnitScalarWhereInput;
  data: InventoryUnitUpdateManyDataInput;
}

export interface InventoryUnitUpdateManyDataInput {
  quantity?: Maybe<String>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface StockUnitUpsertWithoutComponentsInput {
  update: StockUnitUpdateWithoutComponentsDataInput;
  create: StockUnitCreateWithoutComponentsInput;
}

export interface CurrencyUpdateInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export interface CurrencyUpdateManyMutationInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export interface ExpenseUnitUpdateInput {
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
  stockUnit?: Maybe<StockUnitUpdateOneRequiredWithoutExpenseUnitsInput>;
}

export interface ExpenseUnitUpdateManyMutationInput {
  amount?: Maybe<String>;
}

export interface InventoryCreateInput {
  id?: Maybe<ID_Input>;
  inventoryUnits?: Maybe<InventoryUnitCreateManyWithoutInventoryInput>;
}

export interface InventoryUnitCreateManyWithoutInventoryInput {
  create?: Maybe<
    | InventoryUnitCreateWithoutInventoryInput[]
    | InventoryUnitCreateWithoutInventoryInput
  >;
  connect?: Maybe<
    InventoryUnitWhereUniqueInput[] | InventoryUnitWhereUniqueInput
  >;
}

export interface InventoryUnitCreateWithoutInventoryInput {
  id?: Maybe<ID_Input>;
  quantity?: Maybe<String>;
  unit: MeasurementUnitCreateOneInput;
  expenseUnit?: Maybe<ExpenseUnitCreateOneInput>;
  stockUnit?: Maybe<StockUnitCreateOneWithoutInventoryUnitsInput>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface InventoryUpdateInput {
  inventoryUnits?: Maybe<InventoryUnitUpdateManyWithoutInventoryInput>;
}

export interface InventoryUnitUpdateManyWithoutInventoryInput {
  create?: Maybe<
    | InventoryUnitCreateWithoutInventoryInput[]
    | InventoryUnitCreateWithoutInventoryInput
  >;
  delete?: Maybe<
    InventoryUnitWhereUniqueInput[] | InventoryUnitWhereUniqueInput
  >;
  connect?: Maybe<
    InventoryUnitWhereUniqueInput[] | InventoryUnitWhereUniqueInput
  >;
  set?: Maybe<InventoryUnitWhereUniqueInput[] | InventoryUnitWhereUniqueInput>;
  disconnect?: Maybe<
    InventoryUnitWhereUniqueInput[] | InventoryUnitWhereUniqueInput
  >;
  update?: Maybe<
    | InventoryUnitUpdateWithWhereUniqueWithoutInventoryInput[]
    | InventoryUnitUpdateWithWhereUniqueWithoutInventoryInput
  >;
  upsert?: Maybe<
    | InventoryUnitUpsertWithWhereUniqueWithoutInventoryInput[]
    | InventoryUnitUpsertWithWhereUniqueWithoutInventoryInput
  >;
  deleteMany?: Maybe<
    InventoryUnitScalarWhereInput[] | InventoryUnitScalarWhereInput
  >;
  updateMany?: Maybe<
    | InventoryUnitUpdateManyWithWhereNestedInput[]
    | InventoryUnitUpdateManyWithWhereNestedInput
  >;
}

export interface InventoryUnitUpdateWithWhereUniqueWithoutInventoryInput {
  where: InventoryUnitWhereUniqueInput;
  data: InventoryUnitUpdateWithoutInventoryDataInput;
}

export interface InventoryUnitUpdateWithoutInventoryDataInput {
  quantity?: Maybe<String>;
  unit?: Maybe<MeasurementUnitUpdateOneRequiredInput>;
  expenseUnit?: Maybe<ExpenseUnitUpdateOneInput>;
  stockUnit?: Maybe<StockUnitUpdateOneWithoutInventoryUnitsInput>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface InventoryUnitUpsertWithWhereUniqueWithoutInventoryInput {
  where: InventoryUnitWhereUniqueInput;
  update: InventoryUnitUpdateWithoutInventoryDataInput;
  create: InventoryUnitCreateWithoutInventoryInput;
}

export interface InventoryUnitUpdateInput {
  inventory?: Maybe<InventoryUpdateOneWithoutInventoryUnitsInput>;
  quantity?: Maybe<String>;
  unit?: Maybe<MeasurementUnitUpdateOneRequiredInput>;
  expenseUnit?: Maybe<ExpenseUnitUpdateOneInput>;
  stockUnit?: Maybe<StockUnitUpdateOneWithoutInventoryUnitsInput>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface InventoryUnitUpdateManyMutationInput {
  quantity?: Maybe<String>;
  expiresAt?: Maybe<DateTimeInput>;
}

export interface MeasurementUnitUpdateInput {
  name?: Maybe<String>;
  symbol?: Maybe<String>;
}

export interface MeasurementUnitUpdateManyMutationInput {
  name?: Maybe<String>;
  symbol?: Maybe<String>;
}

export interface StockUnitCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  category?: Maybe<StockUnitCategoryCreateOneInput>;
  inventoryUnits?: Maybe<InventoryUnitCreateManyWithoutStockUnitInput>;
  expenseUnits?: Maybe<ExpenseUnitCreateManyWithoutStockUnitInput>;
  components?: Maybe<ComponentCreateManyWithoutStockUnitInput>;
}

export interface StockUnitUpdateInput {
  name?: Maybe<String>;
  category?: Maybe<StockUnitCategoryUpdateOneInput>;
  inventoryUnits?: Maybe<InventoryUnitUpdateManyWithoutStockUnitInput>;
  expenseUnits?: Maybe<ExpenseUnitUpdateManyWithoutStockUnitInput>;
  components?: Maybe<ComponentUpdateManyWithoutStockUnitInput>;
}

export interface StockUnitUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface StockUnitCategoryUpdateInput {
  name?: Maybe<String>;
}

export interface StockUnitCategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ComponentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ComponentWhereInput>;
  AND?: Maybe<
    ComponentSubscriptionWhereInput[] | ComponentSubscriptionWhereInput
  >;
  OR?: Maybe<
    ComponentSubscriptionWhereInput[] | ComponentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ComponentSubscriptionWhereInput[] | ComponentSubscriptionWhereInput
  >;
}

export interface CurrencySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CurrencyWhereInput>;
  AND?: Maybe<
    CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput
  >;
  OR?: Maybe<CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput>;
  NOT?: Maybe<
    CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput
  >;
}

export interface ExpenseUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpenseUnitWhereInput>;
  AND?: Maybe<
    ExpenseUnitSubscriptionWhereInput[] | ExpenseUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    ExpenseUnitSubscriptionWhereInput[] | ExpenseUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ExpenseUnitSubscriptionWhereInput[] | ExpenseUnitSubscriptionWhereInput
  >;
}

export interface InventorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InventoryWhereInput>;
  AND?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
  OR?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
}

export interface InventoryUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InventoryUnitWhereInput>;
  AND?: Maybe<
    InventoryUnitSubscriptionWhereInput[] | InventoryUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    InventoryUnitSubscriptionWhereInput[] | InventoryUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    InventoryUnitSubscriptionWhereInput[] | InventoryUnitSubscriptionWhereInput
  >;
}

export interface MeasurementUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MeasurementUnitWhereInput>;
  AND?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
}

export interface StockUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StockUnitWhereInput>;
  AND?: Maybe<
    StockUnitSubscriptionWhereInput[] | StockUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    StockUnitSubscriptionWhereInput[] | StockUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    StockUnitSubscriptionWhereInput[] | StockUnitSubscriptionWhereInput
  >;
}

export interface StockUnitCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StockUnitCategoryWhereInput>;
  AND?: Maybe<
    | StockUnitCategorySubscriptionWhereInput[]
    | StockUnitCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | StockUnitCategorySubscriptionWhereInput[]
    | StockUnitCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | StockUnitCategorySubscriptionWhereInput[]
    | StockUnitCategorySubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Component {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ComponentPromise extends Promise<Component>, Fragmentable {
  id: () => Promise<ID_Output>;
  stockUnit: <T = StockUnitPromise>() => T;
  inventoryUnit: <T = InventoryUnitPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ComponentSubscription
  extends Promise<AsyncIterator<Component>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stockUnit: <T = StockUnitSubscription>() => T;
  inventoryUnit: <T = InventoryUnitSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ComponentNullablePromise
  extends Promise<Component | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  stockUnit: <T = StockUnitPromise>() => T;
  inventoryUnit: <T = InventoryUnitPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StockUnit {
  id: ID_Output;
  name?: String;
}

export interface StockUnitPromise extends Promise<StockUnit>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: <T = StockUnitCategoryPromise>() => T;
  inventoryUnits: <T = FragmentableArray<InventoryUnit>>(args?: {
    where?: InventoryUnitWhereInput;
    orderBy?: InventoryUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  expenseUnits: <T = FragmentableArray<ExpenseUnit>>(args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  components: <T = FragmentableArray<Component>>(args?: {
    where?: ComponentWhereInput;
    orderBy?: ComponentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StockUnitSubscription
  extends Promise<AsyncIterator<StockUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: <T = StockUnitCategorySubscription>() => T;
  inventoryUnits: <
    T = Promise<AsyncIterator<InventoryUnitSubscription>>
  >(args?: {
    where?: InventoryUnitWhereInput;
    orderBy?: InventoryUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  expenseUnits: <T = Promise<AsyncIterator<ExpenseUnitSubscription>>>(args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  components: <T = Promise<AsyncIterator<ComponentSubscription>>>(args?: {
    where?: ComponentWhereInput;
    orderBy?: ComponentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StockUnitNullablePromise
  extends Promise<StockUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: <T = StockUnitCategoryPromise>() => T;
  inventoryUnits: <T = FragmentableArray<InventoryUnit>>(args?: {
    where?: InventoryUnitWhereInput;
    orderBy?: InventoryUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  expenseUnits: <T = FragmentableArray<ExpenseUnit>>(args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  components: <T = FragmentableArray<Component>>(args?: {
    where?: ComponentWhereInput;
    orderBy?: ComponentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StockUnitCategory {
  id: ID_Output;
  name: String;
}

export interface StockUnitCategoryPromise
  extends Promise<StockUnitCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface StockUnitCategorySubscription
  extends Promise<AsyncIterator<StockUnitCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StockUnitCategoryNullablePromise
  extends Promise<StockUnitCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface InventoryUnit {
  id: ID_Output;
  quantity: String;
  expiresAt?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InventoryUnitPromise
  extends Promise<InventoryUnit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  inventory: <T = InventoryPromise>() => T;
  quantity: () => Promise<String>;
  unit: <T = MeasurementUnitPromise>() => T;
  expenseUnit: <T = ExpenseUnitPromise>() => T;
  stockUnit: <T = StockUnitPromise>() => T;
  expiresAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventoryUnitSubscription
  extends Promise<AsyncIterator<InventoryUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  inventory: <T = InventorySubscription>() => T;
  quantity: () => Promise<AsyncIterator<String>>;
  unit: <T = MeasurementUnitSubscription>() => T;
  expenseUnit: <T = ExpenseUnitSubscription>() => T;
  stockUnit: <T = StockUnitSubscription>() => T;
  expiresAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryUnitNullablePromise
  extends Promise<InventoryUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  inventory: <T = InventoryPromise>() => T;
  quantity: () => Promise<String>;
  unit: <T = MeasurementUnitPromise>() => T;
  expenseUnit: <T = ExpenseUnitPromise>() => T;
  stockUnit: <T = StockUnitPromise>() => T;
  expiresAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Inventory {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface InventoryPromise extends Promise<Inventory>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  inventoryUnits: <T = FragmentableArray<InventoryUnit>>(args?: {
    where?: InventoryUnitWhereInput;
    orderBy?: InventoryUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface InventorySubscription
  extends Promise<AsyncIterator<Inventory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  inventoryUnits: <
    T = Promise<AsyncIterator<InventoryUnitSubscription>>
  >(args?: {
    where?: InventoryUnitWhereInput;
    orderBy?: InventoryUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface InventoryNullablePromise
  extends Promise<Inventory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  inventoryUnits: <T = FragmentableArray<InventoryUnit>>(args?: {
    where?: InventoryUnitWhereInput;
    orderBy?: InventoryUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MeasurementUnit {
  id: ID_Output;
  name: String;
  symbol: String;
}

export interface MeasurementUnitPromise
  extends Promise<MeasurementUnit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  symbol: () => Promise<String>;
}

export interface MeasurementUnitSubscription
  extends Promise<AsyncIterator<MeasurementUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  symbol: () => Promise<AsyncIterator<String>>;
}

export interface MeasurementUnitNullablePromise
  extends Promise<MeasurementUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  symbol: () => Promise<String>;
}

export interface ExpenseUnit {
  id: ID_Output;
  amount: String;
  createdAt: DateTimeOutput;
}

export interface ExpenseUnitPromise extends Promise<ExpenseUnit>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  stockUnit: <T = StockUnitPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ExpenseUnitSubscription
  extends Promise<AsyncIterator<ExpenseUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  currency: <T = CurrencySubscription>() => T;
  stockUnit: <T = StockUnitSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpenseUnitNullablePromise
  extends Promise<ExpenseUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  stockUnit: <T = StockUnitPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface Currency {
  id: ID_Output;
  symbol: String;
  isDefault?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CurrencyPromise extends Promise<Currency>, Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CurrencySubscription
  extends Promise<AsyncIterator<Currency>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<String>>;
  isDefault: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CurrencyNullablePromise
  extends Promise<Currency | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ComponentConnection {
  pageInfo: PageInfo;
  edges: ComponentEdge[];
}

export interface ComponentConnectionPromise
  extends Promise<ComponentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ComponentEdge>>() => T;
  aggregate: <T = AggregateComponentPromise>() => T;
}

export interface ComponentConnectionSubscription
  extends Promise<AsyncIterator<ComponentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ComponentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateComponentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ComponentEdge {
  node: Component;
  cursor: String;
}

export interface ComponentEdgePromise
  extends Promise<ComponentEdge>,
    Fragmentable {
  node: <T = ComponentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ComponentEdgeSubscription
  extends Promise<AsyncIterator<ComponentEdge>>,
    Fragmentable {
  node: <T = ComponentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComponent {
  count: Int;
}

export interface AggregateComponentPromise
  extends Promise<AggregateComponent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateComponentSubscription
  extends Promise<AsyncIterator<AggregateComponent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CurrencyConnection {
  pageInfo: PageInfo;
  edges: CurrencyEdge[];
}

export interface CurrencyConnectionPromise
  extends Promise<CurrencyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CurrencyEdge>>() => T;
  aggregate: <T = AggregateCurrencyPromise>() => T;
}

export interface CurrencyConnectionSubscription
  extends Promise<AsyncIterator<CurrencyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CurrencyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCurrencySubscription>() => T;
}

export interface CurrencyEdge {
  node: Currency;
  cursor: String;
}

export interface CurrencyEdgePromise
  extends Promise<CurrencyEdge>,
    Fragmentable {
  node: <T = CurrencyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CurrencyEdgeSubscription
  extends Promise<AsyncIterator<CurrencyEdge>>,
    Fragmentable {
  node: <T = CurrencySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCurrency {
  count: Int;
}

export interface AggregateCurrencyPromise
  extends Promise<AggregateCurrency>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCurrencySubscription
  extends Promise<AsyncIterator<AggregateCurrency>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpenseUnitConnection {
  pageInfo: PageInfo;
  edges: ExpenseUnitEdge[];
}

export interface ExpenseUnitConnectionPromise
  extends Promise<ExpenseUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpenseUnitEdge>>() => T;
  aggregate: <T = AggregateExpenseUnitPromise>() => T;
}

export interface ExpenseUnitConnectionSubscription
  extends Promise<AsyncIterator<ExpenseUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpenseUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpenseUnitSubscription>() => T;
}

export interface ExpenseUnitEdge {
  node: ExpenseUnit;
  cursor: String;
}

export interface ExpenseUnitEdgePromise
  extends Promise<ExpenseUnitEdge>,
    Fragmentable {
  node: <T = ExpenseUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpenseUnitEdgeSubscription
  extends Promise<AsyncIterator<ExpenseUnitEdge>>,
    Fragmentable {
  node: <T = ExpenseUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpenseUnit {
  count: Int;
}

export interface AggregateExpenseUnitPromise
  extends Promise<AggregateExpenseUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpenseUnitSubscription
  extends Promise<AsyncIterator<AggregateExpenseUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InventoryConnection {
  pageInfo: PageInfo;
  edges: InventoryEdge[];
}

export interface InventoryConnectionPromise
  extends Promise<InventoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryEdge>>() => T;
  aggregate: <T = AggregateInventoryPromise>() => T;
}

export interface InventoryConnectionSubscription
  extends Promise<AsyncIterator<InventoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventorySubscription>() => T;
}

export interface InventoryEdge {
  node: Inventory;
  cursor: String;
}

export interface InventoryEdgePromise
  extends Promise<InventoryEdge>,
    Fragmentable {
  node: <T = InventoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryEdgeSubscription
  extends Promise<AsyncIterator<InventoryEdge>>,
    Fragmentable {
  node: <T = InventorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInventory {
  count: Int;
}

export interface AggregateInventoryPromise
  extends Promise<AggregateInventory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventorySubscription
  extends Promise<AsyncIterator<AggregateInventory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InventoryUnitConnection {
  pageInfo: PageInfo;
  edges: InventoryUnitEdge[];
}

export interface InventoryUnitConnectionPromise
  extends Promise<InventoryUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryUnitEdge>>() => T;
  aggregate: <T = AggregateInventoryUnitPromise>() => T;
}

export interface InventoryUnitConnectionSubscription
  extends Promise<AsyncIterator<InventoryUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventoryUnitSubscription>() => T;
}

export interface InventoryUnitEdge {
  node: InventoryUnit;
  cursor: String;
}

export interface InventoryUnitEdgePromise
  extends Promise<InventoryUnitEdge>,
    Fragmentable {
  node: <T = InventoryUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryUnitEdgeSubscription
  extends Promise<AsyncIterator<InventoryUnitEdge>>,
    Fragmentable {
  node: <T = InventoryUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInventoryUnit {
  count: Int;
}

export interface AggregateInventoryUnitPromise
  extends Promise<AggregateInventoryUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventoryUnitSubscription
  extends Promise<AsyncIterator<AggregateInventoryUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MeasurementUnitConnection {
  pageInfo: PageInfo;
  edges: MeasurementUnitEdge[];
}

export interface MeasurementUnitConnectionPromise
  extends Promise<MeasurementUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MeasurementUnitEdge>>() => T;
  aggregate: <T = AggregateMeasurementUnitPromise>() => T;
}

export interface MeasurementUnitConnectionSubscription
  extends Promise<AsyncIterator<MeasurementUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MeasurementUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMeasurementUnitSubscription>() => T;
}

export interface MeasurementUnitEdge {
  node: MeasurementUnit;
  cursor: String;
}

export interface MeasurementUnitEdgePromise
  extends Promise<MeasurementUnitEdge>,
    Fragmentable {
  node: <T = MeasurementUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MeasurementUnitEdgeSubscription
  extends Promise<AsyncIterator<MeasurementUnitEdge>>,
    Fragmentable {
  node: <T = MeasurementUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMeasurementUnit {
  count: Int;
}

export interface AggregateMeasurementUnitPromise
  extends Promise<AggregateMeasurementUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMeasurementUnitSubscription
  extends Promise<AsyncIterator<AggregateMeasurementUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StockUnitConnection {
  pageInfo: PageInfo;
  edges: StockUnitEdge[];
}

export interface StockUnitConnectionPromise
  extends Promise<StockUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StockUnitEdge>>() => T;
  aggregate: <T = AggregateStockUnitPromise>() => T;
}

export interface StockUnitConnectionSubscription
  extends Promise<AsyncIterator<StockUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StockUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStockUnitSubscription>() => T;
}

export interface StockUnitEdge {
  node: StockUnit;
  cursor: String;
}

export interface StockUnitEdgePromise
  extends Promise<StockUnitEdge>,
    Fragmentable {
  node: <T = StockUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StockUnitEdgeSubscription
  extends Promise<AsyncIterator<StockUnitEdge>>,
    Fragmentable {
  node: <T = StockUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStockUnit {
  count: Int;
}

export interface AggregateStockUnitPromise
  extends Promise<AggregateStockUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStockUnitSubscription
  extends Promise<AsyncIterator<AggregateStockUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StockUnitCategoryConnection {
  pageInfo: PageInfo;
  edges: StockUnitCategoryEdge[];
}

export interface StockUnitCategoryConnectionPromise
  extends Promise<StockUnitCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StockUnitCategoryEdge>>() => T;
  aggregate: <T = AggregateStockUnitCategoryPromise>() => T;
}

export interface StockUnitCategoryConnectionSubscription
  extends Promise<AsyncIterator<StockUnitCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StockUnitCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStockUnitCategorySubscription>() => T;
}

export interface StockUnitCategoryEdge {
  node: StockUnitCategory;
  cursor: String;
}

export interface StockUnitCategoryEdgePromise
  extends Promise<StockUnitCategoryEdge>,
    Fragmentable {
  node: <T = StockUnitCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StockUnitCategoryEdgeSubscription
  extends Promise<AsyncIterator<StockUnitCategoryEdge>>,
    Fragmentable {
  node: <T = StockUnitCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStockUnitCategory {
  count: Int;
}

export interface AggregateStockUnitCategoryPromise
  extends Promise<AggregateStockUnitCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStockUnitCategorySubscription
  extends Promise<AsyncIterator<AggregateStockUnitCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ComponentSubscriptionPayload {
  mutation: MutationType;
  node: Component;
  updatedFields: String[];
  previousValues: ComponentPreviousValues;
}

export interface ComponentSubscriptionPayloadPromise
  extends Promise<ComponentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ComponentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ComponentPreviousValuesPromise>() => T;
}

export interface ComponentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ComponentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ComponentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ComponentPreviousValuesSubscription>() => T;
}

export interface ComponentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ComponentPreviousValuesPromise
  extends Promise<ComponentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ComponentPreviousValuesSubscription
  extends Promise<AsyncIterator<ComponentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CurrencySubscriptionPayload {
  mutation: MutationType;
  node: Currency;
  updatedFields: String[];
  previousValues: CurrencyPreviousValues;
}

export interface CurrencySubscriptionPayloadPromise
  extends Promise<CurrencySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CurrencyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CurrencyPreviousValuesPromise>() => T;
}

export interface CurrencySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CurrencySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CurrencySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CurrencyPreviousValuesSubscription>() => T;
}

export interface CurrencyPreviousValues {
  id: ID_Output;
  symbol: String;
  isDefault?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CurrencyPreviousValuesPromise
  extends Promise<CurrencyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CurrencyPreviousValuesSubscription
  extends Promise<AsyncIterator<CurrencyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<String>>;
  isDefault: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpenseUnitSubscriptionPayload {
  mutation: MutationType;
  node: ExpenseUnit;
  updatedFields: String[];
  previousValues: ExpenseUnitPreviousValues;
}

export interface ExpenseUnitSubscriptionPayloadPromise
  extends Promise<ExpenseUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpenseUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpenseUnitPreviousValuesPromise>() => T;
}

export interface ExpenseUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpenseUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpenseUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpenseUnitPreviousValuesSubscription>() => T;
}

export interface ExpenseUnitPreviousValues {
  id: ID_Output;
  amount: String;
  createdAt: DateTimeOutput;
}

export interface ExpenseUnitPreviousValuesPromise
  extends Promise<ExpenseUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ExpenseUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<ExpenseUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventorySubscriptionPayload {
  mutation: MutationType;
  node: Inventory;
  updatedFields: String[];
  previousValues: InventoryPreviousValues;
}

export interface InventorySubscriptionPayloadPromise
  extends Promise<InventorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryPreviousValuesPromise>() => T;
}

export interface InventorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryPreviousValuesSubscription>() => T;
}

export interface InventoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface InventoryPreviousValuesPromise
  extends Promise<InventoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface InventoryPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryUnitSubscriptionPayload {
  mutation: MutationType;
  node: InventoryUnit;
  updatedFields: String[];
  previousValues: InventoryUnitPreviousValues;
}

export interface InventoryUnitSubscriptionPayloadPromise
  extends Promise<InventoryUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryUnitPreviousValuesPromise>() => T;
}

export interface InventoryUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventoryUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventoryUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryUnitPreviousValuesSubscription>() => T;
}

export interface InventoryUnitPreviousValues {
  id: ID_Output;
  quantity: String;
  expiresAt?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InventoryUnitPreviousValuesPromise
  extends Promise<InventoryUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<String>;
  expiresAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventoryUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<String>>;
  expiresAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MeasurementUnitSubscriptionPayload {
  mutation: MutationType;
  node: MeasurementUnit;
  updatedFields: String[];
  previousValues: MeasurementUnitPreviousValues;
}

export interface MeasurementUnitSubscriptionPayloadPromise
  extends Promise<MeasurementUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MeasurementUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MeasurementUnitPreviousValuesPromise>() => T;
}

export interface MeasurementUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MeasurementUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MeasurementUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MeasurementUnitPreviousValuesSubscription>() => T;
}

export interface MeasurementUnitPreviousValues {
  id: ID_Output;
  name: String;
  symbol: String;
}

export interface MeasurementUnitPreviousValuesPromise
  extends Promise<MeasurementUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  symbol: () => Promise<String>;
}

export interface MeasurementUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<MeasurementUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  symbol: () => Promise<AsyncIterator<String>>;
}

export interface StockUnitSubscriptionPayload {
  mutation: MutationType;
  node: StockUnit;
  updatedFields: String[];
  previousValues: StockUnitPreviousValues;
}

export interface StockUnitSubscriptionPayloadPromise
  extends Promise<StockUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StockUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StockUnitPreviousValuesPromise>() => T;
}

export interface StockUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StockUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StockUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StockUnitPreviousValuesSubscription>() => T;
}

export interface StockUnitPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface StockUnitPreviousValuesPromise
  extends Promise<StockUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface StockUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<StockUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StockUnitCategorySubscriptionPayload {
  mutation: MutationType;
  node: StockUnitCategory;
  updatedFields: String[];
  previousValues: StockUnitCategoryPreviousValues;
}

export interface StockUnitCategorySubscriptionPayloadPromise
  extends Promise<StockUnitCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StockUnitCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StockUnitCategoryPreviousValuesPromise>() => T;
}

export interface StockUnitCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StockUnitCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StockUnitCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StockUnitCategoryPreviousValuesSubscription>() => T;
}

export interface StockUnitCategoryPreviousValues {
  id: ID_Output;
  name: String;
}

export interface StockUnitCategoryPreviousValuesPromise
  extends Promise<StockUnitCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface StockUnitCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<StockUnitCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "ExpenseUnit",
    embedded: false
  },
  {
    name: "StockUnitCategory",
    embedded: false
  },
  {
    name: "Inventory",
    embedded: false
  },
  {
    name: "InventoryUnit",
    embedded: false
  },
  {
    name: "Component",
    embedded: false
  },
  {
    name: "MeasurementUnit",
    embedded: false
  },
  {
    name: "StockUnit",
    embedded: false
  },
  {
    name: "Currency",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://116.203.108.46:4466`
});
export const prisma = new Prisma();
