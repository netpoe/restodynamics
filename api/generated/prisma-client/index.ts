// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  currency: (where?: CurrencyWhereInput) => Promise<boolean>;
  expenseUnit: (where?: ExpenseUnitWhereInput) => Promise<boolean>;
  inventory: (where?: InventoryWhereInput) => Promise<boolean>;
  measurementUnit: (where?: MeasurementUnitWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  stockUnit: (where?: StockUnitWhereInput) => Promise<boolean>;
  stockUnitCategory: (where?: StockUnitCategoryWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  currency: (where: CurrencyWhereUniqueInput) => CurrencyNullablePromise;
  currencies: (args?: {
    where?: CurrencyWhereInput;
    orderBy?: CurrencyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Currency>;
  currenciesConnection: (args?: {
    where?: CurrencyWhereInput;
    orderBy?: CurrencyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CurrencyConnectionPromise;
  expenseUnit: (
    where: ExpenseUnitWhereUniqueInput
  ) => ExpenseUnitNullablePromise;
  expenseUnits: (args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExpenseUnit>;
  expenseUnitsConnection: (args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpenseUnitConnectionPromise;
  inventory: (where: InventoryWhereUniqueInput) => InventoryNullablePromise;
  inventories: (args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Inventory>;
  inventoriesConnection: (args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InventoryConnectionPromise;
  measurementUnit: (
    where: MeasurementUnitWhereUniqueInput
  ) => MeasurementUnitNullablePromise;
  measurementUnits: (args?: {
    where?: MeasurementUnitWhereInput;
    orderBy?: MeasurementUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MeasurementUnit>;
  measurementUnitsConnection: (args?: {
    where?: MeasurementUnitWhereInput;
    orderBy?: MeasurementUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MeasurementUnitConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  stockUnit: (where: StockUnitWhereUniqueInput) => StockUnitNullablePromise;
  stockUnits: (args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StockUnit>;
  stockUnitsConnection: (args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StockUnitConnectionPromise;
  stockUnitCategory: (
    where: StockUnitCategoryWhereUniqueInput
  ) => StockUnitCategoryNullablePromise;
  stockUnitCategories: (args?: {
    where?: StockUnitCategoryWhereInput;
    orderBy?: StockUnitCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StockUnitCategory>;
  stockUnitCategoriesConnection: (args?: {
    where?: StockUnitCategoryWhereInput;
    orderBy?: StockUnitCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StockUnitCategoryConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCurrency: (data: CurrencyCreateInput) => CurrencyPromise;
  updateCurrency: (args: {
    data: CurrencyUpdateInput;
    where: CurrencyWhereUniqueInput;
  }) => CurrencyPromise;
  updateManyCurrencies: (args: {
    data: CurrencyUpdateManyMutationInput;
    where?: CurrencyWhereInput;
  }) => BatchPayloadPromise;
  upsertCurrency: (args: {
    where: CurrencyWhereUniqueInput;
    create: CurrencyCreateInput;
    update: CurrencyUpdateInput;
  }) => CurrencyPromise;
  deleteCurrency: (where: CurrencyWhereUniqueInput) => CurrencyPromise;
  deleteManyCurrencies: (where?: CurrencyWhereInput) => BatchPayloadPromise;
  createExpenseUnit: (data: ExpenseUnitCreateInput) => ExpenseUnitPromise;
  updateExpenseUnit: (args: {
    data: ExpenseUnitUpdateInput;
    where: ExpenseUnitWhereUniqueInput;
  }) => ExpenseUnitPromise;
  updateManyExpenseUnits: (args: {
    data: ExpenseUnitUpdateManyMutationInput;
    where?: ExpenseUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertExpenseUnit: (args: {
    where: ExpenseUnitWhereUniqueInput;
    create: ExpenseUnitCreateInput;
    update: ExpenseUnitUpdateInput;
  }) => ExpenseUnitPromise;
  deleteExpenseUnit: (where: ExpenseUnitWhereUniqueInput) => ExpenseUnitPromise;
  deleteManyExpenseUnits: (
    where?: ExpenseUnitWhereInput
  ) => BatchPayloadPromise;
  createInventory: (data: InventoryCreateInput) => InventoryPromise;
  updateInventory: (args: {
    data: InventoryUpdateInput;
    where: InventoryWhereUniqueInput;
  }) => InventoryPromise;
  updateManyInventories: (args: {
    data: InventoryUpdateManyMutationInput;
    where?: InventoryWhereInput;
  }) => BatchPayloadPromise;
  upsertInventory: (args: {
    where: InventoryWhereUniqueInput;
    create: InventoryCreateInput;
    update: InventoryUpdateInput;
  }) => InventoryPromise;
  deleteInventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  deleteManyInventories: (where?: InventoryWhereInput) => BatchPayloadPromise;
  createMeasurementUnit: (
    data: MeasurementUnitCreateInput
  ) => MeasurementUnitPromise;
  updateMeasurementUnit: (args: {
    data: MeasurementUnitUpdateInput;
    where: MeasurementUnitWhereUniqueInput;
  }) => MeasurementUnitPromise;
  updateManyMeasurementUnits: (args: {
    data: MeasurementUnitUpdateManyMutationInput;
    where?: MeasurementUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertMeasurementUnit: (args: {
    where: MeasurementUnitWhereUniqueInput;
    create: MeasurementUnitCreateInput;
    update: MeasurementUnitUpdateInput;
  }) => MeasurementUnitPromise;
  deleteMeasurementUnit: (
    where: MeasurementUnitWhereUniqueInput
  ) => MeasurementUnitPromise;
  deleteManyMeasurementUnits: (
    where?: MeasurementUnitWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createStockUnit: (data: StockUnitCreateInput) => StockUnitPromise;
  updateStockUnit: (args: {
    data: StockUnitUpdateInput;
    where: StockUnitWhereUniqueInput;
  }) => StockUnitPromise;
  updateManyStockUnits: (args: {
    data: StockUnitUpdateManyMutationInput;
    where?: StockUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertStockUnit: (args: {
    where: StockUnitWhereUniqueInput;
    create: StockUnitCreateInput;
    update: StockUnitUpdateInput;
  }) => StockUnitPromise;
  deleteStockUnit: (where: StockUnitWhereUniqueInput) => StockUnitPromise;
  deleteManyStockUnits: (where?: StockUnitWhereInput) => BatchPayloadPromise;
  createStockUnitCategory: (
    data: StockUnitCategoryCreateInput
  ) => StockUnitCategoryPromise;
  updateStockUnitCategory: (args: {
    data: StockUnitCategoryUpdateInput;
    where: StockUnitCategoryWhereUniqueInput;
  }) => StockUnitCategoryPromise;
  updateManyStockUnitCategories: (args: {
    data: StockUnitCategoryUpdateManyMutationInput;
    where?: StockUnitCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertStockUnitCategory: (args: {
    where: StockUnitCategoryWhereUniqueInput;
    create: StockUnitCategoryCreateInput;
    update: StockUnitCategoryUpdateInput;
  }) => StockUnitCategoryPromise;
  deleteStockUnitCategory: (
    where: StockUnitCategoryWhereUniqueInput
  ) => StockUnitCategoryPromise;
  deleteManyStockUnitCategories: (
    where?: StockUnitCategoryWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  currency: (
    where?: CurrencySubscriptionWhereInput
  ) => CurrencySubscriptionPayloadSubscription;
  expenseUnit: (
    where?: ExpenseUnitSubscriptionWhereInput
  ) => ExpenseUnitSubscriptionPayloadSubscription;
  inventory: (
    where?: InventorySubscriptionWhereInput
  ) => InventorySubscriptionPayloadSubscription;
  measurementUnit: (
    where?: MeasurementUnitSubscriptionWhereInput
  ) => MeasurementUnitSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  stockUnit: (
    where?: StockUnitSubscriptionWhereInput
  ) => StockUnitSubscriptionPayloadSubscription;
  stockUnitCategory: (
    where?: StockUnitCategorySubscriptionWhereInput
  ) => StockUnitCategorySubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CurrencyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "symbol_ASC"
  | "symbol_DESC"
  | "isDefault_ASC"
  | "isDefault_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type StockUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type InventoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExpenseUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type MeasurementUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "symbol_ASC"
  | "symbol_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StockUnitCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CurrencyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CurrencyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  symbol?: Maybe<String>;
  symbol_not?: Maybe<String>;
  symbol_in?: Maybe<String[] | String>;
  symbol_not_in?: Maybe<String[] | String>;
  symbol_lt?: Maybe<String>;
  symbol_lte?: Maybe<String>;
  symbol_gt?: Maybe<String>;
  symbol_gte?: Maybe<String>;
  symbol_contains?: Maybe<String>;
  symbol_not_contains?: Maybe<String>;
  symbol_starts_with?: Maybe<String>;
  symbol_not_starts_with?: Maybe<String>;
  symbol_ends_with?: Maybe<String>;
  symbol_not_ends_with?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
  isDefault_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
  OR?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
  NOT?: Maybe<CurrencyWhereInput[] | CurrencyWhereInput>;
}

export type ExpenseUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StockUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  inventory_every?: Maybe<InventoryWhereInput>;
  inventory_some?: Maybe<InventoryWhereInput>;
  inventory_none?: Maybe<InventoryWhereInput>;
  category?: Maybe<StockUnitCategoryWhereInput>;
  expenseUnit_every?: Maybe<ExpenseUnitWhereInput>;
  expenseUnit_some?: Maybe<ExpenseUnitWhereInput>;
  expenseUnit_none?: Maybe<ExpenseUnitWhereInput>;
  AND?: Maybe<StockUnitWhereInput[] | StockUnitWhereInput>;
  OR?: Maybe<StockUnitWhereInput[] | StockUnitWhereInput>;
  NOT?: Maybe<StockUnitWhereInput[] | StockUnitWhereInput>;
}

export interface InventoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<String>;
  quantity_not?: Maybe<String>;
  quantity_in?: Maybe<String[] | String>;
  quantity_not_in?: Maybe<String[] | String>;
  quantity_lt?: Maybe<String>;
  quantity_lte?: Maybe<String>;
  quantity_gt?: Maybe<String>;
  quantity_gte?: Maybe<String>;
  quantity_contains?: Maybe<String>;
  quantity_not_contains?: Maybe<String>;
  quantity_starts_with?: Maybe<String>;
  quantity_not_starts_with?: Maybe<String>;
  quantity_ends_with?: Maybe<String>;
  quantity_not_ends_with?: Maybe<String>;
  unit?: Maybe<MeasurementUnitWhereInput>;
  stockUnit_every?: Maybe<StockUnitWhereInput>;
  stockUnit_some?: Maybe<StockUnitWhereInput>;
  stockUnit_none?: Maybe<StockUnitWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
  OR?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
  NOT?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
}

export interface MeasurementUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  symbol?: Maybe<String>;
  symbol_not?: Maybe<String>;
  symbol_in?: Maybe<String[] | String>;
  symbol_not_in?: Maybe<String[] | String>;
  symbol_lt?: Maybe<String>;
  symbol_lte?: Maybe<String>;
  symbol_gt?: Maybe<String>;
  symbol_gte?: Maybe<String>;
  symbol_contains?: Maybe<String>;
  symbol_not_contains?: Maybe<String>;
  symbol_starts_with?: Maybe<String>;
  symbol_not_starts_with?: Maybe<String>;
  symbol_ends_with?: Maybe<String>;
  symbol_not_ends_with?: Maybe<String>;
  AND?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
  OR?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
  NOT?: Maybe<MeasurementUnitWhereInput[] | MeasurementUnitWhereInput>;
}

export interface StockUnitCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<StockUnitCategoryWhereInput[] | StockUnitCategoryWhereInput>;
  OR?: Maybe<StockUnitCategoryWhereInput[] | StockUnitCategoryWhereInput>;
  NOT?: Maybe<StockUnitCategoryWhereInput[] | StockUnitCategoryWhereInput>;
}

export interface ExpenseUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  currency?: Maybe<CurrencyWhereInput>;
  stockUnit_every?: Maybe<StockUnitWhereInput>;
  stockUnit_some?: Maybe<StockUnitWhereInput>;
  stockUnit_none?: Maybe<StockUnitWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExpenseUnitWhereInput[] | ExpenseUnitWhereInput>;
  OR?: Maybe<ExpenseUnitWhereInput[] | ExpenseUnitWhereInput>;
  NOT?: Maybe<ExpenseUnitWhereInput[] | ExpenseUnitWhereInput>;
}

export type InventoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MeasurementUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  item?: Maybe<StockUnitWhereInput>;
  stockUnit_every?: Maybe<StockUnitWhereInput>;
  stockUnit_some?: Maybe<StockUnitWhereInput>;
  stockUnit_none?: Maybe<StockUnitWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export type StockUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type StockUnitCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface CurrencyCreateInput {
  id?: Maybe<ID_Input>;
  symbol: String;
  isDefault?: Maybe<Boolean>;
}

export interface CurrencyUpdateInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export interface CurrencyUpdateManyMutationInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export interface ExpenseUnitCreateInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  currency: CurrencyCreateOneInput;
  stockUnit?: Maybe<StockUnitCreateManyWithoutExpenseUnitInput>;
}

export interface CurrencyCreateOneInput {
  create?: Maybe<CurrencyCreateInput>;
  connect?: Maybe<CurrencyWhereUniqueInput>;
}

export interface StockUnitCreateManyWithoutExpenseUnitInput {
  create?: Maybe<
    | StockUnitCreateWithoutExpenseUnitInput[]
    | StockUnitCreateWithoutExpenseUnitInput
  >;
  connect?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
}

export interface StockUnitCreateWithoutExpenseUnitInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  inventory?: Maybe<InventoryCreateManyWithoutStockUnitInput>;
  category?: Maybe<StockUnitCategoryCreateOneInput>;
}

export interface InventoryCreateManyWithoutStockUnitInput {
  create?: Maybe<
    | InventoryCreateWithoutStockUnitInput[]
    | InventoryCreateWithoutStockUnitInput
  >;
  connect?: Maybe<InventoryWhereUniqueInput[] | InventoryWhereUniqueInput>;
}

export interface InventoryCreateWithoutStockUnitInput {
  id?: Maybe<ID_Input>;
  quantity?: Maybe<String>;
  unit: MeasurementUnitCreateOneInput;
}

export interface MeasurementUnitCreateOneInput {
  create?: Maybe<MeasurementUnitCreateInput>;
  connect?: Maybe<MeasurementUnitWhereUniqueInput>;
}

export interface MeasurementUnitCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  symbol: String;
}

export interface StockUnitCategoryCreateOneInput {
  create?: Maybe<StockUnitCategoryCreateInput>;
  connect?: Maybe<StockUnitCategoryWhereUniqueInput>;
}

export interface StockUnitCategoryCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ExpenseUnitUpdateInput {
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
  stockUnit?: Maybe<StockUnitUpdateManyWithoutExpenseUnitInput>;
}

export interface CurrencyUpdateOneRequiredInput {
  create?: Maybe<CurrencyCreateInput>;
  update?: Maybe<CurrencyUpdateDataInput>;
  upsert?: Maybe<CurrencyUpsertNestedInput>;
  connect?: Maybe<CurrencyWhereUniqueInput>;
}

export interface CurrencyUpdateDataInput {
  symbol?: Maybe<String>;
  isDefault?: Maybe<Boolean>;
}

export interface CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput;
  create: CurrencyCreateInput;
}

export interface StockUnitUpdateManyWithoutExpenseUnitInput {
  create?: Maybe<
    | StockUnitCreateWithoutExpenseUnitInput[]
    | StockUnitCreateWithoutExpenseUnitInput
  >;
  delete?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  connect?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  set?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  disconnect?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  update?: Maybe<
    | StockUnitUpdateWithWhereUniqueWithoutExpenseUnitInput[]
    | StockUnitUpdateWithWhereUniqueWithoutExpenseUnitInput
  >;
  upsert?: Maybe<
    | StockUnitUpsertWithWhereUniqueWithoutExpenseUnitInput[]
    | StockUnitUpsertWithWhereUniqueWithoutExpenseUnitInput
  >;
  deleteMany?: Maybe<StockUnitScalarWhereInput[] | StockUnitScalarWhereInput>;
  updateMany?: Maybe<
    | StockUnitUpdateManyWithWhereNestedInput[]
    | StockUnitUpdateManyWithWhereNestedInput
  >;
}

export interface StockUnitUpdateWithWhereUniqueWithoutExpenseUnitInput {
  where: StockUnitWhereUniqueInput;
  data: StockUnitUpdateWithoutExpenseUnitDataInput;
}

export interface StockUnitUpdateWithoutExpenseUnitDataInput {
  name?: Maybe<String>;
  inventory?: Maybe<InventoryUpdateManyWithoutStockUnitInput>;
  category?: Maybe<StockUnitCategoryUpdateOneInput>;
}

export interface InventoryUpdateManyWithoutStockUnitInput {
  create?: Maybe<
    | InventoryCreateWithoutStockUnitInput[]
    | InventoryCreateWithoutStockUnitInput
  >;
  delete?: Maybe<InventoryWhereUniqueInput[] | InventoryWhereUniqueInput>;
  connect?: Maybe<InventoryWhereUniqueInput[] | InventoryWhereUniqueInput>;
  set?: Maybe<InventoryWhereUniqueInput[] | InventoryWhereUniqueInput>;
  disconnect?: Maybe<InventoryWhereUniqueInput[] | InventoryWhereUniqueInput>;
  update?: Maybe<
    | InventoryUpdateWithWhereUniqueWithoutStockUnitInput[]
    | InventoryUpdateWithWhereUniqueWithoutStockUnitInput
  >;
  upsert?: Maybe<
    | InventoryUpsertWithWhereUniqueWithoutStockUnitInput[]
    | InventoryUpsertWithWhereUniqueWithoutStockUnitInput
  >;
  deleteMany?: Maybe<InventoryScalarWhereInput[] | InventoryScalarWhereInput>;
  updateMany?: Maybe<
    | InventoryUpdateManyWithWhereNestedInput[]
    | InventoryUpdateManyWithWhereNestedInput
  >;
}

export interface InventoryUpdateWithWhereUniqueWithoutStockUnitInput {
  where: InventoryWhereUniqueInput;
  data: InventoryUpdateWithoutStockUnitDataInput;
}

export interface InventoryUpdateWithoutStockUnitDataInput {
  quantity?: Maybe<String>;
  unit?: Maybe<MeasurementUnitUpdateOneRequiredInput>;
}

export interface MeasurementUnitUpdateOneRequiredInput {
  create?: Maybe<MeasurementUnitCreateInput>;
  update?: Maybe<MeasurementUnitUpdateDataInput>;
  upsert?: Maybe<MeasurementUnitUpsertNestedInput>;
  connect?: Maybe<MeasurementUnitWhereUniqueInput>;
}

export interface MeasurementUnitUpdateDataInput {
  name?: Maybe<String>;
  symbol?: Maybe<String>;
}

export interface MeasurementUnitUpsertNestedInput {
  update: MeasurementUnitUpdateDataInput;
  create: MeasurementUnitCreateInput;
}

export interface InventoryUpsertWithWhereUniqueWithoutStockUnitInput {
  where: InventoryWhereUniqueInput;
  update: InventoryUpdateWithoutStockUnitDataInput;
  create: InventoryCreateWithoutStockUnitInput;
}

export interface InventoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<String>;
  quantity_not?: Maybe<String>;
  quantity_in?: Maybe<String[] | String>;
  quantity_not_in?: Maybe<String[] | String>;
  quantity_lt?: Maybe<String>;
  quantity_lte?: Maybe<String>;
  quantity_gt?: Maybe<String>;
  quantity_gte?: Maybe<String>;
  quantity_contains?: Maybe<String>;
  quantity_not_contains?: Maybe<String>;
  quantity_starts_with?: Maybe<String>;
  quantity_not_starts_with?: Maybe<String>;
  quantity_ends_with?: Maybe<String>;
  quantity_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InventoryScalarWhereInput[] | InventoryScalarWhereInput>;
  OR?: Maybe<InventoryScalarWhereInput[] | InventoryScalarWhereInput>;
  NOT?: Maybe<InventoryScalarWhereInput[] | InventoryScalarWhereInput>;
}

export interface InventoryUpdateManyWithWhereNestedInput {
  where: InventoryScalarWhereInput;
  data: InventoryUpdateManyDataInput;
}

export interface InventoryUpdateManyDataInput {
  quantity?: Maybe<String>;
}

export interface StockUnitCategoryUpdateOneInput {
  create?: Maybe<StockUnitCategoryCreateInput>;
  update?: Maybe<StockUnitCategoryUpdateDataInput>;
  upsert?: Maybe<StockUnitCategoryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StockUnitCategoryWhereUniqueInput>;
}

export interface StockUnitCategoryUpdateDataInput {
  name?: Maybe<String>;
}

export interface StockUnitCategoryUpsertNestedInput {
  update: StockUnitCategoryUpdateDataInput;
  create: StockUnitCategoryCreateInput;
}

export interface StockUnitUpsertWithWhereUniqueWithoutExpenseUnitInput {
  where: StockUnitWhereUniqueInput;
  update: StockUnitUpdateWithoutExpenseUnitDataInput;
  create: StockUnitCreateWithoutExpenseUnitInput;
}

export interface StockUnitScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<StockUnitScalarWhereInput[] | StockUnitScalarWhereInput>;
  OR?: Maybe<StockUnitScalarWhereInput[] | StockUnitScalarWhereInput>;
  NOT?: Maybe<StockUnitScalarWhereInput[] | StockUnitScalarWhereInput>;
}

export interface StockUnitUpdateManyWithWhereNestedInput {
  where: StockUnitScalarWhereInput;
  data: StockUnitUpdateManyDataInput;
}

export interface StockUnitUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface ExpenseUnitUpdateManyMutationInput {
  amount?: Maybe<String>;
}

export interface InventoryCreateInput {
  id?: Maybe<ID_Input>;
  quantity?: Maybe<String>;
  unit: MeasurementUnitCreateOneInput;
  stockUnit?: Maybe<StockUnitCreateManyWithoutInventoryInput>;
}

export interface StockUnitCreateManyWithoutInventoryInput {
  create?: Maybe<
    | StockUnitCreateWithoutInventoryInput[]
    | StockUnitCreateWithoutInventoryInput
  >;
  connect?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
}

export interface StockUnitCreateWithoutInventoryInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  category?: Maybe<StockUnitCategoryCreateOneInput>;
  expenseUnit?: Maybe<ExpenseUnitCreateManyWithoutStockUnitInput>;
}

export interface ExpenseUnitCreateManyWithoutStockUnitInput {
  create?: Maybe<
    | ExpenseUnitCreateWithoutStockUnitInput[]
    | ExpenseUnitCreateWithoutStockUnitInput
  >;
  connect?: Maybe<ExpenseUnitWhereUniqueInput[] | ExpenseUnitWhereUniqueInput>;
}

export interface ExpenseUnitCreateWithoutStockUnitInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  currency: CurrencyCreateOneInput;
}

export interface InventoryUpdateInput {
  quantity?: Maybe<String>;
  unit?: Maybe<MeasurementUnitUpdateOneRequiredInput>;
  stockUnit?: Maybe<StockUnitUpdateManyWithoutInventoryInput>;
}

export interface StockUnitUpdateManyWithoutInventoryInput {
  create?: Maybe<
    | StockUnitCreateWithoutInventoryInput[]
    | StockUnitCreateWithoutInventoryInput
  >;
  delete?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  connect?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  set?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  disconnect?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  update?: Maybe<
    | StockUnitUpdateWithWhereUniqueWithoutInventoryInput[]
    | StockUnitUpdateWithWhereUniqueWithoutInventoryInput
  >;
  upsert?: Maybe<
    | StockUnitUpsertWithWhereUniqueWithoutInventoryInput[]
    | StockUnitUpsertWithWhereUniqueWithoutInventoryInput
  >;
  deleteMany?: Maybe<StockUnitScalarWhereInput[] | StockUnitScalarWhereInput>;
  updateMany?: Maybe<
    | StockUnitUpdateManyWithWhereNestedInput[]
    | StockUnitUpdateManyWithWhereNestedInput
  >;
}

export interface StockUnitUpdateWithWhereUniqueWithoutInventoryInput {
  where: StockUnitWhereUniqueInput;
  data: StockUnitUpdateWithoutInventoryDataInput;
}

export interface StockUnitUpdateWithoutInventoryDataInput {
  name?: Maybe<String>;
  category?: Maybe<StockUnitCategoryUpdateOneInput>;
  expenseUnit?: Maybe<ExpenseUnitUpdateManyWithoutStockUnitInput>;
}

export interface ExpenseUnitUpdateManyWithoutStockUnitInput {
  create?: Maybe<
    | ExpenseUnitCreateWithoutStockUnitInput[]
    | ExpenseUnitCreateWithoutStockUnitInput
  >;
  delete?: Maybe<ExpenseUnitWhereUniqueInput[] | ExpenseUnitWhereUniqueInput>;
  connect?: Maybe<ExpenseUnitWhereUniqueInput[] | ExpenseUnitWhereUniqueInput>;
  set?: Maybe<ExpenseUnitWhereUniqueInput[] | ExpenseUnitWhereUniqueInput>;
  disconnect?: Maybe<
    ExpenseUnitWhereUniqueInput[] | ExpenseUnitWhereUniqueInput
  >;
  update?: Maybe<
    | ExpenseUnitUpdateWithWhereUniqueWithoutStockUnitInput[]
    | ExpenseUnitUpdateWithWhereUniqueWithoutStockUnitInput
  >;
  upsert?: Maybe<
    | ExpenseUnitUpsertWithWhereUniqueWithoutStockUnitInput[]
    | ExpenseUnitUpsertWithWhereUniqueWithoutStockUnitInput
  >;
  deleteMany?: Maybe<
    ExpenseUnitScalarWhereInput[] | ExpenseUnitScalarWhereInput
  >;
  updateMany?: Maybe<
    | ExpenseUnitUpdateManyWithWhereNestedInput[]
    | ExpenseUnitUpdateManyWithWhereNestedInput
  >;
}

export interface ExpenseUnitUpdateWithWhereUniqueWithoutStockUnitInput {
  where: ExpenseUnitWhereUniqueInput;
  data: ExpenseUnitUpdateWithoutStockUnitDataInput;
}

export interface ExpenseUnitUpdateWithoutStockUnitDataInput {
  amount?: Maybe<String>;
  currency?: Maybe<CurrencyUpdateOneRequiredInput>;
}

export interface ExpenseUnitUpsertWithWhereUniqueWithoutStockUnitInput {
  where: ExpenseUnitWhereUniqueInput;
  update: ExpenseUnitUpdateWithoutStockUnitDataInput;
  create: ExpenseUnitCreateWithoutStockUnitInput;
}

export interface ExpenseUnitScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<String>;
  amount_not?: Maybe<String>;
  amount_in?: Maybe<String[] | String>;
  amount_not_in?: Maybe<String[] | String>;
  amount_lt?: Maybe<String>;
  amount_lte?: Maybe<String>;
  amount_gt?: Maybe<String>;
  amount_gte?: Maybe<String>;
  amount_contains?: Maybe<String>;
  amount_not_contains?: Maybe<String>;
  amount_starts_with?: Maybe<String>;
  amount_not_starts_with?: Maybe<String>;
  amount_ends_with?: Maybe<String>;
  amount_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExpenseUnitScalarWhereInput[] | ExpenseUnitScalarWhereInput>;
  OR?: Maybe<ExpenseUnitScalarWhereInput[] | ExpenseUnitScalarWhereInput>;
  NOT?: Maybe<ExpenseUnitScalarWhereInput[] | ExpenseUnitScalarWhereInput>;
}

export interface ExpenseUnitUpdateManyWithWhereNestedInput {
  where: ExpenseUnitScalarWhereInput;
  data: ExpenseUnitUpdateManyDataInput;
}

export interface ExpenseUnitUpdateManyDataInput {
  amount?: Maybe<String>;
}

export interface StockUnitUpsertWithWhereUniqueWithoutInventoryInput {
  where: StockUnitWhereUniqueInput;
  update: StockUnitUpdateWithoutInventoryDataInput;
  create: StockUnitCreateWithoutInventoryInput;
}

export interface InventoryUpdateManyMutationInput {
  quantity?: Maybe<String>;
}

export interface MeasurementUnitUpdateInput {
  name?: Maybe<String>;
  symbol?: Maybe<String>;
}

export interface MeasurementUnitUpdateManyMutationInput {
  name?: Maybe<String>;
  symbol?: Maybe<String>;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  item: StockUnitCreateOneInput;
  stockUnit?: Maybe<StockUnitCreateManyInput>;
}

export interface StockUnitCreateOneInput {
  create?: Maybe<StockUnitCreateInput>;
  connect?: Maybe<StockUnitWhereUniqueInput>;
}

export interface StockUnitCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  inventory?: Maybe<InventoryCreateManyWithoutStockUnitInput>;
  category?: Maybe<StockUnitCategoryCreateOneInput>;
  expenseUnit?: Maybe<ExpenseUnitCreateManyWithoutStockUnitInput>;
}

export interface StockUnitCreateManyInput {
  create?: Maybe<StockUnitCreateInput[] | StockUnitCreateInput>;
  connect?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
}

export interface ProductUpdateInput {
  item?: Maybe<StockUnitUpdateOneRequiredInput>;
  stockUnit?: Maybe<StockUnitUpdateManyInput>;
}

export interface StockUnitUpdateOneRequiredInput {
  create?: Maybe<StockUnitCreateInput>;
  update?: Maybe<StockUnitUpdateDataInput>;
  upsert?: Maybe<StockUnitUpsertNestedInput>;
  connect?: Maybe<StockUnitWhereUniqueInput>;
}

export interface StockUnitUpdateDataInput {
  name?: Maybe<String>;
  inventory?: Maybe<InventoryUpdateManyWithoutStockUnitInput>;
  category?: Maybe<StockUnitCategoryUpdateOneInput>;
  expenseUnit?: Maybe<ExpenseUnitUpdateManyWithoutStockUnitInput>;
}

export interface StockUnitUpsertNestedInput {
  update: StockUnitUpdateDataInput;
  create: StockUnitCreateInput;
}

export interface StockUnitUpdateManyInput {
  create?: Maybe<StockUnitCreateInput[] | StockUnitCreateInput>;
  update?: Maybe<
    | StockUnitUpdateWithWhereUniqueNestedInput[]
    | StockUnitUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | StockUnitUpsertWithWhereUniqueNestedInput[]
    | StockUnitUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  connect?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  set?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  disconnect?: Maybe<StockUnitWhereUniqueInput[] | StockUnitWhereUniqueInput>;
  deleteMany?: Maybe<StockUnitScalarWhereInput[] | StockUnitScalarWhereInput>;
  updateMany?: Maybe<
    | StockUnitUpdateManyWithWhereNestedInput[]
    | StockUnitUpdateManyWithWhereNestedInput
  >;
}

export interface StockUnitUpdateWithWhereUniqueNestedInput {
  where: StockUnitWhereUniqueInput;
  data: StockUnitUpdateDataInput;
}

export interface StockUnitUpsertWithWhereUniqueNestedInput {
  where: StockUnitWhereUniqueInput;
  update: StockUnitUpdateDataInput;
  create: StockUnitCreateInput;
}

export interface StockUnitUpdateInput {
  name?: Maybe<String>;
  inventory?: Maybe<InventoryUpdateManyWithoutStockUnitInput>;
  category?: Maybe<StockUnitCategoryUpdateOneInput>;
  expenseUnit?: Maybe<ExpenseUnitUpdateManyWithoutStockUnitInput>;
}

export interface StockUnitUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface StockUnitCategoryUpdateInput {
  name?: Maybe<String>;
}

export interface StockUnitCategoryUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CurrencySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CurrencyWhereInput>;
  AND?: Maybe<
    CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput
  >;
  OR?: Maybe<CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput>;
  NOT?: Maybe<
    CurrencySubscriptionWhereInput[] | CurrencySubscriptionWhereInput
  >;
}

export interface ExpenseUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpenseUnitWhereInput>;
  AND?: Maybe<
    ExpenseUnitSubscriptionWhereInput[] | ExpenseUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    ExpenseUnitSubscriptionWhereInput[] | ExpenseUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ExpenseUnitSubscriptionWhereInput[] | ExpenseUnitSubscriptionWhereInput
  >;
}

export interface InventorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InventoryWhereInput>;
  AND?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
  OR?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
}

export interface MeasurementUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MeasurementUnitWhereInput>;
  AND?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MeasurementUnitSubscriptionWhereInput[]
    | MeasurementUnitSubscriptionWhereInput
  >;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface StockUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StockUnitWhereInput>;
  AND?: Maybe<
    StockUnitSubscriptionWhereInput[] | StockUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    StockUnitSubscriptionWhereInput[] | StockUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    StockUnitSubscriptionWhereInput[] | StockUnitSubscriptionWhereInput
  >;
}

export interface StockUnitCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StockUnitCategoryWhereInput>;
  AND?: Maybe<
    | StockUnitCategorySubscriptionWhereInput[]
    | StockUnitCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | StockUnitCategorySubscriptionWhereInput[]
    | StockUnitCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | StockUnitCategorySubscriptionWhereInput[]
    | StockUnitCategorySubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Currency {
  id: ID_Output;
  symbol: String;
  isDefault?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CurrencyPromise extends Promise<Currency>, Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CurrencySubscription
  extends Promise<AsyncIterator<Currency>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<String>>;
  isDefault: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CurrencyNullablePromise
  extends Promise<Currency | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CurrencyConnection {
  pageInfo: PageInfo;
  edges: CurrencyEdge[];
}

export interface CurrencyConnectionPromise
  extends Promise<CurrencyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CurrencyEdge>>() => T;
  aggregate: <T = AggregateCurrencyPromise>() => T;
}

export interface CurrencyConnectionSubscription
  extends Promise<AsyncIterator<CurrencyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CurrencyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCurrencySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CurrencyEdge {
  node: Currency;
  cursor: String;
}

export interface CurrencyEdgePromise
  extends Promise<CurrencyEdge>,
    Fragmentable {
  node: <T = CurrencyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CurrencyEdgeSubscription
  extends Promise<AsyncIterator<CurrencyEdge>>,
    Fragmentable {
  node: <T = CurrencySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCurrency {
  count: Int;
}

export interface AggregateCurrencyPromise
  extends Promise<AggregateCurrency>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCurrencySubscription
  extends Promise<AsyncIterator<AggregateCurrency>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpenseUnit {
  id: ID_Output;
  amount: String;
  createdAt: DateTimeOutput;
}

export interface ExpenseUnitPromise extends Promise<ExpenseUnit>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  stockUnit: <T = FragmentableArray<StockUnit>>(args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ExpenseUnitSubscription
  extends Promise<AsyncIterator<ExpenseUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  currency: <T = CurrencySubscription>() => T;
  stockUnit: <T = Promise<AsyncIterator<StockUnitSubscription>>>(args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpenseUnitNullablePromise
  extends Promise<ExpenseUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  currency: <T = CurrencyPromise>() => T;
  stockUnit: <T = FragmentableArray<StockUnit>>(args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface StockUnit {
  id: ID_Output;
  name?: String;
}

export interface StockUnitPromise extends Promise<StockUnit>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  inventory: <T = FragmentableArray<Inventory>>(args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = StockUnitCategoryPromise>() => T;
  expenseUnit: <T = FragmentableArray<ExpenseUnit>>(args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StockUnitSubscription
  extends Promise<AsyncIterator<StockUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  inventory: <T = Promise<AsyncIterator<InventorySubscription>>>(args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = StockUnitCategorySubscription>() => T;
  expenseUnit: <T = Promise<AsyncIterator<ExpenseUnitSubscription>>>(args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StockUnitNullablePromise
  extends Promise<StockUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  inventory: <T = FragmentableArray<Inventory>>(args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = StockUnitCategoryPromise>() => T;
  expenseUnit: <T = FragmentableArray<ExpenseUnit>>(args?: {
    where?: ExpenseUnitWhereInput;
    orderBy?: ExpenseUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Inventory {
  id: ID_Output;
  quantity: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InventoryPromise extends Promise<Inventory>, Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<String>;
  unit: <T = MeasurementUnitPromise>() => T;
  stockUnit: <T = FragmentableArray<StockUnit>>(args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventorySubscription
  extends Promise<AsyncIterator<Inventory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<String>>;
  unit: <T = MeasurementUnitSubscription>() => T;
  stockUnit: <T = Promise<AsyncIterator<StockUnitSubscription>>>(args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryNullablePromise
  extends Promise<Inventory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<String>;
  unit: <T = MeasurementUnitPromise>() => T;
  stockUnit: <T = FragmentableArray<StockUnit>>(args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MeasurementUnit {
  id: ID_Output;
  name: String;
  symbol: String;
}

export interface MeasurementUnitPromise
  extends Promise<MeasurementUnit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  symbol: () => Promise<String>;
}

export interface MeasurementUnitSubscription
  extends Promise<AsyncIterator<MeasurementUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  symbol: () => Promise<AsyncIterator<String>>;
}

export interface MeasurementUnitNullablePromise
  extends Promise<MeasurementUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  symbol: () => Promise<String>;
}

export interface StockUnitCategory {
  id: ID_Output;
  name: String;
}

export interface StockUnitCategoryPromise
  extends Promise<StockUnitCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface StockUnitCategorySubscription
  extends Promise<AsyncIterator<StockUnitCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StockUnitCategoryNullablePromise
  extends Promise<StockUnitCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ExpenseUnitConnection {
  pageInfo: PageInfo;
  edges: ExpenseUnitEdge[];
}

export interface ExpenseUnitConnectionPromise
  extends Promise<ExpenseUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpenseUnitEdge>>() => T;
  aggregate: <T = AggregateExpenseUnitPromise>() => T;
}

export interface ExpenseUnitConnectionSubscription
  extends Promise<AsyncIterator<ExpenseUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpenseUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpenseUnitSubscription>() => T;
}

export interface ExpenseUnitEdge {
  node: ExpenseUnit;
  cursor: String;
}

export interface ExpenseUnitEdgePromise
  extends Promise<ExpenseUnitEdge>,
    Fragmentable {
  node: <T = ExpenseUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpenseUnitEdgeSubscription
  extends Promise<AsyncIterator<ExpenseUnitEdge>>,
    Fragmentable {
  node: <T = ExpenseUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpenseUnit {
  count: Int;
}

export interface AggregateExpenseUnitPromise
  extends Promise<AggregateExpenseUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpenseUnitSubscription
  extends Promise<AsyncIterator<AggregateExpenseUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InventoryConnection {
  pageInfo: PageInfo;
  edges: InventoryEdge[];
}

export interface InventoryConnectionPromise
  extends Promise<InventoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryEdge>>() => T;
  aggregate: <T = AggregateInventoryPromise>() => T;
}

export interface InventoryConnectionSubscription
  extends Promise<AsyncIterator<InventoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventorySubscription>() => T;
}

export interface InventoryEdge {
  node: Inventory;
  cursor: String;
}

export interface InventoryEdgePromise
  extends Promise<InventoryEdge>,
    Fragmentable {
  node: <T = InventoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryEdgeSubscription
  extends Promise<AsyncIterator<InventoryEdge>>,
    Fragmentable {
  node: <T = InventorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInventory {
  count: Int;
}

export interface AggregateInventoryPromise
  extends Promise<AggregateInventory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventorySubscription
  extends Promise<AsyncIterator<AggregateInventory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MeasurementUnitConnection {
  pageInfo: PageInfo;
  edges: MeasurementUnitEdge[];
}

export interface MeasurementUnitConnectionPromise
  extends Promise<MeasurementUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MeasurementUnitEdge>>() => T;
  aggregate: <T = AggregateMeasurementUnitPromise>() => T;
}

export interface MeasurementUnitConnectionSubscription
  extends Promise<AsyncIterator<MeasurementUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MeasurementUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMeasurementUnitSubscription>() => T;
}

export interface MeasurementUnitEdge {
  node: MeasurementUnit;
  cursor: String;
}

export interface MeasurementUnitEdgePromise
  extends Promise<MeasurementUnitEdge>,
    Fragmentable {
  node: <T = MeasurementUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MeasurementUnitEdgeSubscription
  extends Promise<AsyncIterator<MeasurementUnitEdge>>,
    Fragmentable {
  node: <T = MeasurementUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMeasurementUnit {
  count: Int;
}

export interface AggregateMeasurementUnitPromise
  extends Promise<AggregateMeasurementUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMeasurementUnitSubscription
  extends Promise<AsyncIterator<AggregateMeasurementUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  item: <T = StockUnitPromise>() => T;
  stockUnit: <T = FragmentableArray<StockUnit>>(args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  item: <T = StockUnitSubscription>() => T;
  stockUnit: <T = Promise<AsyncIterator<StockUnitSubscription>>>(args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  item: <T = StockUnitPromise>() => T;
  stockUnit: <T = FragmentableArray<StockUnit>>(args?: {
    where?: StockUnitWhereInput;
    orderBy?: StockUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StockUnitConnection {
  pageInfo: PageInfo;
  edges: StockUnitEdge[];
}

export interface StockUnitConnectionPromise
  extends Promise<StockUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StockUnitEdge>>() => T;
  aggregate: <T = AggregateStockUnitPromise>() => T;
}

export interface StockUnitConnectionSubscription
  extends Promise<AsyncIterator<StockUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StockUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStockUnitSubscription>() => T;
}

export interface StockUnitEdge {
  node: StockUnit;
  cursor: String;
}

export interface StockUnitEdgePromise
  extends Promise<StockUnitEdge>,
    Fragmentable {
  node: <T = StockUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StockUnitEdgeSubscription
  extends Promise<AsyncIterator<StockUnitEdge>>,
    Fragmentable {
  node: <T = StockUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStockUnit {
  count: Int;
}

export interface AggregateStockUnitPromise
  extends Promise<AggregateStockUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStockUnitSubscription
  extends Promise<AsyncIterator<AggregateStockUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StockUnitCategoryConnection {
  pageInfo: PageInfo;
  edges: StockUnitCategoryEdge[];
}

export interface StockUnitCategoryConnectionPromise
  extends Promise<StockUnitCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StockUnitCategoryEdge>>() => T;
  aggregate: <T = AggregateStockUnitCategoryPromise>() => T;
}

export interface StockUnitCategoryConnectionSubscription
  extends Promise<AsyncIterator<StockUnitCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StockUnitCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStockUnitCategorySubscription>() => T;
}

export interface StockUnitCategoryEdge {
  node: StockUnitCategory;
  cursor: String;
}

export interface StockUnitCategoryEdgePromise
  extends Promise<StockUnitCategoryEdge>,
    Fragmentable {
  node: <T = StockUnitCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StockUnitCategoryEdgeSubscription
  extends Promise<AsyncIterator<StockUnitCategoryEdge>>,
    Fragmentable {
  node: <T = StockUnitCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStockUnitCategory {
  count: Int;
}

export interface AggregateStockUnitCategoryPromise
  extends Promise<AggregateStockUnitCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStockUnitCategorySubscription
  extends Promise<AsyncIterator<AggregateStockUnitCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CurrencySubscriptionPayload {
  mutation: MutationType;
  node: Currency;
  updatedFields: String[];
  previousValues: CurrencyPreviousValues;
}

export interface CurrencySubscriptionPayloadPromise
  extends Promise<CurrencySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CurrencyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CurrencyPreviousValuesPromise>() => T;
}

export interface CurrencySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CurrencySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CurrencySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CurrencyPreviousValuesSubscription>() => T;
}

export interface CurrencyPreviousValues {
  id: ID_Output;
  symbol: String;
  isDefault?: Boolean;
  createdAt: DateTimeOutput;
}

export interface CurrencyPreviousValuesPromise
  extends Promise<CurrencyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  symbol: () => Promise<String>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CurrencyPreviousValuesSubscription
  extends Promise<AsyncIterator<CurrencyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  symbol: () => Promise<AsyncIterator<String>>;
  isDefault: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpenseUnitSubscriptionPayload {
  mutation: MutationType;
  node: ExpenseUnit;
  updatedFields: String[];
  previousValues: ExpenseUnitPreviousValues;
}

export interface ExpenseUnitSubscriptionPayloadPromise
  extends Promise<ExpenseUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpenseUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpenseUnitPreviousValuesPromise>() => T;
}

export interface ExpenseUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpenseUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpenseUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpenseUnitPreviousValuesSubscription>() => T;
}

export interface ExpenseUnitPreviousValues {
  id: ID_Output;
  amount: String;
  createdAt: DateTimeOutput;
}

export interface ExpenseUnitPreviousValuesPromise
  extends Promise<ExpenseUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ExpenseUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<ExpenseUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventorySubscriptionPayload {
  mutation: MutationType;
  node: Inventory;
  updatedFields: String[];
  previousValues: InventoryPreviousValues;
}

export interface InventorySubscriptionPayloadPromise
  extends Promise<InventorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryPreviousValuesPromise>() => T;
}

export interface InventorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryPreviousValuesSubscription>() => T;
}

export interface InventoryPreviousValues {
  id: ID_Output;
  quantity: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InventoryPreviousValuesPromise
  extends Promise<InventoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventoryPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MeasurementUnitSubscriptionPayload {
  mutation: MutationType;
  node: MeasurementUnit;
  updatedFields: String[];
  previousValues: MeasurementUnitPreviousValues;
}

export interface MeasurementUnitSubscriptionPayloadPromise
  extends Promise<MeasurementUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MeasurementUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MeasurementUnitPreviousValuesPromise>() => T;
}

export interface MeasurementUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MeasurementUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MeasurementUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MeasurementUnitPreviousValuesSubscription>() => T;
}

export interface MeasurementUnitPreviousValues {
  id: ID_Output;
  name: String;
  symbol: String;
}

export interface MeasurementUnitPreviousValuesPromise
  extends Promise<MeasurementUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  symbol: () => Promise<String>;
}

export interface MeasurementUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<MeasurementUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  symbol: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StockUnitSubscriptionPayload {
  mutation: MutationType;
  node: StockUnit;
  updatedFields: String[];
  previousValues: StockUnitPreviousValues;
}

export interface StockUnitSubscriptionPayloadPromise
  extends Promise<StockUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StockUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StockUnitPreviousValuesPromise>() => T;
}

export interface StockUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StockUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StockUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StockUnitPreviousValuesSubscription>() => T;
}

export interface StockUnitPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface StockUnitPreviousValuesPromise
  extends Promise<StockUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface StockUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<StockUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StockUnitCategorySubscriptionPayload {
  mutation: MutationType;
  node: StockUnitCategory;
  updatedFields: String[];
  previousValues: StockUnitCategoryPreviousValues;
}

export interface StockUnitCategorySubscriptionPayloadPromise
  extends Promise<StockUnitCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StockUnitCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StockUnitCategoryPreviousValuesPromise>() => T;
}

export interface StockUnitCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StockUnitCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StockUnitCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StockUnitCategoryPreviousValuesSubscription>() => T;
}

export interface StockUnitCategoryPreviousValues {
  id: ID_Output;
  name: String;
}

export interface StockUnitCategoryPreviousValuesPromise
  extends Promise<StockUnitCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface StockUnitCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<StockUnitCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "ExpenseUnit",
    embedded: false
  },
  {
    name: "StockUnitCategory",
    embedded: false
  },
  {
    name: "Inventory",
    embedded: false
  },
  {
    name: "MeasurementUnit",
    embedded: false
  },
  {
    name: "StockUnit",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Currency",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://116.203.108.46:4466`
});
export const prisma = new Prisma();
